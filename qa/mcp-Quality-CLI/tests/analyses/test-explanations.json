[
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Comandos PT simples > should detect FULL mode from \"analise meu reposit√≥rio\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **FULL** a partir da entrada \"analise meu reposit√≥rio\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"full\"`, `result.final_params.mode` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Comandos PT simples > should detect ANALYZE mode from \"apenas analisar o c√≥digo\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **ANALYZE** a partir da entrada \"apenas analisar o c√≥digo\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"analyze\"`, `result.final_params.mode` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Comandos PT simples > should detect PLAN mode from \"criar plano de testes\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **PLAN** a partir da entrada \"criar plano de testes\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"plan\"`, `result.final_params.mode` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Comandos PT simples > should detect RUN mode from \"rodar testes e calcular cobertura\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **RUN** a partir da entrada \"rodar testes e calcular cobertura\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"run\"`, `result.final_params.mode` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should detect FULL mode from \"analise meu reposit√≥rio\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **FULL** a partir da entrada \"analise meu reposit√≥rio\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"full\"`, `result.final_params.mode` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should detect ANALYZE mode from \"apenas analisar o c√≥digo\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **ANALYZE** a partir da entrada \"apenas analisar o c√≥digo\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"analyze\"`, `result.final_params.mode` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should detect PLAN mode from \"criar plano de testes\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **PLAN** a partir da entrada \"criar plano de testes\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"plan\"`, `result.final_params.mode` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should detect RUN mode from \"rodar testes e calcular cobertura\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **RUN** a partir da entrada \"rodar testes e calcular cobertura\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"run\"`, `result.final_params.mode` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Comandos EN simples > should detect FULL mode from \"run all tests\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **FULL** a partir da entrada \"run all tests\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.detected_mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Comandos EN simples > should detect ANALYZE mode from \"only analyze\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **ANALYZE** a partir da entrada \"only analyze\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.detected_mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Comandos EN simples > should detect PLAN mode from \"generate test plan\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **PLAN** a partir da entrada \"generate test plan\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.detected_mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should detect FULL mode from \"run all tests\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **FULL** a partir da entrada \"run all tests\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.detected_mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should detect ANALYZE mode from \"only analyze\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **ANALYZE** a partir da entrada \"only analyze\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.detected_mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should detect PLAN mode from \"generate test plan\"",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue detectar modo **PLAN** a partir da entrada \"generate test plan\". **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.detected_mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Overrides no texto > should extract repo override",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue extract repo override. **Valida√ß√µes**: `result.success` = `true`, `result.extracted_params.repo` = `\"tempDir\"`, `result.final_params.repo` = `\"tempDir\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "result.extracted_params.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "result.final_params.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Overrides no texto > should extract mode override",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue extract mode override. **Valida√ß√µes**: `result.success` = `true`, `result.extracted_params.mode` = `\"run\"`, `result.final_params.mode` = `\"run\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "result.extracted_params.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Overrides no texto > should extract multiple overrides",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue extract multiple overrides. **Valida√ß√µes**: `result.success` = `true`, `result.extracted_params.repo` = `\"tempDir\"`, `result.extracted_params.product` = `\"TestApp\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "result.extracted_params.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "TestApp",
        "path": "result.extracted_params.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.extracted_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should extract repo override",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue extract repo override. **Valida√ß√µes**: `result.success` = `true`, `result.extracted_params.repo` = `\"tempDir\"`, `result.final_params.repo` = `\"tempDir\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "result.extracted_params.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "result.final_params.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should extract mode override",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue extract mode override. **Valida√ß√µes**: `result.success` = `true`, `result.extracted_params.mode` = `\"run\"`, `result.final_params.mode` = `\"run\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "result.extracted_params.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "result.final_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should extract multiple overrides",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue extract multiple overrides. **Valida√ß√µes**: `result.success` = `true`, `result.extracted_params.repo` = `\"tempDir\"`, `result.extracted_params.product` = `\"TestApp\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "result.extracted_params.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "TestApp",
        "path": "result.extracted_params.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.extracted_params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Defaults globais > should apply defaults when no override present",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue apply defaults when no override present. **Valida√ß√µes**: `result.success` = `true`, `result.final_params.repo` = `\"tempDir\"`, `result.final_params.product` = `\"DefaultProduct\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "result.final_params.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "DefaultProduct",
        "path": "result.final_params.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Defaults globais > should prioritize explicit overrides over defaults",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue prioritize explicit overrides over defaults. **Valida√ß√µes**: `result.success` = `true`, `result.final_params.product` = `\"ExplicitProduct\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "ExplicitProduct",
        "path": "result.final_params.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should apply defaults when no override present",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue apply defaults when no override present. **Valida√ß√µes**: `result.success` = `true`, `result.final_params.repo` = `\"tempDir\"`, `result.final_params.product` = `\"DefaultProduct\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "result.final_params.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "DefaultProduct",
        "path": "result.final_params.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should prioritize explicit overrides over defaults",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue prioritize explicit overrides over defaults. **Valida√ß√µes**: `result.success` = `true`, `result.final_params.product` = `\"ExplicitProduct\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "ExplicitProduct",
        "path": "result.final_params.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Error handling > should handle empty query gracefully",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue handle empty query gracefully. **2 valida√ß√µes** usando: toBeDefined, toBeDefined",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "Error handling > should handle query with only whitespace",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue handle query with only whitespace. **2 valida√ß√µes** usando: toBeDefined, toBeDefined",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should handle empty query gracefully",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue handle empty query gracefully. **2 valida√ß√µes** usando: toBeDefined, toBeDefined",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
    "name": "should handle query with only whitespace",
    "testType": "e2e",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue handle query with only whitespace. **2 valida√ß√µes** usando: toBeDefined, toBeDefined",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "E2E: quality init-product > deve criar estrutura completa de QA",
    "testType": "e2e",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar estrutura completa de QA. **Valida√ß√µes**: `result.ok` = `true`, `result.path` = `\"EcommerceApp\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "EcommerceApp",
        "path": "result.path"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "E2E: quality init-product > deve criar mcp-settings.json com configura√ß√µes corretas",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar mcp-settings.json com configura√ß√µes corretas. **Valida√ß√µes**: `settings` = `\"{...}\"`, `settings.environments` = `\"dev\"`, `settings.environments` = `\"stg\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toMatchObject, toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settingsPath = ...",
      "settingsContent = ...",
      "settings = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "settings"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "dev",
        "path": "settings.environments"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "stg",
        "path": "settings.environments"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "prod",
        "path": "settings.environments"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "E2E: quality init-product > deve criar estrutura de diret√≥rios completa",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar estrutura de diret√≥rios completa. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "qaDir = ...",
      "expectedDirs = ...",
      "dirPath = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "E2E: quality init-product > deve criar GETTING_STARTED.md com documenta√ß√£o",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar GETTING_STARTED.md com documenta√ß√£o. **Valida√ß√µes**: `content` = `\"EcommerceApp\"`, `content` = `\"Quality MCP\"`, `content` = `\"analyze\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "gettingStartedPath = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "EcommerceApp",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quality MCP",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "E2E: quality init-product > deve criar README.md",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar README.md. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "readmePath = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "E2E: quality init-product > deve criar .gitignore apropriado",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar .gitignore apropriado. **Valida√ß√µes**: `content` = `\"node_modules/\"`, `content` = `\"coverage/\"`, `content` = `\"playwright-report/\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "gitignorePath = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "node_modules/",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "coverage/",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "playwright-report/",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".env",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "E2E: quality init-product > n√£o deve sobrescrever mcp-settings.json existente",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sobrescrever mcp-settings.json existente. **Valida√ß√µes**: `newSettings.custom_field` = `\"should_persist\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "settingsPath = ...",
      "originalSettings = ...",
      "newSettings = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "should_persist",
        "path": "newSettings.custom_field"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "E2E: quality init-product > deve permitir criar m√∫ltiplos produtos no mesmo repo",
    "testType": "e2e",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue permitir criar m√∫ltiplos produtos no mesmo repo. **Valida√ß√µes**: `ecommerceExists` = `true`, `paymentExists` = `true`, `ecommerceSettings.product` = `\"EcommerceApp\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "ecommerceExists = ...",
      "paymentExists = ...",
      "ecommerceSettings = ...",
      "paymentSettings = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "ecommerceExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "paymentExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "EcommerceApp",
        "path": "ecommerceSettings.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://www.ecommerce.com",
        "path": "ecommerceSettings.base_url"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "PaymentService",
        "path": "paymentSettings.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://api.payment.com",
        "path": "paymentSettings.base_url"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "deve criar estrutura completa de QA",
    "testType": "e2e",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar estrutura completa de QA. **Valida√ß√µes**: `result.ok` = `true`, `result.path` = `\"EcommerceApp\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "EcommerceApp",
        "path": "result.path"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "deve criar mcp-settings.json com configura√ß√µes corretas",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar mcp-settings.json com configura√ß√µes corretas. **Valida√ß√µes**: `settings` = `\"{...}\"`, `settings.environments` = `\"dev\"`, `settings.environments` = `\"stg\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toMatchObject, toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settingsPath = ...",
      "settingsContent = ...",
      "settings = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "settings"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "dev",
        "path": "settings.environments"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "stg",
        "path": "settings.environments"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "prod",
        "path": "settings.environments"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "deve criar estrutura de diret√≥rios completa",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar estrutura de diret√≥rios completa. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "qaDir = ...",
      "expectedDirs = ...",
      "dirPath = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "deve criar GETTING_STARTED.md com documenta√ß√£o",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar GETTING_STARTED.md com documenta√ß√£o. **Valida√ß√µes**: `content` = `\"EcommerceApp\"`, `content` = `\"Quality MCP\"`, `content` = `\"analyze\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "gettingStartedPath = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "EcommerceApp",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quality MCP",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "deve criar README.md",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar README.md. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "readmePath = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "deve criar .gitignore apropriado",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar .gitignore apropriado. **Valida√ß√µes**: `content` = `\"node_modules/\"`, `content` = `\"coverage/\"`, `content` = `\"playwright-report/\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "gitignorePath = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "node_modules/",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "coverage/",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "playwright-report/",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".env",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "n√£o deve sobrescrever mcp-settings.json existente",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sobrescrever mcp-settings.json existente. **Valida√ß√µes**: `newSettings.custom_field` = `\"should_persist\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "settingsPath = ...",
      "originalSettings = ...",
      "newSettings = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "should_persist",
        "path": "newSettings.custom_field"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
    "name": "deve permitir criar m√∫ltiplos produtos no mesmo repo",
    "testType": "e2e",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue permitir criar m√∫ltiplos produtos no mesmo repo. **Valida√ß√µes**: `ecommerceExists` = `true`, `paymentExists` = `true`, `ecommerceSettings.product` = `\"EcommerceApp\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "ecommerceExists = ...",
      "paymentExists = ...",
      "ecommerceSettings = ...",
      "paymentSettings = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "ecommerceExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "paymentExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "EcommerceApp",
        "path": "ecommerceSettings.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://www.ecommerce.com",
        "path": "ecommerceSettings.base_url"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "PaymentService",
        "path": "paymentSettings.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://api.payment.com",
        "path": "paymentSettings.base_url"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/diff-coverage-gate.spec.ts",
    "name": "E2E: quality diff-coverage (CI gate) > deve ter a tool diff-coverage dispon√≠vel",
    "testType": "e2e",
    "functionUnderTest": ".toBeDefined",
    "whatItTests": "Valida que **`.toBeDefined`** consegue ter a tool diff-coverage dispon√≠vel. **Valida√ß√µes**: `unknown` = `\"function\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeDefined",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "runDiffCoverage"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "function",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/diff-coverage-gate.spec.ts",
    "name": "E2E: quality diff-coverage (CI gate) > deve exportar schema de par√¢metros",
    "testType": "e2e",
    "functionUnderTest": ".toBeDefined",
    "whatItTests": "Valida que **`.toBeDefined`** consegue exportar schema de par√¢metros. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "module = ..."
    ],
    "when": ".toBeDefined",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "module"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/diff-coverage-gate.spec.ts",
    "name": "deve ter a tool diff-coverage dispon√≠vel",
    "testType": "e2e",
    "functionUnderTest": ".toBeDefined",
    "whatItTests": "Valida que **`.toBeDefined`** consegue ter a tool diff-coverage dispon√≠vel. **Valida√ß√µes**: `unknown` = `\"function\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeDefined",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "runDiffCoverage"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "function",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/diff-coverage-gate.spec.ts",
    "name": "deve exportar schema de par√¢metros",
    "testType": "e2e",
    "functionUnderTest": ".toBeDefined",
    "whatItTests": "Valida que **`.toBeDefined`** consegue exportar schema de par√¢metros. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "module = ..."
    ],
    "when": ".toBeDefined",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "module"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "FULL mode em diferentes contextos > should work in empty repo",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue work in empty repo. **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "FULL mode em diferentes contextos > should work in repo with package.json",
    "testType": "e2e",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue work in repo with package.json. **Valida√ß√µes**: `result.ok` = `true`, `result.context.hasPackageJson` = `true`, `result.context.testFramework` = `\"vitest\"`",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.context.hasPackageJson"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.context.testFramework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "FULL mode em diferentes contextos > should work with existing mcp-settings.json",
    "testType": "e2e",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue work with existing mcp-settings.json. **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should work in empty repo",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue work in empty repo. **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should work in repo with package.json",
    "testType": "e2e",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue work in repo with package.json. **Valida√ß√µes**: `result.ok` = `true`, `result.context.hasPackageJson` = `true`, `result.context.testFramework` = `\"vitest\"`",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.context.hasPackageJson"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.context.testFramework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should work with existing mcp-settings.json",
    "testType": "e2e",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue work with existing mcp-settings.json. **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Modos parciais > should execute ANALYZE mode correctly",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue executar corretamente o modo **ANALYZE** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `ANALYZE` corretamente. Confirma que o contexto de execu√ß√£o foi inicializado (`result.context`). Confirma que os outputs foram gerados (`result.outputs`)",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.outputs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Modos parciais > should execute PLAN mode correctly",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue executar corretamente o modo **PLAN** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `PLAN` corretamente. Confirma que o contexto de execu√ß√£o foi inicializado (`result.context`). Confirma que os outputs foram gerados (`result.outputs`)",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.outputs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should execute ANALYZE mode correctly",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue executar corretamente o modo **ANALYZE** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `ANALYZE` corretamente. Confirma que o contexto de execu√ß√£o foi inicializado (`result.context`). Confirma que os outputs foram gerados (`result.outputs`)",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.outputs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should execute PLAN mode correctly",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue executar corretamente o modo **PLAN** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `PLAN` corretamente. Confirma que o contexto de execu√ß√£o foi inicializado (`result.context`). Confirma que os outputs foram gerados (`result.outputs`)",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.outputs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Auto-detec√ß√£o de contexto > should auto-detect repo from cwd",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue auto-detect repo from cwd. **Valida√ß√µes**: `result.ok` = `true`, `result.context.repoPath.length` = `0`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.repoPath"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.context.repoPath.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Auto-detec√ß√£o de contexto > should infer product from package.json",
    "testType": "e2e",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue infer product from package.json. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should auto-detect repo from cwd",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue auto-detect repo from cwd. **Valida√ß√µes**: `result.ok` = `true`, `result.context.repoPath.length` = `0`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.repoPath"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.context.repoPath.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should infer product from package.json",
    "testType": "e2e",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue infer product from package.json. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Cria√ß√£o de estrutura de artifacts > should create qa/<product>/ directory structure",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue create qa/<product>/ directory structure. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Cria√ß√£o de estrutura de artifacts > should generate all expected artifacts in FULL mode",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue generate all expected artifacts in FULL mode. **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`, `result.steps` = `\"analyze\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan, toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.outputs"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should create qa/<product>/ directory structure",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue create qa/<product>/ directory structure. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should generate all expected artifacts in FULL mode",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue generate all expected artifacts in FULL mode. **Valida√ß√µes**: `result.ok` = `true`, `result.steps.length` = `0`, `result.steps` = `\"analyze\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan, toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.outputs"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.steps.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Error handling > should handle invalid repo path gracefully",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue handle invalid repo path gracefully. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Error handling > should handle missing product name",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue handle missing product name. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Error handling > should handle filesystem errors gracefully",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue handle filesystem errors gracefully. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should handle invalid repo path gracefully",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue handle invalid repo path gracefully. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should handle missing product name",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue handle missing product name. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.context.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should handle filesystem errors gracefully",
    "testType": "e2e",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue handle filesystem errors gracefully. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Integration with existing test framework > should detect vitest framework",
    "testType": "e2e",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue detect vitest framework. **Valida√ß√µes**: `result.ok` = `true`, `result.context.testFramework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.context.testFramework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "Integration with existing test framework > should detect existing test files",
    "testType": "e2e",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect existing test files. **Valida√ß√µes**: `result.ok` = `true`, `result.context.hasTests` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.context.hasTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should detect vitest framework",
    "testType": "e2e",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue detect vitest framework. **Valida√ß√µes**: `result.ok` = `true`, `result.context.testFramework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.context.testFramework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
    "name": "should detect existing test files",
    "testType": "e2e",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect existing test files. **Valida√ß√µes**: `result.ok` = `true`, `result.context.hasTests` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.context.hasTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "E2E: quality analyze ‚Üí quality coverage > deve executar analyze e detectar endpoints",
    "testType": "e2e",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue executar analyze e detectar endpoints. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "E2E: quality analyze ‚Üí quality coverage > deve criar analyze.json com findings",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar analyze.json com findings. **Valida√ß√µes**: `exists` = `true`, `content` = `\"findings\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "analyzePath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "findings",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "E2E: quality analyze ‚Üí quality coverage > deve permitir pipeline completo: analyze ‚Üí coverage ‚Üí plan",
    "testType": "e2e",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue permitir pipeline completo: analyze ‚Üí coverage ‚Üí plan. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeResult = ...",
      "coverageResult = ...",
      "planResult = ...",
      "testsDir = ...",
      "exists = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeResult.findings"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "coverageResult.pyramid"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "planResult.plan"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "E2E: quality analyze ‚Üí quality coverage > deve usar configura√ß√£o centralizada de mcp-settings.json",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue usar configura√ß√£o centralizada de mcp-settings.json. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "settingsPath = ...",
      "settings = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "E2E: quality analyze ‚Üí quality coverage > deve validar health da pir√¢mide corretamente",
    "testType": "e2e",
    "functionUnderTest": "analyzeTestCoverage",
    "whatItTests": "Valida que **`analyzeTestCoverage`** consegue validar health da pir√¢mide corretamente. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "deve executar analyze e detectar endpoints",
    "testType": "e2e",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue executar analyze e detectar endpoints. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "deve criar analyze.json com findings",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar analyze.json com findings. **Valida√ß√µes**: `exists` = `true`, `content` = `\"findings\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "analyzePath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "findings",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "deve permitir pipeline completo: analyze ‚Üí coverage ‚Üí plan",
    "testType": "e2e",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue permitir pipeline completo: analyze ‚Üí coverage ‚Üí plan. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeResult = ...",
      "coverageResult = ...",
      "planResult = ...",
      "testsDir = ...",
      "exists = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeResult.findings"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "coverageResult.pyramid"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "planResult.plan"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "deve usar configura√ß√£o centralizada de mcp-settings.json",
    "testType": "e2e",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue usar configura√ß√£o centralizada de mcp-settings.json. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "settingsPath = ...",
      "settings = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
    "name": "deve validar health da pir√¢mide corretamente",
    "testType": "e2e",
    "functionUnderTest": "analyzeTestCoverage",
    "whatItTests": "Valida que **`analyzeTestCoverage`** consegue validar health da pir√¢mide corretamente. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "analyze_codebase > deve validar par√¢metros v√°lidos",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar par√¢metros v√°lidos. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "AnalyzeSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('analyze_codebase > deve validar par√¢metros v√°lidos...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('analyze_codebase > deve validar par√¢metros v√°lidos...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "analyze_codebase > deve rejeitar sem repo",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue rejeitar sem repo. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "AnalyzeSchema = ...",
      "invalidData = ..."
    ],
    "when": "z.object",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "QualityMCPServer - Schema Validations > deve validar par√¢metros v√°lidos",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar par√¢metros v√°lidos. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "AnalyzeSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('QualityMCPServer - Schema Validations > deve valid...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('QualityMCPServer - Schema Validations > deve valid...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "QualityMCPServer - Schema Validations > deve rejeitar sem repo",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue rejeitar sem repo. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "AnalyzeSchema = ...",
      "invalidData = ..."
    ],
    "when": "z.object",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "generate_test_plan > deve validar URL v√°lida",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar URL v√°lida. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "PlanSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('generate_test_plan > deve validar URL v√°lida...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('generate_test_plan > deve validar URL v√°lida...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "generate_test_plan > deve rejeitar URL inv√°lida",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue rejeitar URL inv√°lida. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "PlanSchema = ..."
    ],
    "when": "z.object",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "QualityMCPServer - Schema Validations > deve validar URL v√°lida",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar URL v√°lida. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "PlanSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('QualityMCPServer - Schema Validations > deve valid...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('QualityMCPServer - Schema Validations > deve valid...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "QualityMCPServer - Schema Validations > deve rejeitar URL inv√°lida",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue rejeitar URL inv√°lida. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "PlanSchema = ..."
    ],
    "when": "z.object",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "init_product > deve validar nome de produto alphanumeric",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue validar nome de produto alphanumeric. **Valida√ß√µes**: `regex.test()` = `true`, `regex.test()` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "regex.test()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "init_product > deve validar schema completo",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar schema completo. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "InitSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('init_product > deve validar schema completo...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('init_product > deve validar schema completo...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "QualityMCPServer - Schema Validations > deve validar nome de produto alphanumeric",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue validar nome de produto alphanumeric. **Valida√ß√µes**: `regex.test()` = `true`, `regex.test()` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "regex.test()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "QualityMCPServer - Schema Validations > deve validar schema completo",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar schema completo. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "InitSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('QualityMCPServer - Schema Validations > deve valid...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('QualityMCPServer - Schema Validations > deve valid...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "Tool Names > deve ter todos os nomes de tools essenciais",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter todos os nomes de tools essenciais. **Valida√ß√µes**: `toolNames` = `16`, `toolNames` = `\"nl_command\"`, `toolNames` = `\"auto\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "toolNames = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 16,
        "path": "toolNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "nl_command",
        "path": "toolNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "auto",
        "path": "toolNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "QualityMCPServer - Schema Validations > deve ter todos os nomes de tools essenciais",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter todos os nomes de tools essenciais. **Valida√ß√µes**: `toolNames` = `16`, `toolNames` = `\"nl_command\"`, `toolNames` = `\"auto\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "toolNames = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 16,
        "path": "toolNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "nl_command",
        "path": "toolNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "auto",
        "path": "toolNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "analyze_codebase > deve validar par√¢metros v√°lidos",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar par√¢metros v√°lidos. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "AnalyzeSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('analyze_codebase > deve validar par√¢metros v√°lidos...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('analyze_codebase > deve validar par√¢metros v√°lidos...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "analyze_codebase > deve rejeitar sem repo",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue rejeitar sem repo. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "AnalyzeSchema = ...",
      "invalidData = ..."
    ],
    "when": "z.object",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "deve validar par√¢metros v√°lidos",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar par√¢metros v√°lidos. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "AnalyzeSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve validar par√¢metros v√°lidos...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve validar par√¢metros v√°lidos...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "deve rejeitar sem repo",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue rejeitar sem repo. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "AnalyzeSchema = ...",
      "invalidData = ..."
    ],
    "when": "z.object",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "generate_test_plan > deve validar URL v√°lida",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar URL v√°lida. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "PlanSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('generate_test_plan > deve validar URL v√°lida...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('generate_test_plan > deve validar URL v√°lida...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "generate_test_plan > deve rejeitar URL inv√°lida",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue rejeitar URL inv√°lida. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "PlanSchema = ..."
    ],
    "when": "z.object",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "deve validar URL v√°lida",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar URL v√°lida. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "PlanSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve validar URL v√°lida...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve validar URL v√°lida...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "deve rejeitar URL inv√°lida",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue rejeitar URL inv√°lida. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "PlanSchema = ..."
    ],
    "when": "z.object",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "init_product > deve validar nome de produto alphanumeric",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue validar nome de produto alphanumeric. **Valida√ß√µes**: `regex.test()` = `true`, `regex.test()` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "regex.test()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "init_product > deve validar schema completo",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar schema completo. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "InitSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('init_product > deve validar schema completo...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('init_product > deve validar schema completo...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "deve validar nome de produto alphanumeric",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue validar nome de produto alphanumeric. **Valida√ß√µes**: `regex.test()` = `true`, `regex.test()` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "regex.test()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "deve validar schema completo",
    "testType": "unit",
    "functionUnderTest": "z.object",
    "whatItTests": "Valida que **`z.object`** consegue validar schema completo. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "InitSchema = ...",
      "validData = ..."
    ],
    "when": "z.object",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve validar schema completo...', () => {\n  const result = z.object(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve validar schema completo...', () => {\n  const result = z.object(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "Tool Names > deve ter todos os nomes de tools essenciais",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter todos os nomes de tools essenciais. **Valida√ß√µes**: `toolNames` = `16`, `toolNames` = `\"nl_command\"`, `toolNames` = `\"auto\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "toolNames = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 16,
        "path": "toolNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "nl_command",
        "path": "toolNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "auto",
        "path": "toolNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.test.ts",
    "name": "deve ter todos os nomes de tools essenciais",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter todos os nomes de tools essenciais. **Valida√ß√µes**: `toolNames` = `16`, `toolNames` = `\"nl_command\"`, `toolNames` = `\"auto\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "toolNames = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 16,
        "path": "toolNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "nl_command",
        "path": "toolNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "auto",
        "path": "toolNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve inicializar produto via init-product",
    "testType": "integration",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue inicializar produto via init-product. **Valida√ß√µes**: `result` = `\"{...}\"`, `result.path` = `\"ServerTestApp\"`, `exists` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toMatchObject, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "settingsPath = ...",
      "exists = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "ServerTestApp",
        "path": "result.path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve executar analyze e retornar findings",
    "testType": "integration",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue executar analyze e retornar findings. **Valida√ß√µes**: `result` = `\"findings\"`, `result.findings` = `\"routes\"`, `result.findings` = `\"endpoints\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "findings",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "routes",
        "path": "result.findings"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "endpoints",
        "path": "result.findings"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "events",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve executar coverage e calcular pir√¢mide",
    "testType": "integration",
    "functionUnderTest": "analyzeTestCoverage",
    "whatItTests": "Valida que **`analyzeTestCoverage`** consegue executar coverage e calcular pir√¢mide. **Valida√ß√µes**: `result` = `\"pyramid\"`, `result.pyramid` = `\"{...}\"`, `result.health` = `{}`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveProperty, toMatchObject, toMatch",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "pyramid",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.pyramid"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.health"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve gerar plano baseado em an√°lise",
    "testType": "integration",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue gerar plano baseado em an√°lise. **Valida√ß√µes**: `result` = `\"{...}\"`, `result.plan` = `{}`, `exists` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toMatchObject, toMatch, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "exists = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.plan"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve validar par√¢metros com schemas Zod",
    "testType": "integration",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue validar par√¢metros com schemas Zod. **Valida√ß√µes**: `result` = `\"findings\"`, `result.findings` = `\"object\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveProperty, toBeTypeOf",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "findings",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBeTypeOf",
        "value": "object",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve integrar config centralizado de mcp-settings.json",
    "testType": "integration",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue integrar config centralizado de mcp-settings.json. **Valida√ß√µes**: `result` = `\"findings\"`, `result.findings` = `\"object\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveProperty, toBeTypeOf",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "settingsPath = ...",
      "settings = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "findings",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBeTypeOf",
        "value": "object",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve gerar catalog de cen√°rios",
    "testType": "integration",
    "functionUnderTest": "catalogScenarios",
    "whatItTests": "Valida que **`catalogScenarios`** consegue gerar catalog de cen√°rios. **Valida√ß√µes**: `result` = `\"product\"`, `result` = `\"total_scenarios\"`, `result.total_scenarios` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveProperty, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "catalogScenarios",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "product",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "total_scenarios",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.total_scenarios"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve recomendar estrat√©gia de testes",
    "testType": "integration",
    "functionUnderTest": "recommendTestStrategy",
    "whatItTests": "Valida que **`recommendTestStrategy`** consegue recomendar estrat√©gia de testes. **Valida√ß√µes**: `result` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toMatchObject, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ..."
    ],
    "when": "recommendTestStrategy",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve scaffold de unit tests funcionar",
    "testType": "integration",
    "functionUnderTest": "scaffoldUnitTests",
    "whatItTests": "Valida que **`scaffoldUnitTests`** consegue scaffold de unit tests funcionar. **Valida√ß√µes**: `result` = `\"{...}\"`, `Array.isArray()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldUnitTests",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "Integration: MCP Server Tools > deve scaffold de integration tests funcionar",
    "testType": "integration",
    "functionUnderTest": "scaffoldIntegrationTests",
    "whatItTests": "Valida que **`scaffoldIntegrationTests`** consegue scaffold de integration tests funcionar. **Valida√ß√µes**: `result` = `\"{...}\"`, `Array.isArray()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldIntegrationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve inicializar produto via init-product",
    "testType": "integration",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue inicializar produto via init-product. **Valida√ß√µes**: `result` = `\"{...}\"`, `result.path` = `\"ServerTestApp\"`, `exists` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toMatchObject, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "settingsPath = ...",
      "exists = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "ServerTestApp",
        "path": "result.path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve executar analyze e retornar findings",
    "testType": "integration",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue executar analyze e retornar findings. **Valida√ß√µes**: `result` = `\"findings\"`, `result.findings` = `\"routes\"`, `result.findings` = `\"endpoints\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "findings",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "routes",
        "path": "result.findings"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "endpoints",
        "path": "result.findings"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "events",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve executar coverage e calcular pir√¢mide",
    "testType": "integration",
    "functionUnderTest": "analyzeTestCoverage",
    "whatItTests": "Valida que **`analyzeTestCoverage`** consegue executar coverage e calcular pir√¢mide. **Valida√ß√µes**: `result` = `\"pyramid\"`, `result.pyramid` = `\"{...}\"`, `result.health` = `{}`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveProperty, toMatchObject, toMatch",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "pyramid",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.pyramid"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.health"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve gerar plano baseado em an√°lise",
    "testType": "integration",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue gerar plano baseado em an√°lise. **Valida√ß√µes**: `result` = `\"{...}\"`, `result.plan` = `{}`, `exists` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toMatchObject, toMatch, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "exists = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.plan"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve validar par√¢metros com schemas Zod",
    "testType": "integration",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue validar par√¢metros com schemas Zod. **Valida√ß√µes**: `result` = `\"findings\"`, `result.findings` = `\"object\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveProperty, toBeTypeOf",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "findings",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBeTypeOf",
        "value": "object",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve integrar config centralizado de mcp-settings.json",
    "testType": "integration",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue integrar config centralizado de mcp-settings.json. **Valida√ß√µes**: `result` = `\"findings\"`, `result.findings` = `\"object\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveProperty, toBeTypeOf",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "settingsPath = ...",
      "settings = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "findings",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBeTypeOf",
        "value": "object",
        "path": "result.findings"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve gerar catalog de cen√°rios",
    "testType": "integration",
    "functionUnderTest": "catalogScenarios",
    "whatItTests": "Valida que **`catalogScenarios`** consegue gerar catalog de cen√°rios. **Valida√ß√µes**: `result` = `\"product\"`, `result` = `\"total_scenarios\"`, `result.total_scenarios` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveProperty, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "catalogScenarios",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "product",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "total_scenarios",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.total_scenarios"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve recomendar estrat√©gia de testes",
    "testType": "integration",
    "functionUnderTest": "recommendTestStrategy",
    "whatItTests": "Valida que **`recommendTestStrategy`** consegue recomendar estrat√©gia de testes. **Valida√ß√µes**: `result` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toMatchObject, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ..."
    ],
    "when": "recommendTestStrategy",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve scaffold de unit tests funcionar",
    "testType": "integration",
    "functionUnderTest": "scaffoldUnitTests",
    "whatItTests": "Valida que **`scaffoldUnitTests`** consegue scaffold de unit tests funcionar. **Valida√ß√µes**: `result` = `\"{...}\"`, `Array.isArray()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldUnitTests",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/server.integration.test.ts",
    "name": "deve scaffold de integration tests funcionar",
    "testType": "integration",
    "functionUnderTest": "scaffoldIntegrationTests",
    "whatItTests": "Valida que **`scaffoldIntegrationTests`** consegue scaffold de integration tests funcionar. **Valida√ß√µes**: `result` = `\"{...}\"`, `Array.isArray()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldIntegrationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > deve ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates)",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates). **Valida√ß√µes**: `MCP_TOOLS` = `10`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 10,
        "path": "MCP_TOOLS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > tools devem ter propriedades obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue MCP Tools Manifest > tools devem ter propriedades obrigat√≥rias. **Valida√ß√µes**: `tool` = `\"name\"`, `tool` = `\"description\"`, `tool` = `\"inputSchema\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "tool"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "tool"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "inputSchema",
        "path": "tool"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "object",
        "path": "tool.inputSchema.type"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > deve conter todos os 5 tools esperados",
    "testType": "unit",
    "functionUnderTest": "MCP_TOOLS.map",
    "whatItTests": "Valida que **`MCP_TOOLS.map`** consegue conter todos os 5 tools esperados. **Valida√ß√µes**: `names` = `\"name\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "expected = ...",
      "names = ..."
    ],
    "when": "MCP_TOOLS.map",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "name",
        "path": "names"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > findTool deve encontrar tool por nome",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue encontrar tool por nome. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tool = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "tool"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > findTool deve retornar undefined para tool inexistente",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue retornar undefined para tool inexistente. **1 valida√ß√µes** usando: toBeUndefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeUndefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tool = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "value",
        "matcher": "toBeUndefined",
        "path": "tool"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > tool analyze deve ter campos repo e product obrigat√≥rios",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue ter campos repo e product obrigat√≥rios. **Valida√ß√µes**: `tool.inputSchema.required` = `\"repo\"`, `tool.inputSchema.required` = `\"product\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tool = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "tool.inputSchema.required"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "tool.inputSchema.required"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > tool validate deve ter campos de threshold",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue ter campos de threshold. **Valida√ß√µes**: `props` = `\"minBranch\"`, `props` = `\"minMutation\"`, `props` = `\"minDiffCoverage\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "tool = ...",
      "props = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "minBranch",
        "path": "props"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "minMutation",
        "path": "props"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "minDiffCoverage",
        "path": "props"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > tool scaffold deve ter campo type com enum",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue ter campo type com enum. **Valida√ß√µes**: `typeField.enum` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tool = ...",
      "typeField = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "typeField.enum"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "MCP Tools Manifest > todos os tools devem ter description com emoji",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue MCP Tools Manifest > todos os tools devem ter description com emoji. **Valida√ß√µes**: `tool.description.length` = `10`, `tool.description.charCodeAt()` = `255`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 10,
        "path": "tool.description.length"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 255,
        "path": "tool.description.charCodeAt()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "deve ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates)",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates). **Valida√ß√µes**: `MCP_TOOLS` = `10`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 10,
        "path": "MCP_TOOLS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "tools devem ter propriedades obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue tools devem ter propriedades obrigat√≥rias. **Valida√ß√µes**: `tool` = `\"name\"`, `tool` = `\"description\"`, `tool` = `\"inputSchema\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "tool"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "tool"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "inputSchema",
        "path": "tool"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "object",
        "path": "tool.inputSchema.type"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "deve conter todos os 5 tools esperados",
    "testType": "unit",
    "functionUnderTest": "MCP_TOOLS.map",
    "whatItTests": "Valida que **`MCP_TOOLS.map`** consegue conter todos os 5 tools esperados. **Valida√ß√µes**: `names` = `\"name\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "expected = ...",
      "names = ..."
    ],
    "when": "MCP_TOOLS.map",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "name",
        "path": "names"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "findTool deve encontrar tool por nome",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue encontrar tool por nome. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tool = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "tool"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "findTool deve retornar undefined para tool inexistente",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue retornar undefined para tool inexistente. **1 valida√ß√µes** usando: toBeUndefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeUndefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tool = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "value",
        "matcher": "toBeUndefined",
        "path": "tool"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "tool analyze deve ter campos repo e product obrigat√≥rios",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue ter campos repo e product obrigat√≥rios. **Valida√ß√µes**: `tool.inputSchema.required` = `\"repo\"`, `tool.inputSchema.required` = `\"product\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tool = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "tool.inputSchema.required"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "tool.inputSchema.required"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "tool validate deve ter campos de threshold",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue ter campos de threshold. **Valida√ß√µes**: `props` = `\"minBranch\"`, `props` = `\"minMutation\"`, `props` = `\"minDiffCoverage\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "tool = ...",
      "props = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "minBranch",
        "path": "props"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "minMutation",
        "path": "props"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "minDiffCoverage",
        "path": "props"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "tool scaffold deve ter campo type com enum",
    "testType": "unit",
    "functionUnderTest": "findTool",
    "whatItTests": "Valida que **`findTool`** consegue ter campo type com enum. **Valida√ß√µes**: `typeField.enum` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tool = ...",
      "typeField = ..."
    ],
    "when": "findTool",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "typeField.enum"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/mcp-tools.test.ts",
    "name": "todos os tools devem ter description com emoji",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue todos os tools devem ter description com emoji. **Valida√ß√µes**: `tool.description.length` = `10`, `tool.description.charCodeAt()` = `255`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 10,
        "path": "tool.description.length"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 255,
        "path": "tool.description.charCodeAt()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando analyze > deve parsear dom√≠nios separados por v√≠rgula",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear dom√≠nios separados por v√≠rgula. **Valida√ß√µes**: `domains` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "domainsStr = ...",
      "domains = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "domains"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando analyze > deve parsear critical flows separados por v√≠rgula",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear critical flows separados por v√≠rgula. **Valida√ß√µes**: `flows` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "flowsStr = ...",
      "flows = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "flows"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando analyze > deve parsear JSON de targets",
    "testType": "unit",
    "functionUnderTest": "JSON.parse",
    "whatItTests": "Valida que **`JSON.parse`** consegue parsear JSON de targets. **Valida√ß√µes**: `targets` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "targetsJson = ...",
      "targets = ..."
    ],
    "when": "JSON.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "targets"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve parsear dom√≠nios separados por v√≠rgula",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear dom√≠nios separados por v√≠rgula. **Valida√ß√µes**: `domains` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "domainsStr = ...",
      "domains = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "domains"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve parsear critical flows separados por v√≠rgula",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear critical flows separados por v√≠rgula. **Valida√ß√µes**: `flows` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "flowsStr = ...",
      "flows = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "flows"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve parsear JSON de targets",
    "testType": "unit",
    "functionUnderTest": "JSON.parse",
    "whatItTests": "Valida que **`JSON.parse`** consegue parsear JSON de targets. **Valida√ß√µes**: `targets` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "targetsJson = ...",
      "targets = ..."
    ],
    "when": "JSON.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "targets"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando plan > deve usar diret√≥rio de sa√≠da padr√£o se n√£o especificado",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de sa√≠da padr√£o se n√£o especificado. **Valida√ß√µes**: `defaultOut` = `\"plan\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando plan > deve aceitar include-examples como boolean",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue aceitar include-examples como boolean. **Valida√ß√µes**: `unknown` = `\"boolean\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "includeExamples = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve usar diret√≥rio de sa√≠da padr√£o se n√£o especificado",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de sa√≠da padr√£o se n√£o especificado. **Valida√ß√µes**: `defaultOut` = `\"plan\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve aceitar include-examples como boolean",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue aceitar include-examples como boolean. **Valida√ß√µes**: `unknown` = `\"boolean\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "includeExamples = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando scaffold > deve usar diret√≥rio de sa√≠da padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de sa√≠da padr√£o. **Valida√ß√µes**: `defaultOut` = `\"packages/product-e2e\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "packages/product-e2e",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve usar diret√≥rio de sa√≠da padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de sa√≠da padr√£o. **Valida√ß√µes**: `defaultOut` = `\"packages/product-e2e\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "packages/product-e2e",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando run > deve converter --headed para headless=false",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue converter --headed para headless=false. **Valida√ß√µes**: `headless` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "headed = ...",
      "headless = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "headless"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando run > deve usar headless=true por padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar headless=true por padr√£o. **Valida√ß√µes**: `headless` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "headed = ...",
      "headless = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "headless"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando run > deve usar diret√≥rio de relat√≥rios padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de relat√≥rios padr√£o. **Valida√ß√µes**: `defaultReport` = `\"reports\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultReport = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "reports",
        "path": "defaultReport"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve converter --headed para headless=false",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue converter --headed para headless=false. **Valida√ß√µes**: `headless` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "headed = ...",
      "headless = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "headless"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve usar headless=true por padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar headless=true por padr√£o. **Valida√ß√µes**: `headless` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "headed = ...",
      "headless = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "headless"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve usar diret√≥rio de relat√≥rios padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de relat√≥rios padr√£o. **Valida√ß√µes**: `defaultReport` = `\"reports\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultReport = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "reports",
        "path": "defaultReport"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando report > deve usar arquivo de sa√≠da padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar arquivo de sa√≠da padr√£o. **Valida√ß√µes**: `defaultOut` = `\"SUMMARY.md\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "SUMMARY.md",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve usar arquivo de sa√≠da padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar arquivo de sa√≠da padr√£o. **Valida√ß√µes**: `defaultOut` = `\"SUMMARY.md\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "SUMMARY.md",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Parsing de argumentos > deve parsear lista de arquivos",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de arquivos. **Valida√ß√µes**: `files` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filesStr = ...",
      "files = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Parsing de argumentos > deve parsear lista de endpoints",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de endpoints. **Valida√ß√µes**: `endpoints` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "endpointsStr = ...",
      "endpoints = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "endpoints"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Parsing de argumentos > deve parsear lista de squads",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de squads. **Valida√ß√µes**: `squads` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "squadsStr = ...",
      "squads = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "squads"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Parsing de argumentos > deve parsear thresholds JSON",
    "testType": "unit",
    "functionUnderTest": "JSON.parse",
    "whatItTests": "Valida que **`JSON.parse`** consegue parsear thresholds JSON. **Valida√ß√µes**: `thresholds` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "thresholdsJson = ...",
      "thresholds = ..."
    ],
    "when": "JSON.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "thresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve parsear lista de arquivos",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de arquivos. **Valida√ß√µes**: `files` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filesStr = ...",
      "files = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve parsear lista de endpoints",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de endpoints. **Valida√ß√µes**: `endpoints` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "endpointsStr = ...",
      "endpoints = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "endpoints"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve parsear lista de squads",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de squads. **Valida√ß√µes**: `squads` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "squadsStr = ...",
      "squads = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "squads"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve parsear thresholds JSON",
    "testType": "unit",
    "functionUnderTest": "JSON.parse",
    "whatItTests": "Valida que **`JSON.parse`** consegue parsear thresholds JSON. **Valida√ß√µes**: `thresholds` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "thresholdsJson = ...",
      "thresholds = ..."
    ],
    "when": "JSON.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "thresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de entrada > deve validar URL base",
    "testType": "unit",
    "functionUnderTest": ".not.toThrow",
    "whatItTests": "Valida que **`.not.toThrow`** consegue validar URL base. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "validUrl = ..."
    ],
    "when": ".not.toThrow",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Valida√ß√£o de entrada > deve validar URL base...', () => {\n  const result = .not.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Valida√ß√£o de entrada > deve validar URL base...', () => {\n  const result = .not.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de entrada > deve rejeitar URL inv√°lida",
    "testType": "unit",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue rejeitar URL inv√°lida. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidUrl = ..."
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de entrada > deve validar nome de produto alphanumeric",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue validar nome de produto alphanumeric. **Valida√ß√µes**: `regex.test()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "validName = ...",
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de entrada > deve rejeitar nome de produto com caracteres especiais",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue rejeitar nome de produto com caracteres especiais. **Valida√ß√µes**: `regex.test()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidName = ...",
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve validar URL base",
    "testType": "unit",
    "functionUnderTest": ".not.toThrow",
    "whatItTests": "Valida que **`.not.toThrow`** consegue validar URL base. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "validUrl = ..."
    ],
    "when": ".not.toThrow",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('CLI > deve validar URL base...', () => {\n  const result = .not.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('CLI > deve validar URL base...', () => {\n  const result = .not.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve rejeitar URL inv√°lida",
    "testType": "unit",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue rejeitar URL inv√°lida. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidUrl = ..."
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve validar nome de produto alphanumeric",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue validar nome de produto alphanumeric. **Valida√ß√µes**: `regex.test()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "validName = ...",
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve rejeitar nome de produto com caracteres especiais",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue rejeitar nome de produto com caracteres especiais. **Valida√ß√µes**: `regex.test()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidName = ...",
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Output formats > deve suportar formato markdown",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato markdown. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Output formats > deve suportar formato html",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato html. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Output formats > deve suportar formato json",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato json. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Output formats > deve rejeitar formato inv√°lido",
    "testType": "unit",
    "functionUnderTest": ".not.toContain",
    "whatItTests": "Valida que **`.not.toContain`** consegue rejeitar formato inv√°lido. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "format = ..."
    ],
    "when": ".not.toContain",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Output formats > deve rejeitar formato inv√°lido...', () => {\n  const result = .not.toContain(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Output formats > deve rejeitar formato inv√°lido...', () => {\n  const result = .not.toContain(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve suportar formato markdown",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato markdown. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve suportar formato html",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato html. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve suportar formato json",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato json. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve rejeitar formato inv√°lido",
    "testType": "unit",
    "functionUnderTest": ".not.toContain",
    "whatItTests": "Valida que **`.not.toContain`** consegue rejeitar formato inv√°lido. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "format = ..."
    ],
    "when": ".not.toContain",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('CLI > deve rejeitar formato inv√°lido...', () => {\n  const result = .not.toContain(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('CLI > deve rejeitar formato inv√°lido...', () => {\n  const result = .not.toContain(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Framework detection > deve suportar jest",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar jest. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Framework detection > deve suportar vitest",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar vitest. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Framework detection > deve suportar mocha",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar mocha. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve suportar jest",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar jest. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve suportar vitest",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar vitest. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve suportar mocha",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar mocha. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve ter todos os comandos esperados registrados na CLI",
    "testType": "unit",
    "functionUnderTest": "execSync",
    "whatItTests": "Valida que **`execSync`** consegue ter todos os comandos esperados registrados na CLI. **Valida√ß√µes**: `helpOutput` = `\"command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "expectedCommands = ...",
      "helpOutput = ..."
    ],
    "when": "execSync",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "command",
        "path": "helpOutput"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve ter descri√ß√µes para todos os comandos",
    "testType": "unit",
    "functionUnderTest": "execSync",
    "whatItTests": "Valida que **`execSync`** consegue ter descri√ß√µes para todos os comandos. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "helpOutput = ...",
      "criticalCommands = ..."
    ],
    "when": "execSync",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "helpOutput"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve validar que comandos espec√≠ficos aceitam par√¢metros obrigat√≥rios",
    "testType": "unit",
    "whatItTests": "Valida que **`fun√ß√£o n√£o identificada`** consegue validar que comandos espec√≠ficos aceitam par√¢metros obrigat√≥rios. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "N√ÉO DETERMINADO",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Valida√ß√£o de Comandos Registrados > deve validar q...', () => {\n  const result = processData(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Valida√ß√£o de Comandos Registrados > deve validar q...', () => {\n  const result = processData(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve rejeitar comandos inexistentes com mensagem clara",
    "testType": "unit",
    "whatItTests": "Valida que **`fun√ß√£o n√£o identificada`** consegue rejeitar comandos inexistentes com mensagem clara. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "N√ÉO DETERMINADO",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Valida√ß√£o de Comandos Registrados > deve rejeitar ...', () => {\n  const result = processData(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Valida√ß√£o de Comandos Registrados > deve rejeitar ...', () => {\n  const result = processData(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve garantir que scripts npm correspondam aos comandos CLI",
    "testType": "unit",
    "functionUnderTest": "require",
    "whatItTests": "Valida que **`require`** consegue garantir que scripts npm correspondam aos comandos CLI. **Valida√ß√µes**: `packageJson.scripts` = `\"scriptName\"`, `packageJson.scripts.scriptName` = `\"cliCommand\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveProperty, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "fs = ...",
      "path = ...",
      "packageJsonPath = ...",
      "packageJson = ...",
      "npmScriptMappings = ..."
    ],
    "when": "require",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "scriptName",
        "path": "packageJson.scripts"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cliCommand",
        "path": "packageJson.scripts.scriptName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve ter todos os comandos esperados registrados na CLI",
    "testType": "unit",
    "functionUnderTest": "execSync",
    "whatItTests": "Valida que **`execSync`** consegue ter todos os comandos esperados registrados na CLI. **Valida√ß√µes**: `helpOutput` = `\"command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "expectedCommands = ...",
      "helpOutput = ..."
    ],
    "when": "execSync",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "command",
        "path": "helpOutput"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve ter descri√ß√µes para todos os comandos",
    "testType": "unit",
    "functionUnderTest": "execSync",
    "whatItTests": "Valida que **`execSync`** consegue ter descri√ß√µes para todos os comandos. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "helpOutput = ...",
      "criticalCommands = ..."
    ],
    "when": "execSync",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "helpOutput"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve validar que comandos espec√≠ficos aceitam par√¢metros obrigat√≥rios",
    "testType": "unit",
    "whatItTests": "Valida que **`fun√ß√£o n√£o identificada`** consegue validar que comandos espec√≠ficos aceitam par√¢metros obrigat√≥rios. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "N√ÉO DETERMINADO",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('CLI > deve validar que comandos espec√≠ficos aceita...', () => {\n  const result = processData(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('CLI > deve validar que comandos espec√≠ficos aceita...', () => {\n  const result = processData(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve rejeitar comandos inexistentes com mensagem clara",
    "testType": "unit",
    "whatItTests": "Valida que **`fun√ß√£o n√£o identificada`** consegue rejeitar comandos inexistentes com mensagem clara. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "N√ÉO DETERMINADO",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('CLI > deve rejeitar comandos inexistentes com mens...', () => {\n  const result = processData(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('CLI > deve rejeitar comandos inexistentes com mens...', () => {\n  const result = processData(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "CLI > deve garantir que scripts npm correspondam aos comandos CLI",
    "testType": "unit",
    "functionUnderTest": "require",
    "whatItTests": "Valida que **`require`** consegue garantir que scripts npm correspondam aos comandos CLI. **Valida√ß√µes**: `packageJson.scripts` = `\"scriptName\"`, `packageJson.scripts.scriptName` = `\"cliCommand\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveProperty, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "fs = ...",
      "path = ...",
      "packageJsonPath = ...",
      "packageJson = ...",
      "npmScriptMappings = ..."
    ],
    "when": "require",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "scriptName",
        "path": "packageJson.scripts"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cliCommand",
        "path": "packageJson.scripts.scriptName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando analyze > deve parsear dom√≠nios separados por v√≠rgula",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear dom√≠nios separados por v√≠rgula. **Valida√ß√µes**: `domains` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "domainsStr = ...",
      "domains = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "domains"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando analyze > deve parsear critical flows separados por v√≠rgula",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear critical flows separados por v√≠rgula. **Valida√ß√µes**: `flows` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "flowsStr = ...",
      "flows = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "flows"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando analyze > deve parsear JSON de targets",
    "testType": "unit",
    "functionUnderTest": "JSON.parse",
    "whatItTests": "Valida que **`JSON.parse`** consegue parsear JSON de targets. **Valida√ß√µes**: `targets` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "targetsJson = ...",
      "targets = ..."
    ],
    "when": "JSON.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "targets"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve parsear dom√≠nios separados por v√≠rgula",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear dom√≠nios separados por v√≠rgula. **Valida√ß√µes**: `domains` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "domainsStr = ...",
      "domains = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "domains"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve parsear critical flows separados por v√≠rgula",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear critical flows separados por v√≠rgula. **Valida√ß√µes**: `flows` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "flowsStr = ...",
      "flows = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "flows"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve parsear JSON de targets",
    "testType": "unit",
    "functionUnderTest": "JSON.parse",
    "whatItTests": "Valida que **`JSON.parse`** consegue parsear JSON de targets. **Valida√ß√µes**: `targets` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "targetsJson = ...",
      "targets = ..."
    ],
    "when": "JSON.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "targets"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando plan > deve usar diret√≥rio de sa√≠da padr√£o se n√£o especificado",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de sa√≠da padr√£o se n√£o especificado. **Valida√ß√µes**: `defaultOut` = `\"plan\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando plan > deve aceitar include-examples como boolean",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue aceitar include-examples como boolean. **Valida√ß√µes**: `unknown` = `\"boolean\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "includeExamples = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve usar diret√≥rio de sa√≠da padr√£o se n√£o especificado",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de sa√≠da padr√£o se n√£o especificado. **Valida√ß√µes**: `defaultOut` = `\"plan\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve aceitar include-examples como boolean",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue aceitar include-examples como boolean. **Valida√ß√µes**: `unknown` = `\"boolean\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "includeExamples = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando scaffold > deve usar diret√≥rio de sa√≠da padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de sa√≠da padr√£o. **Valida√ß√µes**: `defaultOut` = `\"packages/product-e2e\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "packages/product-e2e",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve usar diret√≥rio de sa√≠da padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de sa√≠da padr√£o. **Valida√ß√µes**: `defaultOut` = `\"packages/product-e2e\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "packages/product-e2e",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando run > deve converter --headed para headless=false",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue converter --headed para headless=false. **Valida√ß√µes**: `headless` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "headed = ...",
      "headless = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "headless"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando run > deve usar headless=true por padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar headless=true por padr√£o. **Valida√ß√µes**: `headless` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "headed = ...",
      "headless = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "headless"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando run > deve usar diret√≥rio de relat√≥rios padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de relat√≥rios padr√£o. **Valida√ß√µes**: `defaultReport` = `\"reports\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultReport = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "reports",
        "path": "defaultReport"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve converter --headed para headless=false",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue converter --headed para headless=false. **Valida√ß√µes**: `headless` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "headed = ...",
      "headless = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "headless"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve usar headless=true por padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar headless=true por padr√£o. **Valida√ß√µes**: `headless` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "headed = ...",
      "headless = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "headless"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve usar diret√≥rio de relat√≥rios padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar diret√≥rio de relat√≥rios padr√£o. **Valida√ß√µes**: `defaultReport` = `\"reports\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultReport = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "reports",
        "path": "defaultReport"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Comando report > deve usar arquivo de sa√≠da padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar arquivo de sa√≠da padr√£o. **Valida√ß√µes**: `defaultOut` = `\"SUMMARY.md\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "SUMMARY.md",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve usar arquivo de sa√≠da padr√£o",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar arquivo de sa√≠da padr√£o. **Valida√ß√µes**: `defaultOut` = `\"SUMMARY.md\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "defaultOut = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "SUMMARY.md",
        "path": "defaultOut"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Parsing de argumentos > deve parsear lista de arquivos",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de arquivos. **Valida√ß√µes**: `files` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filesStr = ...",
      "files = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Parsing de argumentos > deve parsear lista de endpoints",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de endpoints. **Valida√ß√µes**: `endpoints` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "endpointsStr = ...",
      "endpoints = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "endpoints"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Parsing de argumentos > deve parsear lista de squads",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de squads. **Valida√ß√µes**: `squads` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "squadsStr = ...",
      "squads = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "squads"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Parsing de argumentos > deve parsear thresholds JSON",
    "testType": "unit",
    "functionUnderTest": "JSON.parse",
    "whatItTests": "Valida que **`JSON.parse`** consegue parsear thresholds JSON. **Valida√ß√µes**: `thresholds` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "thresholdsJson = ...",
      "thresholds = ..."
    ],
    "when": "JSON.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "thresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve parsear lista de arquivos",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de arquivos. **Valida√ß√µes**: `files` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filesStr = ...",
      "files = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve parsear lista de endpoints",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de endpoints. **Valida√ß√µes**: `endpoints` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "endpointsStr = ...",
      "endpoints = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "endpoints"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve parsear lista de squads",
    "testType": "unit",
    "functionUnderTest": ".map",
    "whatItTests": "Valida que **`.map`** consegue parsear lista de squads. **Valida√ß√µes**: `squads` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "squadsStr = ...",
      "squads = ..."
    ],
    "when": ".map",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "squads"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve parsear thresholds JSON",
    "testType": "unit",
    "functionUnderTest": "JSON.parse",
    "whatItTests": "Valida que **`JSON.parse`** consegue parsear thresholds JSON. **Valida√ß√µes**: `thresholds` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "thresholdsJson = ...",
      "thresholds = ..."
    ],
    "when": "JSON.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "thresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de entrada > deve validar URL base",
    "testType": "unit",
    "functionUnderTest": ".not.toThrow",
    "whatItTests": "Valida que **`.not.toThrow`** consegue validar URL base. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "validUrl = ..."
    ],
    "when": ".not.toThrow",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Valida√ß√£o de entrada > deve validar URL base...', () => {\n  const result = .not.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Valida√ß√£o de entrada > deve validar URL base...', () => {\n  const result = .not.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de entrada > deve rejeitar URL inv√°lida",
    "testType": "unit",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue rejeitar URL inv√°lida. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidUrl = ..."
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de entrada > deve validar nome de produto alphanumeric",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue validar nome de produto alphanumeric. **Valida√ß√µes**: `regex.test()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "validName = ...",
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de entrada > deve rejeitar nome de produto com caracteres especiais",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue rejeitar nome de produto com caracteres especiais. **Valida√ß√µes**: `regex.test()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidName = ...",
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve validar URL base",
    "testType": "unit",
    "functionUnderTest": ".not.toThrow",
    "whatItTests": "Valida que **`.not.toThrow`** consegue validar URL base. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "validUrl = ..."
    ],
    "when": ".not.toThrow",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve validar URL base...', () => {\n  const result = .not.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve validar URL base...', () => {\n  const result = .not.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve rejeitar URL inv√°lida",
    "testType": "unit",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue rejeitar URL inv√°lida. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidUrl = ..."
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve validar nome de produto alphanumeric",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue validar nome de produto alphanumeric. **Valida√ß√µes**: `regex.test()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "validName = ...",
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve rejeitar nome de produto com caracteres especiais",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue rejeitar nome de produto com caracteres especiais. **Valida√ß√µes**: `regex.test()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidName = ...",
      "regex = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "regex.test()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Output formats > deve suportar formato markdown",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato markdown. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Output formats > deve suportar formato html",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato html. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Output formats > deve suportar formato json",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato json. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Output formats > deve rejeitar formato inv√°lido",
    "testType": "unit",
    "functionUnderTest": ".not.toContain",
    "whatItTests": "Valida que **`.not.toContain`** consegue rejeitar formato inv√°lido. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "format = ..."
    ],
    "when": ".not.toContain",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Output formats > deve rejeitar formato inv√°lido...', () => {\n  const result = .not.toContain(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Output formats > deve rejeitar formato inv√°lido...', () => {\n  const result = .not.toContain(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve suportar formato markdown",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato markdown. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve suportar formato html",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato html. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve suportar formato json",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar formato json. **Valida√ß√µes**: `unknown` = `\"format\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "format = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "format",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve rejeitar formato inv√°lido",
    "testType": "unit",
    "functionUnderTest": ".not.toContain",
    "whatItTests": "Valida que **`.not.toContain`** consegue rejeitar formato inv√°lido. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "format = ..."
    ],
    "when": ".not.toContain",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve rejeitar formato inv√°lido...', () => {\n  const result = .not.toContain(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve rejeitar formato inv√°lido...', () => {\n  const result = .not.toContain(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Framework detection > deve suportar jest",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar jest. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Framework detection > deve suportar vitest",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar vitest. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Framework detection > deve suportar mocha",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar mocha. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve suportar jest",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar jest. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve suportar vitest",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar vitest. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve suportar mocha",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue suportar mocha. **Valida√ß√µes**: `unknown` = `\"framework\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "framework = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "framework",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve ter todos os comandos esperados registrados na CLI",
    "testType": "unit",
    "functionUnderTest": "execSync",
    "whatItTests": "Valida que **`execSync`** consegue ter todos os comandos esperados registrados na CLI. **Valida√ß√µes**: `helpOutput` = `\"command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "expectedCommands = ...",
      "helpOutput = ..."
    ],
    "when": "execSync",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "command",
        "path": "helpOutput"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve ter descri√ß√µes para todos os comandos",
    "testType": "unit",
    "functionUnderTest": "execSync",
    "whatItTests": "Valida que **`execSync`** consegue ter descri√ß√µes para todos os comandos. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "helpOutput = ...",
      "criticalCommands = ..."
    ],
    "when": "execSync",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "helpOutput"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve validar que comandos espec√≠ficos aceitam par√¢metros obrigat√≥rios",
    "testType": "unit",
    "whatItTests": "Valida que **`fun√ß√£o n√£o identificada`** consegue validar que comandos espec√≠ficos aceitam par√¢metros obrigat√≥rios. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "N√ÉO DETERMINADO",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Valida√ß√£o de Comandos Registrados > deve validar q...', () => {\n  const result = processData(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Valida√ß√£o de Comandos Registrados > deve validar q...', () => {\n  const result = processData(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve rejeitar comandos inexistentes com mensagem clara",
    "testType": "unit",
    "whatItTests": "Valida que **`fun√ß√£o n√£o identificada`** consegue rejeitar comandos inexistentes com mensagem clara. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "N√ÉO DETERMINADO",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Valida√ß√£o de Comandos Registrados > deve rejeitar ...', () => {\n  const result = processData(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Valida√ß√£o de Comandos Registrados > deve rejeitar ...', () => {\n  const result = processData(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "Valida√ß√£o de Comandos Registrados > deve garantir que scripts npm correspondam aos comandos CLI",
    "testType": "unit",
    "functionUnderTest": "require",
    "whatItTests": "Valida que **`require`** consegue garantir que scripts npm correspondam aos comandos CLI. **Valida√ß√µes**: `packageJson.scripts` = `\"scriptName\"`, `packageJson.scripts.scriptName` = `\"cliCommand\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveProperty, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "fs = ...",
      "path = ...",
      "packageJsonPath = ...",
      "packageJson = ...",
      "npmScriptMappings = ..."
    ],
    "when": "require",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "scriptName",
        "path": "packageJson.scripts"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cliCommand",
        "path": "packageJson.scripts.scriptName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve ter todos os comandos esperados registrados na CLI",
    "testType": "unit",
    "functionUnderTest": "execSync",
    "whatItTests": "Valida que **`execSync`** consegue ter todos os comandos esperados registrados na CLI. **Valida√ß√µes**: `helpOutput` = `\"command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "expectedCommands = ...",
      "helpOutput = ..."
    ],
    "when": "execSync",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "command",
        "path": "helpOutput"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve ter descri√ß√µes para todos os comandos",
    "testType": "unit",
    "functionUnderTest": "execSync",
    "whatItTests": "Valida que **`execSync`** consegue ter descri√ß√µes para todos os comandos. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "helpOutput = ...",
      "criticalCommands = ..."
    ],
    "when": "execSync",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "helpOutput"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve validar que comandos espec√≠ficos aceitam par√¢metros obrigat√≥rios",
    "testType": "unit",
    "whatItTests": "Valida que **`fun√ß√£o n√£o identificada`** consegue validar que comandos espec√≠ficos aceitam par√¢metros obrigat√≥rios. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "N√ÉO DETERMINADO",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve validar que comandos espec√≠ficos aceitam par√¢...', () => {\n  const result = processData(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve validar que comandos espec√≠ficos aceitam par√¢...', () => {\n  const result = processData(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve rejeitar comandos inexistentes com mensagem clara",
    "testType": "unit",
    "whatItTests": "Valida que **`fun√ß√£o n√£o identificada`** consegue rejeitar comandos inexistentes com mensagem clara. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "N√ÉO DETERMINADO",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve rejeitar comandos inexistentes com mensagem c...', () => {\n  const result = processData(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve rejeitar comandos inexistentes com mensagem c...', () => {\n  const result = processData(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli.test.ts",
    "name": "deve garantir que scripts npm correspondam aos comandos CLI",
    "testType": "unit",
    "functionUnderTest": "require",
    "whatItTests": "Valida que **`require`** consegue garantir que scripts npm correspondam aos comandos CLI. **Valida√ß√µes**: `packageJson.scripts` = `\"scriptName\"`, `packageJson.scripts.scriptName` = `\"cliCommand\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveProperty, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "fs = ...",
      "path = ...",
      "packageJsonPath = ...",
      "packageJson = ...",
      "npmScriptMappings = ..."
    ],
    "when": "require",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "scriptName",
        "path": "packageJson.scripts"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cliCommand",
        "path": "packageJson.scripts.scriptName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Estrutura do Manifesto > deve ter exatamente 6 comandos consolidados",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter exatamente 6 comandos consolidados. **Valida√ß√µes**: `COMMANDS` = `6`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 6,
        "path": "COMMANDS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Estrutura do Manifesto > todos os comandos devem ter propriedades obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue Estrutura do Manifesto > todos os comandos devem ter propriedades obrigat√≥rias. **Valida√ß√µes**: `cmd` = `\"name\"`, `cmd` = `\"module\"`, `cmd` = `\"description\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "module",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "flags",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Estrutura do Manifesto > todos os comandos devem ter pelo menos uma flag",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue Estrutura do Manifesto > todos os comandos devem ter pelo menos uma flag. **Valida√ß√µes**: `cmd.flags.length` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "cmd.flags.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Estrutura do Manifesto > todas as flags devem ter estrutura v√°lida",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue Estrutura do Manifesto > todas as flags devem ter estrutura v√°lida. **Valida√ß√µes**: `flag` = `\"name\"`, `flag` = `\"description\"`, `flag` = `\"required\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "required",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > deve ter exatamente 6 comandos consolidados",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter exatamente 6 comandos consolidados. **Valida√ß√µes**: `COMMANDS` = `6`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 6,
        "path": "COMMANDS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > todos os comandos devem ter propriedades obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue Commands Manifest > todos os comandos devem ter propriedades obrigat√≥rias. **Valida√ß√µes**: `cmd` = `\"name\"`, `cmd` = `\"module\"`, `cmd` = `\"description\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "module",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "flags",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > todos os comandos devem ter pelo menos uma flag",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue Commands Manifest > todos os comandos devem ter pelo menos uma flag. **Valida√ß√µes**: `cmd.flags.length` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "cmd.flags.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > todas as flags devem ter estrutura v√°lida",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue Commands Manifest > todas as flags devem ter estrutura v√°lida. **Valida√ß√µes**: `flag` = `\"name\"`, `flag` = `\"description\"`, `flag` = `\"required\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "required",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > deve conter todos os comandos esperados",
    "testType": "unit",
    "functionUnderTest": "COMMANDS.map",
    "whatItTests": "Valida que **`COMMANDS.map`** consegue conter todos os comandos esperados. **Valida√ß√µes**: `commandNames` = `\"expectedCmd\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "commandNames = ..."
    ],
    "when": "COMMANDS.map",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "expectedCmd",
        "path": "commandNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > comando analyze deve ter flags obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flags obrigat√≥rias. **Valida√ß√µes**: `requiredNames` = `\"repo\"`, `requiredNames` = `\"product\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "requiredFlags = ...",
      "requiredNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "requiredNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "requiredNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > comando validate deve ter flags de threshold",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flags de threshold. **Valida√ß√µes**: `flagNames` = `\"min-branch\"`, `flagNames` = `\"min-mutation\"`, `flagNames` = `\"min-diff-coverage\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validateCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "validateCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-branch",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-mutation",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-diff-coverage",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > comando scaffold deve ter flag type",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flag type. **Valida√ß√µes**: `flagNames` = `\"type\"`, `flagNames` = `\"repo\"`, `flagNames` = `\"product\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "scaffoldCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "type",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > comando self-check deve ter flag fix",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flag fix. **Valida√ß√µes**: `flagNames` = `\"fix\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "selfCheckCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "selfCheckCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "fix",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > deve conter todos os comandos esperados",
    "testType": "unit",
    "functionUnderTest": "COMMANDS.map",
    "whatItTests": "Valida que **`COMMANDS.map`** consegue conter todos os comandos esperados. **Valida√ß√µes**: `commandNames` = `\"expectedCmd\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "commandNames = ..."
    ],
    "when": "COMMANDS.map",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "expectedCmd",
        "path": "commandNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > comando analyze deve ter flags obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flags obrigat√≥rias. **Valida√ß√µes**: `requiredNames` = `\"repo\"`, `requiredNames` = `\"product\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "requiredFlags = ...",
      "requiredNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "requiredNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "requiredNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > comando validate deve ter flags de threshold",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flags de threshold. **Valida√ß√µes**: `flagNames` = `\"min-branch\"`, `flagNames` = `\"min-mutation\"`, `flagNames` = `\"min-diff-coverage\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validateCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "validateCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-branch",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-mutation",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-diff-coverage",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > comando scaffold deve ter flag type",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flag type. **Valida√ß√µes**: `flagNames` = `\"type\"`, `flagNames` = `\"repo\"`, `flagNames` = `\"product\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "scaffoldCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "type",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > comando self-check deve ter flag fix",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flag fix. **Valida√ß√µes**: `flagNames` = `\"fix\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "selfCheckCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "selfCheckCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "fix",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > flags boolean devem ter defaultValue do tipo boolean",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue Boolean Flags Detection > flags boolean devem ter defaultValue do tipo boolean. **Valida√ß√µes**: `unknown` = `\"boolean\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "booleanFlagNames = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > flags de valor devem ter defaultValue string/number/undefined, n√£o boolean",
    "testType": "unit",
    "functionUnderTest": ".not.toBe",
    "whatItTests": "Valida que **`.not.toBe`** consegue Boolean Flags Detection > flags de valor devem ter defaultValue string/number/undefined, n√£o boolean. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "valueFlagNames = ..."
    ],
    "when": ".not.toBe",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Boolean Flags Detection > flags de valor devem ter...', () => {\n  const result = .not.toBe(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Boolean Flags Detection > flags de valor devem ter...', () => {\n  const result = .not.toBe(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > REGRESS√ÉO: --skip-run deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "skipRunFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "skipRunFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > REGRESS√ÉO: --skip-scaffold deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "skipScaffoldFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "skipScaffoldFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > REGRESS√ÉO: --fix deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "selfCheckCmd = ...",
      "fixFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "fixFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > flags boolean devem ter defaultValue do tipo boolean",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue Commands Manifest > flags boolean devem ter defaultValue do tipo boolean. **Valida√ß√µes**: `unknown` = `\"boolean\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "booleanFlagNames = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > flags de valor devem ter defaultValue string/number/undefined, n√£o boolean",
    "testType": "unit",
    "functionUnderTest": ".not.toBe",
    "whatItTests": "Valida que **`.not.toBe`** consegue Commands Manifest > flags de valor devem ter defaultValue string/number/undefined, n√£o boolean. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "valueFlagNames = ..."
    ],
    "when": ".not.toBe",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Commands Manifest > flags de valor devem ter defau...', () => {\n  const result = .not.toBe(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Commands Manifest > flags de valor devem ter defau...', () => {\n  const result = .not.toBe(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > REGRESS√ÉO: --skip-run deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "skipRunFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "skipRunFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > REGRESS√ÉO: --skip-scaffold deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "skipScaffoldFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "skipScaffoldFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > REGRESS√ÉO: --fix deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "selfCheckCmd = ...",
      "fixFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "fixFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > findCommand deve encontrar comando por nome",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue encontrar comando por nome. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > findCommand deve retornar undefined para comando inexistente",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue retornar undefined para comando inexistente. **1 valida√ß√µes** usando: toBeUndefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeUndefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBeUndefined",
        "path": "cmd"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > findCommand deve encontrar por alias",
    "testType": "unit",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue encontrar por alias. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "analyzeCmd = ...",
      "found = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > validateRequiredFlags deve validar flags obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue validar flags obrigat√≥rias. **Valida√ß√µes**: `result1.valid` = `false`, `result1.missing` = `\"repo\"`, `result1.missing` = `\"product\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "result1 = ...",
      "result2 = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result1.valid"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "result1.missing"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "result1.missing"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result2.valid"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result2.missing"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > validateRequiredFlags deve permitir flags opcionais ausentes",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue permitir flags opcionais ausentes. **Valida√ß√µes**: `result.valid` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "analyzeCmd = ...",
      "result = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.valid"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > findCommand deve encontrar comando por nome",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue encontrar comando por nome. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > findCommand deve retornar undefined para comando inexistente",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue retornar undefined para comando inexistente. **1 valida√ß√µes** usando: toBeUndefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeUndefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBeUndefined",
        "path": "cmd"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > findCommand deve encontrar por alias",
    "testType": "unit",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue encontrar por alias. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "analyzeCmd = ...",
      "found = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > validateRequiredFlags deve validar flags obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue validar flags obrigat√≥rias. **Valida√ß√µes**: `result1.valid` = `false`, `result1.missing` = `\"repo\"`, `result1.missing` = `\"product\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "result1 = ...",
      "result2 = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result1.valid"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "result1.missing"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "result1.missing"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result2.valid"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result2.missing"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > validateRequiredFlags deve permitir flags opcionais ausentes",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue permitir flags opcionais ausentes. **Valida√ß√µes**: `result.valid` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "analyzeCmd = ...",
      "result = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.valid"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Paridade com package.json > scripts npm devem corresponder aos comandos principais",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue Paridade com package.json > scripts npm devem corresponder aos comandos principais. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "packageJsonPath = ...",
      "packageJson = ...",
      "scripts = ...",
      "criticalCommands = ...",
      "scriptKey = ...",
      "hasScript = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Paridade com package.json > scripts npm devem corr...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Paridade com package.json > scripts npm devem corr...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > scripts npm devem corresponder aos comandos principais",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue Commands Manifest > scripts npm devem corresponder aos comandos principais. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "packageJsonPath = ...",
      "packageJson = ...",
      "scripts = ...",
      "criticalCommands = ...",
      "scriptKey = ...",
      "hasScript = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Commands Manifest > scripts npm devem corresponder...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Commands Manifest > scripts npm devem corresponder...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Valida√ß√£o de M√≥dulos > todos os comandos devem apontar para m√≥dulos .js v√°lidos",
    "testType": "unit",
    "functionUnderTest": ".toMatch",
    "whatItTests": "Valida que **`.toMatch`** consegue Valida√ß√£o de M√≥dulos > todos os comandos devem apontar para m√≥dulos .js v√°lidos. **Valida√ß√µes**: `cmd.module` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toMatch",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "cmd.module"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Valida√ß√£o de M√≥dulos > m√≥dulos devem seguir padr√£o de naming",
    "testType": "unit",
    "functionUnderTest": ".replace",
    "whatItTests": "Valida que **`.replace`** consegue Valida√ß√£o de M√≥dulos > m√≥dulos devem seguir padr√£o de naming. **Valida√ß√µes**: `moduleName.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeTruthy, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "moduleName = ..."
    ],
    "when": ".replace",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeTruthy",
        "path": "moduleName"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "moduleName.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > todos os comandos devem apontar para m√≥dulos .js v√°lidos",
    "testType": "unit",
    "functionUnderTest": ".toMatch",
    "whatItTests": "Valida que **`.toMatch`** consegue Commands Manifest > todos os comandos devem apontar para m√≥dulos .js v√°lidos. **Valida√ß√µes**: `cmd.module` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toMatch",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "cmd.module"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > m√≥dulos devem seguir padr√£o de naming",
    "testType": "unit",
    "functionUnderTest": ".replace",
    "whatItTests": "Valida que **`.replace`** consegue Commands Manifest > m√≥dulos devem seguir padr√£o de naming. **Valida√ß√µes**: `moduleName.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeTruthy, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "moduleName = ..."
    ],
    "when": ".replace",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeTruthy",
        "path": "moduleName"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "moduleName.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Defaults Sensatos > comando validate deve aceitar thresholds opcionais",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue aceitar thresholds opcionais. **Valida√ß√µes**: `unknown.required` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validateCmd = ...",
      "minBranch = ...",
      "minMutation = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "minBranch"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.required"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "minMutation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Defaults Sensatos > comando scaffold deve ter defaults √∫teis",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter defaults √∫teis. **Valida√ß√µes**: `unknown.defaultValue` = `\"unit\"`, `unknown.defaultValue` = `\"vitest\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldCmd = ...",
      "typeFlag = ...",
      "frameworkFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "typeFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "unit",
        "path": "unknown.defaultValue"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "frameworkFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Defaults Sensatos > comando self-check deve ter repo default",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter repo default. **Valida√ß√µes**: `unknown.defaultValue` = `\".\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "selfCheckCmd = ...",
      "repoFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "repoFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > comando validate deve aceitar thresholds opcionais",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue aceitar thresholds opcionais. **Valida√ß√µes**: `unknown.required` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validateCmd = ...",
      "minBranch = ...",
      "minMutation = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "minBranch"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.required"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "minMutation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > comando scaffold deve ter defaults √∫teis",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter defaults √∫teis. **Valida√ß√µes**: `unknown.defaultValue` = `\"unit\"`, `unknown.defaultValue` = `\"vitest\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldCmd = ...",
      "typeFlag = ...",
      "frameworkFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "typeFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "unit",
        "path": "unknown.defaultValue"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "frameworkFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > comando self-check deve ter repo default",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter repo default. **Valida√ß√µes**: `unknown.defaultValue` = `\".\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "selfCheckCmd = ...",
      "repoFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "repoFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Exemplos de Uso > comandos principais devem ter exemplos",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue Exemplos de Uso > comandos principais devem ter exemplos. **Valida√ß√µes**: `unknown.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "criticalCommands = ...",
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "cmd"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown.examples"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Exemplos de Uso > exemplos devem conter nome do comando",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue Exemplos de Uso > exemplos devem conter nome do comando. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "example"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Exemplos de Uso > exemplos devem ter sintaxe v√°lida",
    "testType": "unit",
    "functionUnderTest": ".toMatch",
    "whatItTests": "Valida que **`.toMatch`** consegue Exemplos de Uso > exemplos devem ter sintaxe v√°lida. **Valida√ß√µes**: `example` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toMatch",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "example"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > comandos principais devem ter exemplos",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue Commands Manifest > comandos principais devem ter exemplos. **Valida√ß√µes**: `unknown.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "criticalCommands = ...",
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "cmd"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown.examples"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > exemplos devem conter nome do comando",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue Commands Manifest > exemplos devem conter nome do comando. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "example"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Commands Manifest > exemplos devem ter sintaxe v√°lida",
    "testType": "unit",
    "functionUnderTest": ".toMatch",
    "whatItTests": "Valida que **`.toMatch`** consegue Commands Manifest > exemplos devem ter sintaxe v√°lida. **Valida√ß√µes**: `example` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toMatch",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "example"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Estrutura do Manifesto > deve ter exatamente 6 comandos consolidados",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter exatamente 6 comandos consolidados. **Valida√ß√µes**: `COMMANDS` = `6`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 6,
        "path": "COMMANDS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Estrutura do Manifesto > todos os comandos devem ter propriedades obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue Estrutura do Manifesto > todos os comandos devem ter propriedades obrigat√≥rias. **Valida√ß√µes**: `cmd` = `\"name\"`, `cmd` = `\"module\"`, `cmd` = `\"description\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "module",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "flags",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Estrutura do Manifesto > todos os comandos devem ter pelo menos uma flag",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue Estrutura do Manifesto > todos os comandos devem ter pelo menos uma flag. **Valida√ß√µes**: `cmd.flags.length` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "cmd.flags.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Estrutura do Manifesto > todas as flags devem ter estrutura v√°lida",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue Estrutura do Manifesto > todas as flags devem ter estrutura v√°lida. **Valida√ß√µes**: `flag` = `\"name\"`, `flag` = `\"description\"`, `flag` = `\"required\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "required",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "deve ter exatamente 6 comandos consolidados",
    "testType": "unit",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue ter exatamente 6 comandos consolidados. **Valida√ß√µes**: `COMMANDS` = `6`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 6,
        "path": "COMMANDS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "todos os comandos devem ter propriedades obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue todos os comandos devem ter propriedades obrigat√≥rias. **Valida√ß√µes**: `cmd` = `\"name\"`, `cmd` = `\"module\"`, `cmd` = `\"description\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "module",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "flags",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "todos os comandos devem ter pelo menos uma flag",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue todos os comandos devem ter pelo menos uma flag. **Valida√ß√µes**: `cmd.flags.length` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "cmd.flags.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "todas as flags devem ter estrutura v√°lida",
    "testType": "unit",
    "functionUnderTest": ".toHaveProperty",
    "whatItTests": "Valida que **`.toHaveProperty`** consegue todas as flags devem ter estrutura v√°lida. **Valida√ß√µes**: `flag` = `\"name\"`, `flag` = `\"description\"`, `flag` = `\"required\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toHaveProperty",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "required",
        "path": "flag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > deve conter todos os comandos esperados",
    "testType": "unit",
    "functionUnderTest": "COMMANDS.map",
    "whatItTests": "Valida que **`COMMANDS.map`** consegue conter todos os comandos esperados. **Valida√ß√µes**: `commandNames` = `\"expectedCmd\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "commandNames = ..."
    ],
    "when": "COMMANDS.map",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "expectedCmd",
        "path": "commandNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > comando analyze deve ter flags obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flags obrigat√≥rias. **Valida√ß√µes**: `requiredNames` = `\"repo\"`, `requiredNames` = `\"product\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "requiredFlags = ...",
      "requiredNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "requiredNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "requiredNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > comando validate deve ter flags de threshold",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flags de threshold. **Valida√ß√µes**: `flagNames` = `\"min-branch\"`, `flagNames` = `\"min-mutation\"`, `flagNames` = `\"min-diff-coverage\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validateCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "validateCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-branch",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-mutation",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-diff-coverage",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > comando scaffold deve ter flag type",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flag type. **Valida√ß√µes**: `flagNames` = `\"type\"`, `flagNames` = `\"repo\"`, `flagNames` = `\"product\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "scaffoldCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "type",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Comandos Esperados > comando self-check deve ter flag fix",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flag fix. **Valida√ß√µes**: `flagNames` = `\"fix\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "selfCheckCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "selfCheckCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "fix",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "deve conter todos os comandos esperados",
    "testType": "unit",
    "functionUnderTest": "COMMANDS.map",
    "whatItTests": "Valida que **`COMMANDS.map`** consegue conter todos os comandos esperados. **Valida√ß√µes**: `commandNames` = `\"expectedCmd\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "commandNames = ..."
    ],
    "when": "COMMANDS.map",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "expectedCmd",
        "path": "commandNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "comando analyze deve ter flags obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flags obrigat√≥rias. **Valida√ß√µes**: `requiredNames` = `\"repo\"`, `requiredNames` = `\"product\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "requiredFlags = ...",
      "requiredNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "requiredNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "requiredNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "comando validate deve ter flags de threshold",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flags de threshold. **Valida√ß√µes**: `flagNames` = `\"min-branch\"`, `flagNames` = `\"min-mutation\"`, `flagNames` = `\"min-diff-coverage\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validateCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "validateCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-branch",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-mutation",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "min-diff-coverage",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "comando scaffold deve ter flag type",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flag type. **Valida√ß√µes**: `flagNames` = `\"type\"`, `flagNames` = `\"repo\"`, `flagNames` = `\"product\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "scaffoldCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "type",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "flagNames"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "comando self-check deve ter flag fix",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter flag fix. **Valida√ß√µes**: `flagNames` = `\"fix\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "selfCheckCmd = ...",
      "flagNames = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "selfCheckCmd"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "fix",
        "path": "flagNames"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > flags boolean devem ter defaultValue do tipo boolean",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue Boolean Flags Detection > flags boolean devem ter defaultValue do tipo boolean. **Valida√ß√µes**: `unknown` = `\"boolean\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "booleanFlagNames = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > flags de valor devem ter defaultValue string/number/undefined, n√£o boolean",
    "testType": "unit",
    "functionUnderTest": ".not.toBe",
    "whatItTests": "Valida que **`.not.toBe`** consegue Boolean Flags Detection > flags de valor devem ter defaultValue string/number/undefined, n√£o boolean. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "valueFlagNames = ..."
    ],
    "when": ".not.toBe",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Boolean Flags Detection > flags de valor devem ter...', () => {\n  const result = .not.toBe(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Boolean Flags Detection > flags de valor devem ter...', () => {\n  const result = .not.toBe(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > REGRESS√ÉO: --skip-run deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "skipRunFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "skipRunFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > REGRESS√ÉO: --skip-scaffold deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "skipScaffoldFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "skipScaffoldFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Boolean Flags Detection > REGRESS√ÉO: --fix deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "selfCheckCmd = ...",
      "fixFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "fixFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "flags boolean devem ter defaultValue do tipo boolean",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue flags boolean devem ter defaultValue do tipo boolean. **Valida√ß√µes**: `unknown` = `\"boolean\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "booleanFlagNames = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "flags de valor devem ter defaultValue string/number/undefined, n√£o boolean",
    "testType": "unit",
    "functionUnderTest": ".not.toBe",
    "whatItTests": "Valida que **`.not.toBe`** consegue flags de valor devem ter defaultValue string/number/undefined, n√£o boolean. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "valueFlagNames = ..."
    ],
    "when": ".not.toBe",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('flags de valor devem ter defaultValue string/numbe...', () => {\n  const result = .not.toBe(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('flags de valor devem ter defaultValue string/numbe...', () => {\n  const result = .not.toBe(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "REGRESS√ÉO: --skip-run deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "skipRunFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "skipRunFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "REGRESS√ÉO: --skip-scaffold deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "skipScaffoldFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "skipScaffoldFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "REGRESS√ÉO: --fix deve ser boolean (bug fix e6939d9)",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ser boolean (bug fix e6939d9). **Valida√ß√µes**: `unknown` = `\"boolean\"`, `unknown.defaultValue` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "selfCheckCmd = ...",
      "fixFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "fixFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > findCommand deve encontrar comando por nome",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue encontrar comando por nome. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > findCommand deve retornar undefined para comando inexistente",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue retornar undefined para comando inexistente. **1 valida√ß√µes** usando: toBeUndefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeUndefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBeUndefined",
        "path": "cmd"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > findCommand deve encontrar por alias",
    "testType": "unit",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue encontrar por alias. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "analyzeCmd = ...",
      "found = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > validateRequiredFlags deve validar flags obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue validar flags obrigat√≥rias. **Valida√ß√µes**: `result1.valid` = `false`, `result1.missing` = `\"repo\"`, `result1.missing` = `\"product\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "result1 = ...",
      "result2 = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result1.valid"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "result1.missing"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "result1.missing"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result2.valid"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result2.missing"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Fun√ß√µes Utilit√°rias > validateRequiredFlags deve permitir flags opcionais ausentes",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue permitir flags opcionais ausentes. **Valida√ß√µes**: `result.valid` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "analyzeCmd = ...",
      "result = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.valid"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "findCommand deve encontrar comando por nome",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue encontrar comando por nome. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "cmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "findCommand deve retornar undefined para comando inexistente",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue retornar undefined para comando inexistente. **1 valida√ß√µes** usando: toBeUndefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeUndefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBeUndefined",
        "path": "cmd"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "findCommand deve encontrar por alias",
    "testType": "unit",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue encontrar por alias. **Valida√ß√µes**: `unknown.name` = `\"analyze\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "analyzeCmd = ...",
      "found = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "unknown.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "validateRequiredFlags deve validar flags obrigat√≥rias",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue validar flags obrigat√≥rias. **Valida√ß√µes**: `result1.valid` = `false`, `result1.missing` = `\"repo\"`, `result1.missing` = `\"product\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyzeCmd = ...",
      "result1 = ...",
      "result2 = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result1.valid"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "result1.missing"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "product",
        "path": "result1.missing"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result2.valid"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result2.missing"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "validateRequiredFlags deve permitir flags opcionais ausentes",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue permitir flags opcionais ausentes. **Valida√ß√µes**: `result.valid` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "analyzeCmd = ...",
      "result = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.valid"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Paridade com package.json > scripts npm devem corresponder aos comandos principais",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue Paridade com package.json > scripts npm devem corresponder aos comandos principais. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "packageJsonPath = ...",
      "packageJson = ...",
      "scripts = ...",
      "criticalCommands = ...",
      "scriptKey = ...",
      "hasScript = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Paridade com package.json > scripts npm devem corr...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Paridade com package.json > scripts npm devem corr...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "scripts npm devem corresponder aos comandos principais",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue scripts npm devem corresponder aos comandos principais. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "packageJsonPath = ...",
      "packageJson = ...",
      "scripts = ...",
      "criticalCommands = ...",
      "scriptKey = ...",
      "hasScript = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('scripts npm devem corresponder aos comandos princi...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('scripts npm devem corresponder aos comandos princi...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Valida√ß√£o de M√≥dulos > todos os comandos devem apontar para m√≥dulos .js v√°lidos",
    "testType": "unit",
    "functionUnderTest": ".toMatch",
    "whatItTests": "Valida que **`.toMatch`** consegue Valida√ß√£o de M√≥dulos > todos os comandos devem apontar para m√≥dulos .js v√°lidos. **Valida√ß√µes**: `cmd.module` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toMatch",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "cmd.module"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Valida√ß√£o de M√≥dulos > m√≥dulos devem seguir padr√£o de naming",
    "testType": "unit",
    "functionUnderTest": ".replace",
    "whatItTests": "Valida que **`.replace`** consegue Valida√ß√£o de M√≥dulos > m√≥dulos devem seguir padr√£o de naming. **Valida√ß√µes**: `moduleName.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeTruthy, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "moduleName = ..."
    ],
    "when": ".replace",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeTruthy",
        "path": "moduleName"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "moduleName.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "todos os comandos devem apontar para m√≥dulos .js v√°lidos",
    "testType": "unit",
    "functionUnderTest": ".toMatch",
    "whatItTests": "Valida que **`.toMatch`** consegue todos os comandos devem apontar para m√≥dulos .js v√°lidos. **Valida√ß√µes**: `cmd.module` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toMatch",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "cmd.module"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "m√≥dulos devem seguir padr√£o de naming",
    "testType": "unit",
    "functionUnderTest": ".replace",
    "whatItTests": "Valida que **`.replace`** consegue m√≥dulos devem seguir padr√£o de naming. **Valida√ß√µes**: `moduleName.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeTruthy, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "moduleName = ..."
    ],
    "when": ".replace",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeTruthy",
        "path": "moduleName"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "moduleName.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Defaults Sensatos > comando validate deve aceitar thresholds opcionais",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue aceitar thresholds opcionais. **Valida√ß√µes**: `unknown.required` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validateCmd = ...",
      "minBranch = ...",
      "minMutation = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "minBranch"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.required"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "minMutation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Defaults Sensatos > comando scaffold deve ter defaults √∫teis",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter defaults √∫teis. **Valida√ß√µes**: `unknown.defaultValue` = `\"unit\"`, `unknown.defaultValue` = `\"vitest\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldCmd = ...",
      "typeFlag = ...",
      "frameworkFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "typeFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "unit",
        "path": "unknown.defaultValue"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "frameworkFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Defaults Sensatos > comando self-check deve ter repo default",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter repo default. **Valida√ß√µes**: `unknown.defaultValue` = `\".\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "selfCheckCmd = ...",
      "repoFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "repoFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "comando validate deve aceitar thresholds opcionais",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue aceitar thresholds opcionais. **Valida√ß√µes**: `unknown.required` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validateCmd = ...",
      "minBranch = ...",
      "minMutation = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "minBranch"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown.required"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "minMutation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "comando scaffold deve ter defaults √∫teis",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter defaults √∫teis. **Valida√ß√µes**: `unknown.defaultValue` = `\"unit\"`, `unknown.defaultValue` = `\"vitest\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldCmd = ...",
      "typeFlag = ...",
      "frameworkFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "typeFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "unit",
        "path": "unknown.defaultValue"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "frameworkFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "comando self-check deve ter repo default",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue ter repo default. **Valida√ß√µes**: `unknown.defaultValue` = `\".\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "selfCheckCmd = ...",
      "repoFlag = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "repoFlag"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "unknown.defaultValue"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Exemplos de Uso > comandos principais devem ter exemplos",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue Exemplos de Uso > comandos principais devem ter exemplos. **Valida√ß√µes**: `unknown.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "criticalCommands = ...",
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "cmd"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown.examples"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Exemplos de Uso > exemplos devem conter nome do comando",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue Exemplos de Uso > exemplos devem conter nome do comando. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "example"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "Exemplos de Uso > exemplos devem ter sintaxe v√°lida",
    "testType": "unit",
    "functionUnderTest": ".toMatch",
    "whatItTests": "Valida que **`.toMatch`** consegue Exemplos de Uso > exemplos devem ter sintaxe v√°lida. **Valida√ß√µes**: `example` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toMatch",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "example"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "comandos principais devem ter exemplos",
    "testType": "unit",
    "functionUnderTest": "findCommand",
    "whatItTests": "Valida que **`findCommand`** consegue comandos principais devem ter exemplos. **Valida√ß√µes**: `unknown.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "criticalCommands = ...",
      "cmd = ..."
    ],
    "when": "findCommand",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "cmd"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown.examples"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "exemplos devem conter nome do comando",
    "testType": "unit",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue exemplos devem conter nome do comando. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "example"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-manifest.test.ts",
    "name": "exemplos devem ter sintaxe v√°lida",
    "testType": "unit",
    "functionUnderTest": ".toMatch",
    "whatItTests": "Valida que **`.toMatch`** consegue exemplos devem ter sintaxe v√°lida. **Valida√ß√µes**: `example` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toMatch",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "example"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Boolean flags devem funcionar SEM <value> > --skip-run deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.skipRun` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeCmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Boolean flags devem funcionar SEM <value> > --fix deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.fix` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "selfCheckCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "selfCheckCmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.fix"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Boolean flags devem funcionar SEM <value> > --skip-scaffold deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.skipScaffold` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipScaffold"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > --skip-run deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.skipRun` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeCmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > --fix deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.fix` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "selfCheckCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "selfCheckCmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.fix"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > --skip-scaffold deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.skipScaffold` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipScaffold"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Value flags devem EXIGIR <value> > --repo deve rejeitar se n√£o tiver valor",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue rejeitar se n√£o tiver valor. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Value flags devem EXIGIR <value> > --product deve aceitar valor",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar valor. **Valida√ß√µes**: `opts.product` = `\"my-product\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "my-product",
        "path": "opts.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > --repo deve rejeitar se n√£o tiver valor",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue rejeitar se n√£o tiver valor. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > --product deve aceitar valor",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar valor. **Valida√ß√µes**: `opts.product` = `\"my-product\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "my-product",
        "path": "opts.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > analyze --repo . --product \"mcp\" --mode analyze --skip-run",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > analyze --repo . --product \"mcp\" --mode analyze --skip-run. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.product` = `\"mcp\"`, `opts.mode` = `\"analyze\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mcp",
        "path": "opts.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "opts.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > self-check --repo . --fix",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > self-check --repo . --fix. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.fix` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "selfCheckCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.fix"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > validate --repo . --min-mutation 60 --min-branch 70 --fail-fast. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.minMutation` = `\"60\"`, `opts.minBranch` = `\"70\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "program = ...",
      "validateCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "60",
        "path": "opts.minMutation"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "70",
        "path": "opts.minBranch"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.failFast"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > analyze --repo . --product \"mcp\" --mode analyze --skip-run",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > analyze --repo . --product \"mcp\" --mode analyze --skip-run. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.product` = `\"mcp\"`, `opts.mode` = `\"analyze\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mcp",
        "path": "opts.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "opts.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > self-check --repo . --fix",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > self-check --repo . --fix. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.fix` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "selfCheckCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.fix"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > validate --repo . --min-mutation 60 --min-branch 70 --fail-fast. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.minMutation` = `\"60\"`, `opts.minBranch` = `\"70\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "program = ...",
      "validateCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "60",
        "path": "opts.minMutation"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "70",
        "path": "opts.minBranch"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.failFast"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "DETEC√á√ÉO DE TIPO: defaultValue define comportamento > Boolean defaultValue = flag sem <value>",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue DETEC√á√ÉO DE TIPO: defaultValue define comportamento > Boolean defaultValue = flag sem <value>. **Valida√ß√µes**: `booleanFlags.length` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analyzeCmd = ...",
      "booleanFlags = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "booleanFlags.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "DETEC√á√ÉO DE TIPO: defaultValue define comportamento > String/Number defaultValue = flag com <value>",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue DETEC√á√ÉO DE TIPO: defaultValue define comportamento > String/Number defaultValue = flag com <value>. **Valida√ß√µes**: `valueFlags.length` = `3`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analyzeCmd = ...",
      "valueFlags = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 3,
        "path": "valueFlags.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > Boolean defaultValue = flag sem <value>",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > Boolean defaultValue = flag sem <value>. **Valida√ß√µes**: `booleanFlags.length` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analyzeCmd = ...",
      "booleanFlags = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "booleanFlags.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > String/Number defaultValue = flag com <value>",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue üî• CLI Boolean Flags - INTEGRA√á√ÉO REAL > String/Number defaultValue = flag com <value>. **Valida√ß√µes**: `valueFlags.length` = `3`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analyzeCmd = ...",
      "valueFlags = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 3,
        "path": "valueFlags.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Boolean flags devem funcionar SEM <value> > --skip-run deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.skipRun` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeCmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Boolean flags devem funcionar SEM <value> > --fix deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.fix` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "selfCheckCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "selfCheckCmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.fix"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Boolean flags devem funcionar SEM <value> > --skip-scaffold deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.skipScaffold` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipScaffold"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "--skip-run deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.skipRun` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "analyzeCmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "--fix deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.fix` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "selfCheckCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "selfCheckCmd"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.fix"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "--skip-scaffold deve aceitar sintaxe boolean (sem valor)",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar sintaxe boolean (sem valor). **Valida√ß√µes**: `opts.skipScaffold` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipScaffold"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Value flags devem EXIGIR <value> > --repo deve rejeitar se n√£o tiver valor",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue rejeitar se n√£o tiver valor. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "CRITICAL: Value flags devem EXIGIR <value> > --product deve aceitar valor",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar valor. **Valida√ß√µes**: `opts.product` = `\"my-product\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "my-product",
        "path": "opts.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "--repo deve rejeitar se n√£o tiver valor",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue rejeitar se n√£o tiver valor. **1 valida√ß√µes** usando: toThrow",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "--product deve aceitar valor",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue aceitar valor. **Valida√ß√µes**: `opts.product` = `\"my-product\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "my-product",
        "path": "opts.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > analyze --repo . --product \"mcp\" --mode analyze --skip-run",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > analyze --repo . --product \"mcp\" --mode analyze --skip-run. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.product` = `\"mcp\"`, `opts.mode` = `\"analyze\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mcp",
        "path": "opts.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "opts.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > self-check --repo . --fix",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > self-check --repo . --fix. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.fix` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "selfCheckCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.fix"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue REGRESS√ÉO e6939d9: Comandos do CI devem funcionar > validate --repo . --min-mutation 60 --min-branch 70 --fail-fast. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.minMutation` = `\"60\"`, `opts.minBranch` = `\"70\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "program = ...",
      "validateCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "60",
        "path": "opts.minMutation"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "70",
        "path": "opts.minBranch"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.failFast"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "analyze --repo . --product \"mcp\" --mode analyze --skip-run",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue analyze --repo . --product \"mcp\" --mode analyze --skip-run. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.product` = `\"mcp\"`, `opts.mode` = `\"analyze\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "program = ...",
      "analyzeCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mcp",
        "path": "opts.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "opts.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "self-check --repo . --fix",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue self-check --repo . --fix. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.fix` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "program = ...",
      "selfCheckCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.fix"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue validate --repo . --min-mutation 60 --min-branch 70 --fail-fast. **Valida√ß√µes**: `opts.repo` = `\".\"`, `opts.minMutation` = `\"60\"`, `opts.minBranch` = `\"70\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "program = ...",
      "validateCmd = ...",
      "cmd = ...",
      "isBoolean = ...",
      "flagName = ...",
      "isBoolean = ...",
      "flagName = ...",
      "opts = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".",
        "path": "opts.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "60",
        "path": "opts.minMutation"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "70",
        "path": "opts.minBranch"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "opts.failFast"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "DETEC√á√ÉO DE TIPO: defaultValue define comportamento > Boolean defaultValue = flag sem <value>",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue DETEC√á√ÉO DE TIPO: defaultValue define comportamento > Boolean defaultValue = flag sem <value>. **Valida√ß√µes**: `booleanFlags.length` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analyzeCmd = ...",
      "booleanFlags = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "booleanFlags.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "DETEC√á√ÉO DE TIPO: defaultValue define comportamento > String/Number defaultValue = flag com <value>",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue DETEC√á√ÉO DE TIPO: defaultValue define comportamento > String/Number defaultValue = flag com <value>. **Valida√ß√µes**: `valueFlags.length` = `3`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analyzeCmd = ...",
      "valueFlags = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 3,
        "path": "valueFlags.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "Boolean defaultValue = flag sem <value>",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue Boolean defaultValue = flag sem <value>. **Valida√ß√µes**: `booleanFlags.length` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analyzeCmd = ...",
      "booleanFlags = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "booleanFlags.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/__tests__/cli-boolean-flags.integration.test.ts",
    "name": "String/Number defaultValue = flag com <value>",
    "testType": "integration",
    "functionUnderTest": "COMMANDS.find",
    "whatItTests": "Valida que **`COMMANDS.find`** consegue String/Number defaultValue = flag com <value>. **Valida√ß√µes**: `valueFlags.length` = `3`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analyzeCmd = ...",
      "valueFlags = ..."
    ],
    "when": "COMMANDS.find",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 3,
        "path": "valueFlags.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should calculate CRITICAL risk for high probability and high impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate CRITICAL risk for high probability and high impact. **Valida√ß√µes**: `result.probability` = `80`, `result.impact` = `80`, `result.score` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.probability"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "result.level"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/auth/login.ts",
        "path": "result.file"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.reasons.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should calculate LOW risk for low probability and low impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate LOW risk for low probability and low impact. **Valida√ß√µes**: `result.probability` = `20`, `result.impact` = `20`, `result.score` = `40` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 20,
        "path": "result.probability"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 20,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should calculate HIGH risk for medium probability and high impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate HIGH risk for medium probability and high impact. **Valida√ß√µes**: `result.score` = `40`, `result.score` = `80`, `result.level` = `\"MEDIUM\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 80,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MEDIUM",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should calculate LOW-MEDIUM risk for balanced factors",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate LOW-MEDIUM risk for balanced factors. **Valida√ß√µes**: `result.score` = `10`, `result.score` = `40`, `result.level` = `\"LOW\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should generate descriptive reasons",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue generate descriptive reasons. **Valida√ß√µes**: `result.reasons.some()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.reasons.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should handle zero test coverage correctly",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue handle zero test coverage correctly. **Valida√ß√µes**: `result.impact` = `30`, `result.reasons.some()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 30,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.reasons.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should calculate CRITICAL risk for high probability and high impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate CRITICAL risk for high probability and high impact. **Valida√ß√µes**: `result.probability` = `80`, `result.impact` = `80`, `result.score` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.probability"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "result.level"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/auth/login.ts",
        "path": "result.file"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.reasons.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should calculate LOW risk for low probability and low impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate LOW risk for low probability and low impact. **Valida√ß√µes**: `result.probability` = `20`, `result.impact` = `20`, `result.score` = `40` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 20,
        "path": "result.probability"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 20,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should calculate HIGH risk for medium probability and high impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate HIGH risk for medium probability and high impact. **Valida√ß√µes**: `result.score` = `40`, `result.score` = `80`, `result.level` = `\"MEDIUM\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 80,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MEDIUM",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should calculate LOW-MEDIUM risk for balanced factors",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate LOW-MEDIUM risk for balanced factors. **Valida√ß√µes**: `result.score` = `10`, `result.score` = `40`, `result.level` = `\"LOW\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should generate descriptive reasons",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue generate descriptive reasons. **Valida√ß√µes**: `result.reasons.some()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.reasons.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should handle zero test coverage correctly",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue handle zero test coverage correctly. **Valida√ß√µes**: `result.impact` = `30`, `result.reasons.some()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 30,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.reasons.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateChangeFrequency > should estimate high frequency for sensitive files",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue estimate high frequency for sensitive files. **Valida√ß√µes**: `estimateChangeFrequency()` = `50`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 50,
        "path": "estimateChangeFrequency()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateChangeFrequency > should estimate low frequency for config files",
    "testType": "unit",
    "functionUnderTest": ".toBeLessThan",
    "whatItTests": "Valida que **`.toBeLessThan`** consegue estimate low frequency for config files. **Valida√ß√µes**: `estimateChangeFrequency()` = `40`, `estimateChangeFrequency()` = `60`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeLessThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "estimateChangeFrequency()"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 60,
        "path": "estimateChangeFrequency()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateChangeFrequency > should estimate medium frequency for regular files",
    "testType": "unit",
    "functionUnderTest": "estimateChangeFrequency",
    "whatItTests": "Valida que **`estimateChangeFrequency`** consegue estimate medium frequency for regular files. **Valida√ß√µes**: `freq` = `40`, `freq` = `60`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "freq = ..."
    ],
    "when": "estimateChangeFrequency",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 40,
        "path": "freq"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 60,
        "path": "freq"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should estimate high frequency for sensitive files",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue estimate high frequency for sensitive files. **Valida√ß√µes**: `estimateChangeFrequency()` = `50`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 50,
        "path": "estimateChangeFrequency()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should estimate low frequency for config files",
    "testType": "unit",
    "functionUnderTest": ".toBeLessThan",
    "whatItTests": "Valida que **`.toBeLessThan`** consegue estimate low frequency for config files. **Valida√ß√µes**: `estimateChangeFrequency()` = `40`, `estimateChangeFrequency()` = `60`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeLessThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "estimateChangeFrequency()"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 60,
        "path": "estimateChangeFrequency()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should estimate medium frequency for regular files",
    "testType": "unit",
    "functionUnderTest": "estimateChangeFrequency",
    "whatItTests": "Valida que **`estimateChangeFrequency`** consegue estimate medium frequency for regular files. **Valida√ß√µes**: `freq` = `40`, `freq` = `60`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "freq = ..."
    ],
    "when": "estimateChangeFrequency",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 40,
        "path": "freq"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 60,
        "path": "freq"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateComplexity > should estimate high complexity for parsing/analysis files",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue estimate high complexity for parsing/analysis files. **Valida√ß√µes**: `estimateComplexity()` = `70`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 70,
        "path": "estimateComplexity()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateComplexity > should estimate medium complexity for API files",
    "testType": "unit",
    "functionUnderTest": "estimateComplexity",
    "whatItTests": "Valida que **`estimateComplexity`** consegue estimate medium complexity for API files. **Valida√ß√µes**: `complexity` = `50`, `complexity` = `70`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "complexity = ..."
    ],
    "when": "estimateComplexity",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 50,
        "path": "complexity"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 70,
        "path": "complexity"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateComplexity > should estimate low complexity for config files",
    "testType": "unit",
    "functionUnderTest": ".toBeLessThan",
    "whatItTests": "Valida que **`.toBeLessThan`** consegue estimate low complexity for config files. **Valida√ß√µes**: `estimateComplexity()` = `30`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeLessThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 30,
        "path": "estimateComplexity()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateComplexity > should count conditionals from file content",
    "testType": "unit",
    "functionUnderTest": "estimateComplexity",
    "whatItTests": "Valida que **`estimateComplexity`** consegue count conditionals from file content. **Valida√ß√µes**: `complexity` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "content = ...",
      "complexity = ..."
    ],
    "when": "estimateComplexity",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "complexity"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should estimate high complexity for parsing/analysis files",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue estimate high complexity for parsing/analysis files. **Valida√ß√µes**: `estimateComplexity()` = `70`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 70,
        "path": "estimateComplexity()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should estimate medium complexity for API files",
    "testType": "unit",
    "functionUnderTest": "estimateComplexity",
    "whatItTests": "Valida que **`estimateComplexity`** consegue estimate medium complexity for API files. **Valida√ß√µes**: `complexity` = `50`, `complexity` = `70`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "complexity = ..."
    ],
    "when": "estimateComplexity",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 50,
        "path": "complexity"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 70,
        "path": "complexity"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should estimate low complexity for config files",
    "testType": "unit",
    "functionUnderTest": ".toBeLessThan",
    "whatItTests": "Valida que **`.toBeLessThan`** consegue estimate low complexity for config files. **Valida√ß√µes**: `estimateComplexity()` = `30`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeLessThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 30,
        "path": "estimateComplexity()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should count conditionals from file content",
    "testType": "unit",
    "functionUnderTest": "estimateComplexity",
    "whatItTests": "Valida que **`estimateComplexity`** consegue count conditionals from file content. **Valida√ß√µes**: `complexity` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "content = ...",
      "complexity = ..."
    ],
    "when": "estimateComplexity",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "complexity"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateRecentBugs > should return 0 for files without bug tracking",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return 0 for files without bug tracking. **Valida√ß√µes**: `estimateRecentBugs()` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "estimateRecentBugs()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should return 0 for files without bug tracking",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return 0 for files without bug tracking. **Valida√ß√µes**: `estimateRecentBugs()` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "estimateRecentBugs()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "isUserFacing > should detect user-facing files",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue detect user-facing files. **Valida√ß√µes**: `isUserFacing()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isUserFacing()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "isUserFacing > should detect non-user-facing files",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue detect non-user-facing files. **Valida√ß√µes**: `isUserFacing()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isUserFacing()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should detect user-facing files",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue detect user-facing files. **Valida√ß√µes**: `isUserFacing()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isUserFacing()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should detect non-user-facing files",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue detect non-user-facing files. **Valida√ß√µes**: `isUserFacing()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isUserFacing()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScores > should calculate and sort multiple scores",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScores",
    "whatItTests": "Valida que **`calculateRiskScores`** consegue calculate and sort multiple scores. **Valida√ß√µes**: `scores` = `3`, `scores.?.file` = `\"src/high-risk.ts\"`, `scores.?.file` = `\"src/low-risk.ts\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "files = ...",
      "scores = ..."
    ],
    "when": "calculateRiskScores",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "scores"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/high-risk.ts",
        "path": "scores.?.file"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/low-risk.ts",
        "path": "scores.?.file"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "path": "scores.?.score"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should calculate and sort multiple scores",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScores",
    "whatItTests": "Valida que **`calculateRiskScores`** consegue calculate and sort multiple scores. **Valida√ß√µes**: `scores` = `3`, `scores.?.file` = `\"src/high-risk.ts\"`, `scores.?.file` = `\"src/low-risk.ts\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "files = ...",
      "scores = ..."
    ],
    "when": "calculateRiskScores",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "scores"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/high-risk.ts",
        "path": "scores.?.file"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/low-risk.ts",
        "path": "scores.?.file"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "path": "scores.?.score"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "groupByRiskLevel > should group scores by risk level",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScores",
    "whatItTests": "Valida que **`calculateRiskScores`** consegue group scores by risk level. **Valida√ß√µes**: `grouped.CRITICAL.length` = `2`, `Object.keys().length` = `2`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scores = ...",
      "grouped = ..."
    ],
    "when": "calculateRiskScores",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "grouped.CRITICAL"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "grouped.CRITICAL.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "grouped.LOW"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "Object.keys().length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "risk-calculator > should group scores by risk level",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScores",
    "whatItTests": "Valida que **`calculateRiskScores`** consegue group scores by risk level. **Valida√ß√µes**: `grouped.CRITICAL.length` = `2`, `Object.keys().length` = `2`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scores = ...",
      "grouped = ..."
    ],
    "when": "calculateRiskScores",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "grouped.CRITICAL"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "grouped.CRITICAL.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "grouped.LOW"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "Object.keys().length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should calculate CRITICAL risk for high probability and high impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate CRITICAL risk for high probability and high impact. **Valida√ß√µes**: `result.probability` = `80`, `result.impact` = `80`, `result.score` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.probability"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "result.level"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/auth/login.ts",
        "path": "result.file"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.reasons.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should calculate LOW risk for low probability and low impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate LOW risk for low probability and low impact. **Valida√ß√µes**: `result.probability` = `20`, `result.impact` = `20`, `result.score` = `40` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 20,
        "path": "result.probability"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 20,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should calculate HIGH risk for medium probability and high impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate HIGH risk for medium probability and high impact. **Valida√ß√µes**: `result.score` = `40`, `result.score` = `80`, `result.level` = `\"MEDIUM\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 80,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MEDIUM",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should calculate LOW-MEDIUM risk for balanced factors",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate LOW-MEDIUM risk for balanced factors. **Valida√ß√µes**: `result.score` = `10`, `result.score` = `40`, `result.level` = `\"LOW\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should generate descriptive reasons",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue generate descriptive reasons. **Valida√ß√µes**: `result.reasons.some()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.reasons.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScore > should handle zero test coverage correctly",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue handle zero test coverage correctly. **Valida√ß√µes**: `result.impact` = `30`, `result.reasons.some()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 30,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.reasons.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should calculate CRITICAL risk for high probability and high impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate CRITICAL risk for high probability and high impact. **Valida√ß√µes**: `result.probability` = `80`, `result.impact` = `80`, `result.score` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.probability"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 80,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "result.level"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/auth/login.ts",
        "path": "result.file"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.reasons.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should calculate LOW risk for low probability and low impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate LOW risk for low probability and low impact. **Valida√ß√µes**: `result.probability` = `20`, `result.impact` = `20`, `result.score` = `40` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 20,
        "path": "result.probability"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 20,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should calculate HIGH risk for medium probability and high impact",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate HIGH risk for medium probability and high impact. **Valida√ß√µes**: `result.score` = `40`, `result.score` = `80`, `result.level` = `\"MEDIUM\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 80,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MEDIUM",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should calculate LOW-MEDIUM risk for balanced factors",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue calculate LOW-MEDIUM risk for balanced factors. **Valida√ß√µes**: `result.score` = `10`, `result.score` = `40`, `result.level` = `\"LOW\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "result.score"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "result.level"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should generate descriptive reasons",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue generate descriptive reasons. **Valida√ß√µes**: `result.reasons.some()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.reasons.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should handle zero test coverage correctly",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScore",
    "whatItTests": "Valida que **`calculateRiskScore`** consegue handle zero test coverage correctly. **Valida√ß√µes**: `result.impact` = `30`, `result.reasons.some()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "factors = ...",
      "result = ..."
    ],
    "when": "calculateRiskScore",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 30,
        "path": "result.impact"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.reasons.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateChangeFrequency > should estimate high frequency for sensitive files",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue estimate high frequency for sensitive files. **Valida√ß√µes**: `estimateChangeFrequency()` = `50`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 50,
        "path": "estimateChangeFrequency()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateChangeFrequency > should estimate low frequency for config files",
    "testType": "unit",
    "functionUnderTest": ".toBeLessThan",
    "whatItTests": "Valida que **`.toBeLessThan`** consegue estimate low frequency for config files. **Valida√ß√µes**: `estimateChangeFrequency()` = `40`, `estimateChangeFrequency()` = `60`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeLessThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "estimateChangeFrequency()"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 60,
        "path": "estimateChangeFrequency()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateChangeFrequency > should estimate medium frequency for regular files",
    "testType": "unit",
    "functionUnderTest": "estimateChangeFrequency",
    "whatItTests": "Valida que **`estimateChangeFrequency`** consegue estimate medium frequency for regular files. **Valida√ß√µes**: `freq` = `40`, `freq` = `60`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "freq = ..."
    ],
    "when": "estimateChangeFrequency",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 40,
        "path": "freq"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 60,
        "path": "freq"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should estimate high frequency for sensitive files",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue estimate high frequency for sensitive files. **Valida√ß√µes**: `estimateChangeFrequency()` = `50`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 50,
        "path": "estimateChangeFrequency()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should estimate low frequency for config files",
    "testType": "unit",
    "functionUnderTest": ".toBeLessThan",
    "whatItTests": "Valida que **`.toBeLessThan`** consegue estimate low frequency for config files. **Valida√ß√µes**: `estimateChangeFrequency()` = `40`, `estimateChangeFrequency()` = `60`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeLessThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 40,
        "path": "estimateChangeFrequency()"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 60,
        "path": "estimateChangeFrequency()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should estimate medium frequency for regular files",
    "testType": "unit",
    "functionUnderTest": "estimateChangeFrequency",
    "whatItTests": "Valida que **`estimateChangeFrequency`** consegue estimate medium frequency for regular files. **Valida√ß√µes**: `freq` = `40`, `freq` = `60`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "freq = ..."
    ],
    "when": "estimateChangeFrequency",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 40,
        "path": "freq"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 60,
        "path": "freq"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateComplexity > should estimate high complexity for parsing/analysis files",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue estimate high complexity for parsing/analysis files. **Valida√ß√µes**: `estimateComplexity()` = `70`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 70,
        "path": "estimateComplexity()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateComplexity > should estimate medium complexity for API files",
    "testType": "unit",
    "functionUnderTest": "estimateComplexity",
    "whatItTests": "Valida que **`estimateComplexity`** consegue estimate medium complexity for API files. **Valida√ß√µes**: `complexity` = `50`, `complexity` = `70`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "complexity = ..."
    ],
    "when": "estimateComplexity",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 50,
        "path": "complexity"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 70,
        "path": "complexity"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateComplexity > should estimate low complexity for config files",
    "testType": "unit",
    "functionUnderTest": ".toBeLessThan",
    "whatItTests": "Valida que **`.toBeLessThan`** consegue estimate low complexity for config files. **Valida√ß√µes**: `estimateComplexity()` = `30`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeLessThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 30,
        "path": "estimateComplexity()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateComplexity > should count conditionals from file content",
    "testType": "unit",
    "functionUnderTest": "estimateComplexity",
    "whatItTests": "Valida que **`estimateComplexity`** consegue count conditionals from file content. **Valida√ß√µes**: `complexity` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "content = ...",
      "complexity = ..."
    ],
    "when": "estimateComplexity",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "complexity"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should estimate high complexity for parsing/analysis files",
    "testType": "unit",
    "functionUnderTest": ".toBeGreaterThan",
    "whatItTests": "Valida que **`.toBeGreaterThan`** consegue estimate high complexity for parsing/analysis files. **Valida√ß√µes**: `estimateComplexity()` = `70`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeGreaterThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 70,
        "path": "estimateComplexity()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should estimate medium complexity for API files",
    "testType": "unit",
    "functionUnderTest": "estimateComplexity",
    "whatItTests": "Valida que **`estimateComplexity`** consegue estimate medium complexity for API files. **Valida√ß√µes**: `complexity` = `50`, `complexity` = `70`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "complexity = ..."
    ],
    "when": "estimateComplexity",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 50,
        "path": "complexity"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 70,
        "path": "complexity"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should estimate low complexity for config files",
    "testType": "unit",
    "functionUnderTest": ".toBeLessThan",
    "whatItTests": "Valida que **`.toBeLessThan`** consegue estimate low complexity for config files. **Valida√ß√µes**: `estimateComplexity()` = `30`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBeLessThan",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 30,
        "path": "estimateComplexity()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should count conditionals from file content",
    "testType": "unit",
    "functionUnderTest": "estimateComplexity",
    "whatItTests": "Valida que **`estimateComplexity`** consegue count conditionals from file content. **Valida√ß√µes**: `complexity` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "content = ...",
      "complexity = ..."
    ],
    "when": "estimateComplexity",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "complexity"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "estimateRecentBugs > should return 0 for files without bug tracking",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return 0 for files without bug tracking. **Valida√ß√µes**: `estimateRecentBugs()` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "estimateRecentBugs()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should return 0 for files without bug tracking",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return 0 for files without bug tracking. **Valida√ß√µes**: `estimateRecentBugs()` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "estimateRecentBugs()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "isUserFacing > should detect user-facing files",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue detect user-facing files. **Valida√ß√µes**: `isUserFacing()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isUserFacing()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "isUserFacing > should detect non-user-facing files",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue detect non-user-facing files. **Valida√ß√µes**: `isUserFacing()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isUserFacing()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should detect user-facing files",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue detect user-facing files. **Valida√ß√µes**: `isUserFacing()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isUserFacing()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should detect non-user-facing files",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue detect non-user-facing files. **Valida√ß√µes**: `isUserFacing()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isUserFacing()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "calculateRiskScores > should calculate and sort multiple scores",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScores",
    "whatItTests": "Valida que **`calculateRiskScores`** consegue calculate and sort multiple scores. **Valida√ß√µes**: `scores` = `3`, `scores.?.file` = `\"src/high-risk.ts\"`, `scores.?.file` = `\"src/low-risk.ts\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "files = ...",
      "scores = ..."
    ],
    "when": "calculateRiskScores",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "scores"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/high-risk.ts",
        "path": "scores.?.file"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/low-risk.ts",
        "path": "scores.?.file"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "path": "scores.?.score"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should calculate and sort multiple scores",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScores",
    "whatItTests": "Valida que **`calculateRiskScores`** consegue calculate and sort multiple scores. **Valida√ß√µes**: `scores` = `3`, `scores.?.file` = `\"src/high-risk.ts\"`, `scores.?.file` = `\"src/low-risk.ts\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "files = ...",
      "scores = ..."
    ],
    "when": "calculateRiskScores",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "scores"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/high-risk.ts",
        "path": "scores.?.file"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/low-risk.ts",
        "path": "scores.?.file"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "path": "scores.?.score"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "groupByRiskLevel > should group scores by risk level",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScores",
    "whatItTests": "Valida que **`calculateRiskScores`** consegue group scores by risk level. **Valida√ß√µes**: `grouped.CRITICAL.length` = `2`, `Object.keys().length` = `2`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scores = ...",
      "grouped = ..."
    ],
    "when": "calculateRiskScores",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "grouped.CRITICAL"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "grouped.CRITICAL.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "grouped.LOW"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "Object.keys().length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/risk-calculator.test.ts",
    "name": "should group scores by risk level",
    "testType": "unit",
    "functionUnderTest": "calculateRiskScores",
    "whatItTests": "Valida que **`calculateRiskScores`** consegue group scores by risk level. **Valida√ß√µes**: `grouped.CRITICAL.length` = `2`, `Object.keys().length` = `2`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scores = ...",
      "grouped = ..."
    ],
    "when": "calculateRiskScores",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "grouped.CRITICAL"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "grouped.CRITICAL.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "grouped.LOW"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 2,
        "path": "Object.keys().length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getPaths > deve gerar paths padr√£o para qa/<product>",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue gerar paths padr√£o para qa/<product>. **Valida√ß√µes**: `paths.root` = `\"/repo/qa/my-app\"`, `paths.analyses` = `\"/repo/qa/my-app/tests/analyses\"`, `paths.reports` = `\"/repo/qa/my-app/tests/reports\"` e mais 8",
    "whyItTests": "Valida 11 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~11) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app",
        "path": "paths.root"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses",
        "path": "paths.analyses"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports",
        "path": "paths.reports"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/playwright",
        "path": "paths.playwrightReports"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/unit",
        "path": "paths.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/integration",
        "path": "paths.integration"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/e2e",
        "path": "paths.e2e"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/fixtures",
        "path": "paths.fixtures"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/fixtures/auth",
        "path": "paths.fixturesAuth"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/dashboards",
        "path": "paths.dashboards"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/patches",
        "path": "paths.patches"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getPaths > deve respeitar output_root customizado via settings",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue respeitar output_root customizado via settings. **Valida√ß√µes**: `paths.root` = `\"/repo/custom/qa-output\"`, `paths.analyses` = `\"/repo/custom/qa-output/tests/analyses\"`, `paths.reports` = `\"/repo/custom/qa-output/tests/reports\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settings = ...",
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/custom/qa-output",
        "path": "paths.root"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/custom/qa-output/tests/analyses",
        "path": "paths.analyses"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/custom/qa-output/tests/reports",
        "path": "paths.reports"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getPaths > deve funcionar com paths absolutos Windows-style",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue funcionar com paths absolutos Windows-style. **Valida√ß√µes**: `paths.root` = `\"my-app\"`, `paths.analyses` = `\"tests\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "my-app",
        "path": "paths.root"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests",
        "path": "paths.analyses"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getPaths > deve sanitizar corretamente nomes de produto com caracteres especiais",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue sanitizar corretamente nomes de produto com caracteres especiais. **Valida√ß√µes**: `paths1.root` = `\"/repo/qa/@scope/package\"`, `paths2.root` = `\"/repo/qa/my_app-v2\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths1 = ...",
      "paths2 = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/@scope/package",
        "path": "paths1.root"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my_app-v2",
        "path": "paths2.root"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve gerar paths padr√£o para qa/<product>",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue gerar paths padr√£o para qa/<product>. **Valida√ß√µes**: `paths.root` = `\"/repo/qa/my-app\"`, `paths.analyses` = `\"/repo/qa/my-app/tests/analyses\"`, `paths.reports` = `\"/repo/qa/my-app/tests/reports\"` e mais 8",
    "whyItTests": "Valida 11 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~11) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app",
        "path": "paths.root"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses",
        "path": "paths.analyses"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports",
        "path": "paths.reports"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/playwright",
        "path": "paths.playwrightReports"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/unit",
        "path": "paths.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/integration",
        "path": "paths.integration"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/e2e",
        "path": "paths.e2e"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/fixtures",
        "path": "paths.fixtures"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/fixtures/auth",
        "path": "paths.fixturesAuth"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/dashboards",
        "path": "paths.dashboards"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/patches",
        "path": "paths.patches"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve respeitar output_root customizado via settings",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue respeitar output_root customizado via settings. **Valida√ß√µes**: `paths.root` = `\"/repo/custom/qa-output\"`, `paths.analyses` = `\"/repo/custom/qa-output/tests/analyses\"`, `paths.reports` = `\"/repo/custom/qa-output/tests/reports\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settings = ...",
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/custom/qa-output",
        "path": "paths.root"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/custom/qa-output/tests/analyses",
        "path": "paths.analyses"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/custom/qa-output/tests/reports",
        "path": "paths.reports"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve funcionar com paths absolutos Windows-style",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue funcionar com paths absolutos Windows-style. **Valida√ß√µes**: `paths.root` = `\"my-app\"`, `paths.analyses` = `\"tests\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "my-app",
        "path": "paths.root"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests",
        "path": "paths.analyses"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve sanitizar corretamente nomes de produto com caracteres especiais",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue sanitizar corretamente nomes de produto com caracteres especiais. **Valida√ß√µes**: `paths1.root` = `\"/repo/qa/@scope/package\"`, `paths2.root` = `\"/repo/qa/my_app-v2\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths1 = ...",
      "paths2 = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/@scope/package",
        "path": "paths1.root"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my_app-v2",
        "path": "paths2.root"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "ensurePaths > deve criar todos os diret√≥rios da estrutura",
    "testType": "unit",
    "functionUnderTest": "ensurePaths",
    "whatItTests": "Valida que **`ensurePaths`** consegue criar todos os diret√≥rios da estrutura. **Valida√ß√µes**: `stats.isDirectory()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "dirsToCheck = ...",
      "stats = ..."
    ],
    "when": "ensurePaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "stats.isDirectory()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "ensurePaths > deve ser idempotente (n√£o falhar se diret√≥rios j√° existem)",
    "testType": "unit",
    "functionUnderTest": "ensurePaths",
    "whatItTests": "Valida que **`ensurePaths`** consegue ser idempotente (n√£o falhar se diret√≥rios j√° existem). **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "ensurePaths",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('ensurePaths > deve ser idempotente (n√£o falhar se ...', () => {\n  const result = ensurePaths(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('ensurePaths > deve ser idempotente (n√£o falhar se ...', () => {\n  const result = ensurePaths(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "ensurePaths > deve criar estrutura mesmo se diret√≥rio pai n√£o existir",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue criar estrutura mesmo se diret√≥rio pai n√£o existir. **Valida√ß√µes**: `stats.isDirectory()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "deepPaths = ...",
      "stats = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "stats.isDirectory()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve criar todos os diret√≥rios da estrutura",
    "testType": "unit",
    "functionUnderTest": "ensurePaths",
    "whatItTests": "Valida que **`ensurePaths`** consegue criar todos os diret√≥rios da estrutura. **Valida√ß√µes**: `stats.isDirectory()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "dirsToCheck = ...",
      "stats = ..."
    ],
    "when": "ensurePaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "stats.isDirectory()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve ser idempotente (n√£o falhar se diret√≥rios j√° existem)",
    "testType": "unit",
    "functionUnderTest": "ensurePaths",
    "whatItTests": "Valida que **`ensurePaths`** consegue ser idempotente (n√£o falhar se diret√≥rios j√° existem). **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": "ensurePaths",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve ser idempotente (n√£o falhar se diret√≥rios j√° ...', () => {\n  const result = ensurePaths(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve ser idempotente (n√£o falhar se diret√≥rios j√° ...', () => {\n  const result = ensurePaths(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve criar estrutura mesmo se diret√≥rio pai n√£o existir",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue criar estrutura mesmo se diret√≥rio pai n√£o existir. **Valida√ß√µes**: `stats.isDirectory()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "deepPaths = ...",
      "stats = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "stats.isDirectory()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "isWithinQARoot > deve retornar true para paths dentro de qa/<product>",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar true para paths dentro de qa/<product>. **Valida√ß√µes**: `isWithinQARoot()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isWithinQARoot()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "isWithinQARoot > deve retornar false para paths fora de qa/<product>",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar false para paths fora de qa/<product>. **Valida√ß√µes**: `isWithinQARoot()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isWithinQARoot()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "isWithinQARoot > deve normalizar separadores de path (Windows vs Unix)",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue normalizar separadores de path (Windows vs Unix). **Valida√ß√µes**: `isWithinQARoot()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "windowsPath = ...",
      "unixPath = ...",
      "windowsPaths = ...",
      "unixPaths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isWithinQARoot()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve retornar true para paths dentro de qa/<product>",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar true para paths dentro de qa/<product>. **Valida√ß√µes**: `isWithinQARoot()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isWithinQARoot()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve retornar false para paths fora de qa/<product>",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar false para paths fora de qa/<product>. **Valida√ß√µes**: `isWithinQARoot()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isWithinQARoot()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve normalizar separadores de path (Windows vs Unix)",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue normalizar separadores de path (Windows vs Unix). **Valida√ß√µes**: `isWithinQARoot()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "windowsPath = ...",
      "unixPath = ...",
      "windowsPaths = ...",
      "unixPaths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isWithinQARoot()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getOutputPath > deve mapear JSON para analyses/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue mapear JSON para analyses/. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/tests/analyses/analyze.json\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/analyses/coverage-analysis.json\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses/analyze.json",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses/coverage-analysis.json",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getOutputPath > deve mapear MD e HTML para reports/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue mapear MD e HTML para reports/. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/tests/reports/PLAN.md\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/reports/QUALITY-REPORT.md\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/reports/PYRAMID.html\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/PLAN.md",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/QUALITY-REPORT.md",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/PYRAMID.html",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getOutputPath > deve mapear dashboard.html para dashboards/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue mapear dashboard.html para dashboards/. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/dashboards/dashboard.html\"`, `getOutputPath()` = `\"/repo/qa/my-app/dashboards/Dashboard.html\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/dashboards/dashboard.html",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/dashboards/Dashboard.html",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getOutputPath > deve mapear .patch para patches/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue mapear .patch para patches/. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/patches/fix-weak-assertions.patch\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/patches/fix-weak-assertions.patch",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getOutputPath > deve usar root como fallback para tipos desconhecidos",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar root como fallback para tipos desconhecidos. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/unknown.txt\"`, `getOutputPath()` = `\"/repo/qa/my-app/package.json\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/unknown.txt",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/package.json",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getOutputPath > deve ser case-insensitive para extens√µes",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue ser case-insensitive para extens√µes. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/tests/reports/REPORT.MD\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/analyses/Data.JSON\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/REPORT.MD",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses/Data.JSON",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve mapear JSON para analyses/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue mapear JSON para analyses/. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/tests/analyses/analyze.json\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/analyses/coverage-analysis.json\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses/analyze.json",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses/coverage-analysis.json",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve mapear MD e HTML para reports/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue mapear MD e HTML para reports/. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/tests/reports/PLAN.md\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/reports/QUALITY-REPORT.md\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/reports/PYRAMID.html\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/PLAN.md",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/QUALITY-REPORT.md",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/PYRAMID.html",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve mapear dashboard.html para dashboards/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue mapear dashboard.html para dashboards/. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/dashboards/dashboard.html\"`, `getOutputPath()` = `\"/repo/qa/my-app/dashboards/Dashboard.html\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/dashboards/dashboard.html",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/dashboards/Dashboard.html",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve mapear .patch para patches/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue mapear .patch para patches/. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/patches/fix-weak-assertions.patch\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/patches/fix-weak-assertions.patch",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve usar root como fallback para tipos desconhecidos",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar root como fallback para tipos desconhecidos. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/unknown.txt\"`, `getOutputPath()` = `\"/repo/qa/my-app/package.json\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/unknown.txt",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/package.json",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve ser case-insensitive para extens√µes",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue ser case-insensitive para extens√µes. **Valida√ß√µes**: `getOutputPath()` = `\"/repo/qa/my-app/tests/reports/REPORT.MD\"`, `getOutputPath()` = `\"/repo/qa/my-app/tests/analyses/Data.JSON\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/reports/REPORT.MD",
        "path": "getOutputPath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app/tests/analyses/Data.JSON",
        "path": "getOutputPath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getRelativePath > deve retornar path relativo ao root do QA",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar path relativo ao root do QA. **Valida√ß√µes**: `getRelativePath()` = `\"tests/reports/PLAN.md\"`, `getRelativePath()` = `\"tests/analyses/analyze.json\"`, `getRelativePath()` = `\"dashboards/dashboard.html\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tests/reports/PLAN.md",
        "path": "getRelativePath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tests/analyses/analyze.json",
        "path": "getRelativePath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "dashboards/dashboard.html",
        "path": "getRelativePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getRelativePath > deve retornar path original se n√£o estiver dentro do root",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar path original se n√£o estiver dentro do root. **Valida√ß√µes**: `getRelativePath()` = `\"outsidePath\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "outsidePath = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "outsidePath",
        "path": "getRelativePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "getRelativePath > deve normalizar separadores de path",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue normalizar separadores de path. **Valida√ß√µes**: `relative` = `\"tests/unit/foo.test.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "windowsPath = ...",
      "windowsPaths = ...",
      "relative = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tests/unit/foo.test.ts",
        "path": "relative"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve retornar path relativo ao root do QA",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar path relativo ao root do QA. **Valida√ß√µes**: `getRelativePath()` = `\"tests/reports/PLAN.md\"`, `getRelativePath()` = `\"tests/analyses/analyze.json\"`, `getRelativePath()` = `\"dashboards/dashboard.html\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tests/reports/PLAN.md",
        "path": "getRelativePath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tests/analyses/analyze.json",
        "path": "getRelativePath()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "dashboards/dashboard.html",
        "path": "getRelativePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve retornar path original se n√£o estiver dentro do root",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar path original se n√£o estiver dentro do root. **Valida√ß√µes**: `getRelativePath()` = `\"outsidePath\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "outsidePath = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "outsidePath",
        "path": "getRelativePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve normalizar separadores de path",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue normalizar separadores de path. **Valida√ß√µes**: `relative` = `\"tests/unit/foo.test.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "windowsPath = ...",
      "windowsPaths = ...",
      "relative = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tests/unit/foo.test.ts",
        "path": "relative"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "QAPaths interface compliance > deve ter todas as propriedades necess√°rias",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue ter todas as propriedades necess√°rias. **Valida√ß√µes**: `paths` = `\"prop\"`, `unknown` = `\"string\"`, `paths.prop.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveProperty, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ...",
      "requiredProps = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "prop",
        "path": "paths"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "paths.prop.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "QAPaths interface compliance > deve ter paths √∫nicos (sem duplicatas)",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue ter paths √∫nicos (sem duplicatas). **1 valida√ß√µes** usando: toBe",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ...",
      "allPaths = ...",
      "uniquePaths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "uniquePaths.size"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve ter todas as propriedades necess√°rias",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue ter todas as propriedades necess√°rias. **Valida√ß√µes**: `paths` = `\"prop\"`, `unknown` = `\"string\"`, `paths.prop.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveProperty, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ...",
      "requiredProps = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "prop",
        "path": "paths"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "paths.prop.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve ter paths √∫nicos (sem duplicatas)",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue ter paths √∫nicos (sem duplicatas). **1 valida√ß√µes** usando: toBe",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ...",
      "allPaths = ...",
      "uniquePaths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "uniquePaths.size"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "Edge cases e valida√ß√µes > deve lidar com product name vazio ou inv√°lido",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue lidar com product name vazio ou inv√°lido. **Valida√ß√µes**: `paths1.root` = `\"/repo/qa\"`, `paths2.root` = `\"/repo/qa\"`, `paths1.analyses` = `\"tests/analyses\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths1 = ...",
      "paths2 = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/repo/qa",
        "path": "paths1.root"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/repo/qa",
        "path": "paths2.root"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests/analyses",
        "path": "paths1.analyses"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests/analyses",
        "path": "paths2.analyses"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "Edge cases e valida√ß√µes > deve lidar com repo path com espa√ßos",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue lidar com repo path com espa√ßos. **Valida√ß√µes**: `paths.root` = `\"/Users/my folder/repo/qa/my-app\"`, `paths.analyses` = `\"/Users/my folder/repo/qa/my-app/tests/analyses\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/Users/my folder/repo/qa/my-app",
        "path": "paths.root"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/Users/my folder/repo/qa/my-app/tests/analyses",
        "path": "paths.analyses"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "Edge cases e valida√ß√µes > deve preservar case do product name",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue preservar case do product name. **Valida√ß√µes**: `paths.root` = `\"/repo/qa/MyApp-V2\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/MyApp-V2",
        "path": "paths.root"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "Edge cases e valida√ß√µes > deve funcionar com settings undefined",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue funcionar com settings undefined. **Valida√ß√µes**: `paths.root` = `\"/repo/qa/my-app\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app",
        "path": "paths.root"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "Edge cases e valida√ß√µes > deve funcionar com settings.paths undefined",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue funcionar com settings.paths undefined. **Valida√ß√µes**: `paths.root` = `\"/repo/qa/my-app\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "settings = ...",
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app",
        "path": "paths.root"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve lidar com product name vazio ou inv√°lido",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue lidar com product name vazio ou inv√°lido. **Valida√ß√µes**: `paths1.root` = `\"/repo/qa\"`, `paths2.root` = `\"/repo/qa\"`, `paths1.analyses` = `\"tests/analyses\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths1 = ...",
      "paths2 = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/repo/qa",
        "path": "paths1.root"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/repo/qa",
        "path": "paths2.root"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests/analyses",
        "path": "paths1.analyses"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests/analyses",
        "path": "paths2.analyses"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve lidar com repo path com espa√ßos",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue lidar com repo path com espa√ßos. **Valida√ß√µes**: `paths.root` = `\"/Users/my folder/repo/qa/my-app\"`, `paths.analyses` = `\"/Users/my folder/repo/qa/my-app/tests/analyses\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/Users/my folder/repo/qa/my-app",
        "path": "paths.root"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/Users/my folder/repo/qa/my-app/tests/analyses",
        "path": "paths.analyses"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve preservar case do product name",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue preservar case do product name. **Valida√ß√µes**: `paths.root` = `\"/repo/qa/MyApp-V2\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/MyApp-V2",
        "path": "paths.root"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve funcionar com settings undefined",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue funcionar com settings undefined. **Valida√ß√µes**: `paths.root` = `\"/repo/qa/my-app\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app",
        "path": "paths.root"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/paths.test.ts",
    "name": "deve funcionar com settings.paths undefined",
    "testType": "unit",
    "functionUnderTest": "getPaths",
    "whatItTests": "Valida que **`getPaths`** consegue funcionar com settings.paths undefined. **Valida√ß√µes**: `paths.root` = `\"/repo/qa/my-app\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "settings = ...",
      "paths = ..."
    ],
    "when": "getPaths",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/repo/qa/my-app",
        "path": "paths.root"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "ensureDir > deve criar diret√≥rio recursivamente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar diret√≥rio recursivamente. **Valida√ß√µes**: `stats.isDirectory()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nestedDir = ...",
      "stats = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "stats.isDirectory()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "ensureDir > n√£o deve falhar se diret√≥rio j√° existir",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue falhar se diret√≥rio j√° existir. **Valida√ß√µes**: `stats.isDirectory()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "stats = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "stats.isDirectory()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve criar diret√≥rio recursivamente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar diret√≥rio recursivamente. **Valida√ß√µes**: `stats.isDirectory()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nestedDir = ...",
      "stats = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "stats.isDirectory()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "n√£o deve falhar se diret√≥rio j√° existir",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue falhar se diret√≥rio j√° existir. **Valida√ß√µes**: `stats.isDirectory()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "stats = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "stats.isDirectory()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "writeFileSafe > deve criar diret√≥rio pai e escrever arquivo",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar diret√≥rio pai e escrever arquivo. **Valida√ß√µes**: `readContent` = `\"content\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "content = ...",
      "readContent = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content",
        "path": "readContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "writeFileSafe > deve sobrescrever arquivo existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sobrescrever arquivo existente. **Valida√ß√µes**: `readContent` = `\"New content\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "readContent = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "New content",
        "path": "readContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve criar diret√≥rio pai e escrever arquivo",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar diret√≥rio pai e escrever arquivo. **Valida√ß√µes**: `readContent` = `\"content\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "content = ...",
      "readContent = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content",
        "path": "readContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve sobrescrever arquivo existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sobrescrever arquivo existente. **Valida√ß√µes**: `readContent` = `\"New content\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "readContent = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "New content",
        "path": "readContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "readFile > deve lan√ßar erro se arquivo n√£o existir",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lan√ßar erro se arquivo n√£o existir. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "nonExistentFile = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('readFile > deve lan√ßar erro se arquivo n√£o existir...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('readFile > deve lan√ßar erro se arquivo n√£o existir...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "readFile > deve ler conte√∫do de arquivo existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ler conte√∫do de arquivo existente. **Valida√ß√µes**: `readContent` = `\"content\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "content = ...",
      "readContent = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content",
        "path": "readContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve lan√ßar erro se arquivo n√£o existir",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lan√ßar erro se arquivo n√£o existir. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "nonExistentFile = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve lan√ßar erro se arquivo n√£o existir...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve lan√ßar erro se arquivo n√£o existir...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve ler conte√∫do de arquivo existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ler conte√∫do de arquivo existente. **Valida√ß√µes**: `readContent` = `\"content\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "content = ...",
      "readContent = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content",
        "path": "readContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Side Effects: ensureDir > deve chamar fs.mkdir com op√ß√£o recursive:true",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue chamar fs.mkdir com op√ß√£o recursive:true. **Valida√ß√µes**: `mkdirSpy` = `\"nestedDir\"`, `mkdirSpy` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalledWith, toHaveBeenCalledTimes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mkdirSpy = ...",
      "nestedDir = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "nestedDir",
        "path": "mkdirSpy"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledTimes",
        "value": 1,
        "path": "mkdirSpy"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Side Effects: ensureDir > n√£o deve falhar quando diret√≥rio j√° existe (EEXIST)",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue falhar quando diret√≥rio j√° existe (EEXIST). **Valida√ß√µes**: `mkdirSpy` = `\"testDir\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mkdirSpy = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "testDir",
        "path": "mkdirSpy"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve chamar fs.mkdir com op√ß√£o recursive:true",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue chamar fs.mkdir com op√ß√£o recursive:true. **Valida√ß√µes**: `mkdirSpy` = `\"nestedDir\"`, `mkdirSpy` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalledWith, toHaveBeenCalledTimes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mkdirSpy = ...",
      "nestedDir = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "nestedDir",
        "path": "mkdirSpy"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledTimes",
        "value": 1,
        "path": "mkdirSpy"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "n√£o deve falhar quando diret√≥rio j√° existe (EEXIST)",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue falhar quando diret√≥rio j√° existe (EEXIST). **Valida√ß√µes**: `mkdirSpy` = `\"testDir\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mkdirSpy = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "testDir",
        "path": "mkdirSpy"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Side Effects: writeFileSafe > deve chamar ensureDir antes de escrever arquivo",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue chamar ensureDir antes de escrever arquivo. **Valida√ß√µes**: `mkdirSpy.mock.calls.?.?` = `\"{...}\"`, `writeFileSpy` = `\"filePath\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveBeenCalled, toEqual, toHaveBeenCalledWith, toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "filePath = ...",
      "content = ...",
      "mkdirSpy = ...",
      "writeFileSpy = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "mkdirSpy"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "mkdirSpy.mock.calls.?.?"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "filePath",
        "path": "writeFileSpy"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "path": "mkdirSpy.mock.invocationCallOrder.?"
      }
    ],
    "mocks": [
      "fs",
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Side Effects: writeFileSafe > deve criar backup quando arquivo existe e createBackup=true",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar backup quando arquivo existe e createBackup=true. **Valida√ß√µes**: `copyFileSpy` = `\"filePath\"`, `backupContent` = `\"oldContent\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalledWith, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "oldContent = ...",
      "newContent = ...",
      "copyFileSpy = ...",
      "backupContent = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "filePath",
        "path": "copyFileSpy"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "oldContent",
        "path": "backupContent"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Side Effects: writeFileSafe > deve logar mensagem de backup criado",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue logar mensagem de backup criado. **1 valida√ß√µes** usando: toHaveBeenCalledWith",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "consoleLogSpy"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Side Effects: writeFileSafe > n√£o deve criar backup quando createBackup=false",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar backup quando createBackup=false. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "filePath = ...",
      "copyFileSpy = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Side Effects: writeFileSafe > n√£o deve criar backu...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Side Effects: writeFileSafe > n√£o deve criar backu...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve chamar ensureDir antes de escrever arquivo",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue chamar ensureDir antes de escrever arquivo. **Valida√ß√µes**: `mkdirSpy.mock.calls.?.?` = `\"{...}\"`, `writeFileSpy` = `\"filePath\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveBeenCalled, toEqual, toHaveBeenCalledWith, toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "filePath = ...",
      "content = ...",
      "mkdirSpy = ...",
      "writeFileSpy = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "mkdirSpy"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "mkdirSpy.mock.calls.?.?"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "filePath",
        "path": "writeFileSpy"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "path": "mkdirSpy.mock.invocationCallOrder.?"
      }
    ],
    "mocks": [
      "fs",
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve criar backup quando arquivo existe e createBackup=true",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar backup quando arquivo existe e createBackup=true. **Valida√ß√µes**: `copyFileSpy` = `\"filePath\"`, `backupContent` = `\"oldContent\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalledWith, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "oldContent = ...",
      "newContent = ...",
      "copyFileSpy = ...",
      "backupContent = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "filePath",
        "path": "copyFileSpy"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "oldContent",
        "path": "backupContent"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve logar mensagem de backup criado",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue logar mensagem de backup criado. **1 valida√ß√µes** usando: toHaveBeenCalledWith",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "consoleLogSpy"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "n√£o deve criar backup quando createBackup=false",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar backup quando createBackup=false. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "filePath = ...",
      "copyFileSpy = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('n√£o deve criar backup quando createBackup=false...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('n√£o deve criar backup quando createBackup=false...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Side Effects: readFile > deve chamar fs.readFile com encoding utf8",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue chamar fs.readFile com encoding utf8. **Valida√ß√µes**: `readFileSpy` = `\"filePath\"`, `readFileSpy` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalledWith, toHaveBeenCalledTimes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "content = ...",
      "readFileSpy = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "filePath",
        "path": "readFileSpy"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledTimes",
        "value": 1,
        "path": "readFileSpy"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Side Effects: readFile > deve propagar erro quando arquivo n√£o existe",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue propagar erro quando arquivo n√£o existe. **Valida√ß√µes**: `readFileSpy` = `\"nonExistentFile\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nonExistentFile = ...",
      "readFileSpy = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "nonExistentFile",
        "path": "readFileSpy"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve chamar fs.readFile com encoding utf8",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue chamar fs.readFile com encoding utf8. **Valida√ß√µes**: `readFileSpy` = `\"filePath\"`, `readFileSpy` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalledWith, toHaveBeenCalledTimes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "filePath = ...",
      "content = ...",
      "readFileSpy = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "filePath",
        "path": "readFileSpy"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledTimes",
        "value": 1,
        "path": "readFileSpy"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve propagar erro quando arquivo n√£o existe",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue propagar erro quando arquivo n√£o existe. **Valida√ß√µes**: `readFileSpy` = `\"nonExistentFile\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nonExistentFile = ...",
      "readFileSpy = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "nonExistentFile",
        "path": "readFileSpy"
      }
    ],
    "mocks": [
      "fs"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: ensureDir > deve criar diret√≥rio com caracteres especiais no nome",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar diret√≥rio com caracteres especiais no nome. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specialDir = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: ensureDir > deve criar caminho profundamente aninhado",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar caminho profundamente aninhado. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "deepPath = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: ensureDir > deve lidar com diret√≥rio que j√° existe (idempot√™ncia)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lidar com diret√≥rio que j√° existe (idempot√™ncia). **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "existingDir = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Edge Cases: ensureDir > deve lidar com diret√≥rio q...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Edge Cases: ensureDir > deve lidar com diret√≥rio q...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve criar diret√≥rio com caracteres especiais no nome",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar diret√≥rio com caracteres especiais no nome. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specialDir = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve criar caminho profundamente aninhado",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue criar caminho profundamente aninhado. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "deepPath = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve lidar com diret√≥rio que j√° existe (idempot√™ncia)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lidar com diret√≥rio que j√° existe (idempot√™ncia). **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "existingDir = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve lidar com diret√≥rio que j√° existe (idempot√™nc...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve lidar com diret√≥rio que j√° existe (idempot√™nc...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: writeFileSafe > deve escrever arquivo com nome contendo caracteres especiais",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue escrever arquivo com nome contendo caracteres especiais. **Valida√ß√µes**: `written` = `\"content\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specialFile = ...",
      "content = ...",
      "written = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content",
        "path": "written"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: writeFileSafe > deve escrever string vazia sem erro",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue escrever string vazia sem erro. **Valida√ß√µes**: `content` = `\"\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: writeFileSafe > deve escrever conte√∫do muito grande (>1MB)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue escrever conte√∫do muito grande (>1MB). **1 valida√ß√µes** usando: toBe",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "largeContent = ...",
      "written = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "written.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: writeFileSafe > deve lidar com m√∫ltiplas escritas sequenciais (race condition test)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lidar com m√∫ltiplas escritas sequenciais (race condition test). **Valida√ß√µes**: `final` = `\"content-4\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "final = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content-4",
        "path": "final"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: writeFileSafe > deve falhar silenciosamente se backup falhar por falta de permiss√£o",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue falhar silenciosamente se backup falhar por falta de permiss√£o. **2 valida√ß√µes** usando: toHaveBeenCalled, toHaveBeenCalledWith",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalled, toHaveBeenCalledWith. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "copyFileSpy = ...",
      "consoleWarnSpy = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "copyFileSpy"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "consoleWarnSpy"
      }
    ],
    "mocks": [
      "console"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve escrever arquivo com nome contendo caracteres especiais",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue escrever arquivo com nome contendo caracteres especiais. **Valida√ß√µes**: `written` = `\"content\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specialFile = ...",
      "content = ...",
      "written = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content",
        "path": "written"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve escrever string vazia sem erro",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue escrever string vazia sem erro. **Valida√ß√µes**: `content` = `\"\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve escrever conte√∫do muito grande (>1MB)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue escrever conte√∫do muito grande (>1MB). **1 valida√ß√µes** usando: toBe",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "largeContent = ...",
      "written = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "written.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve lidar com m√∫ltiplas escritas sequenciais (race condition test)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lidar com m√∫ltiplas escritas sequenciais (race condition test). **Valida√ß√µes**: `final` = `\"content-4\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "final = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content-4",
        "path": "final"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve falhar silenciosamente se backup falhar por falta de permiss√£o",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue falhar silenciosamente se backup falhar por falta de permiss√£o. **2 valida√ß√µes** usando: toHaveBeenCalled, toHaveBeenCalledWith",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalled, toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "copyFileSpy = ...",
      "consoleWarnSpy = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "copyFileSpy"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "consoleWarnSpy"
      }
    ],
    "mocks": [
      "console"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: readFile > deve ler arquivo com diferentes encodings",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ler arquivo com diferentes encodings. **Valida√ß√µes**: `utf8Content` = `\"content\"`, `unknown` = `\"string\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "content = ...",
      "utf8Content = ...",
      "latin1Content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content",
        "path": "utf8Content"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: readFile > deve lan√ßar erro para arquivo n√£o existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lan√ßar erro para arquivo n√£o existente. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "nonExistent = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Edge Cases: readFile > deve lan√ßar erro para arqui...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Edge Cases: readFile > deve lan√ßar erro para arqui...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: readFile > deve ler arquivo vazio",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ler arquivo vazio. **Valida√ß√µes**: `content` = `\"\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve ler arquivo com diferentes encodings",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ler arquivo com diferentes encodings. **Valida√ß√µes**: `utf8Content` = `\"content\"`, `unknown` = `\"string\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "content = ...",
      "utf8Content = ...",
      "latin1Content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "content",
        "path": "utf8Content"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve lan√ßar erro para arquivo n√£o existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lan√ßar erro para arquivo n√£o existente. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "nonExistent = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve lan√ßar erro para arquivo n√£o existente...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve lan√ßar erro para arquivo n√£o existente...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve ler arquivo vazio",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ler arquivo vazio. **Valida√ß√µes**: `content` = `\"\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: fileExists > deve retornar false para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar false para arquivo inexistente. **Valida√ß√µes**: `exists` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nonExistent = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: fileExists > deve retornar true para arquivo existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar true para arquivo existente. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: fileExists > deve retornar true para diret√≥rio existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar true para diret√≥rio existente. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "dir = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: fileExists > deve retornar false para caminho vazio",
    "testType": "unit",
    "functionUnderTest": "fileExists",
    "whatItTests": "Valida que **`fileExists`** consegue retornar false para caminho vazio. **Valida√ß√µes**: `exists` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "exists = ..."
    ],
    "when": "fileExists",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve retornar false para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar false para arquivo inexistente. **Valida√ß√µes**: `exists` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nonExistent = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve retornar true para arquivo existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar true para arquivo existente. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve retornar true para diret√≥rio existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar true para diret√≥rio existente. **Valida√ß√µes**: `exists` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "dir = ...",
      "exists = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve retornar false para caminho vazio",
    "testType": "unit",
    "functionUnderTest": "fileExists",
    "whatItTests": "Valida que **`fileExists`** consegue retornar false para caminho vazio. **Valida√ß√µes**: `exists` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "exists = ..."
    ],
    "when": "fileExists",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: readDir > deve retornar array vazio para diret√≥rio inexistente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar array vazio para diret√≥rio inexistente. **Valida√ß√µes**: `files` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nonExistent = ...",
      "files = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: readDir > deve retornar array vazio para diret√≥rio vazio",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar array vazio para diret√≥rio vazio. **Valida√ß√µes**: `files` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "emptyDir = ...",
      "files = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: readDir > deve listar todos os arquivos em diret√≥rio populado",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue listar todos os arquivos em diret√≥rio populado. **Valida√ß√µes**: `files` = `3`, `files` = `\"file1.txt\"`, `files` = `\"file2.txt\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toContain. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "files = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "files"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "file1.txt",
        "path": "files"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "file2.txt",
        "path": "files"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "subdir",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "Edge Cases: readDir > deve lidar com caracteres especiais em nomes de arquivos",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com caracteres especiais em nomes de arquivos. **Valida√ß√µes**: `files` = `\"specialName\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specialName = ...",
      "files = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "specialName",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve retornar array vazio para diret√≥rio inexistente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar array vazio para diret√≥rio inexistente. **Valida√ß√µes**: `files` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nonExistent = ...",
      "files = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve retornar array vazio para diret√≥rio vazio",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar array vazio para diret√≥rio vazio. **Valida√ß√µes**: `files` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "emptyDir = ...",
      "files = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve listar todos os arquivos em diret√≥rio populado",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue listar todos os arquivos em diret√≥rio populado. **Valida√ß√µes**: `files` = `3`, `files` = `\"file1.txt\"`, `files` = `\"file2.txt\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "files = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "files"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "file1.txt",
        "path": "files"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "file2.txt",
        "path": "files"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "subdir",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/fs.test.ts",
    "name": "deve lidar com caracteres especiais em nomes de arquivos",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com caracteres especiais em nomes de arquivos. **Valida√ß√µes**: `files` = `\"specialName\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specialName = ...",
      "files = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "specialName",
        "path": "files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - loadMCPSettings > should load settings from /qa/<product>/mcp-settings.json with priority",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue load settings from /qa/<product>/mcp-settings.json with priority. **Valida√ß√µes**: `result` = `\"mockSettings\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toEqual, toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockSettings = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "mockSettings",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "fileExists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - loadMCPSettings > should fall back to root mcp-settings.json if product settings not found",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue fall back to root mcp-settings.json if product settings not found. **Valida√ß√µes**: `result` = `\"mockSettings\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toEqual, toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockSettings = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "mockSettings",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "fileExists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - loadMCPSettings > should return null if no settings file found",
    "testType": "unit",
    "functionUnderTest": "loadMCPSettings",
    "whatItTests": "Valida que **`loadMCPSettings`** consegue return null if no settings file found. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "loadMCPSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - loadMCPSettings > should handle invalid JSON and return null",
    "testType": "unit",
    "functionUnderTest": "loadMCPSettings",
    "whatItTests": "Valida que **`loadMCPSettings`** consegue handle invalid JSON and return null. **2 valida√ß√µes** usando: toBeNull, toHaveBeenCalled",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeNull, toHaveBeenCalled. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "consoleSpy = ...",
      "result = ..."
    ],
    "when": "loadMCPSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      }
    ],
    "mocks": [
      true,
      true,
      "{ invalid json }",
      "{ invalid json }"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - loadMCPSettings > should validate settings with Zod schema and reject invalid data",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue validate settings with Zod schema and reject invalid data. **2 valida√ß√µes** usando: toBeNull, toHaveBeenCalled",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeNull, toHaveBeenCalled. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidSettings = ...",
      "consoleSpy = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - loadMCPSettings > should accept minimal valid settings with defaults",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue accept minimal valid settings with defaults. **Valida√ß√µes**: `result` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "minimalSettings = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should load settings from /qa/<product>/mcp-settings.json with priority",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue load settings from /qa/<product>/mcp-settings.json with priority. **Valida√ß√µes**: `result` = `\"mockSettings\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toEqual, toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockSettings = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "mockSettings",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "fileExists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should fall back to root mcp-settings.json if product settings not found",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue fall back to root mcp-settings.json if product settings not found. **Valida√ß√µes**: `result` = `\"mockSettings\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toEqual, toHaveBeenCalledWith",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockSettings = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "mockSettings",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "fileExists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should return null if no settings file found",
    "testType": "unit",
    "functionUnderTest": "loadMCPSettings",
    "whatItTests": "Valida que **`loadMCPSettings`** consegue return null if no settings file found. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "loadMCPSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should handle invalid JSON and return null",
    "testType": "unit",
    "functionUnderTest": "loadMCPSettings",
    "whatItTests": "Valida que **`loadMCPSettings`** consegue handle invalid JSON and return null. **2 valida√ß√µes** usando: toBeNull, toHaveBeenCalled",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeNull, toHaveBeenCalled. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "consoleSpy = ...",
      "result = ..."
    ],
    "when": "loadMCPSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      }
    ],
    "mocks": [
      true,
      true,
      "{ invalid json }",
      "{ invalid json }"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should validate settings with Zod schema and reject invalid data",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue validate settings with Zod schema and reject invalid data. **2 valida√ß√µes** usando: toBeNull, toHaveBeenCalled",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeNull, toHaveBeenCalled. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidSettings = ...",
      "consoleSpy = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should accept minimal valid settings with defaults",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue accept minimal valid settings with defaults. **Valida√ß√µes**: `result` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "minimalSettings = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - mergeSettings > should return params when fileSettings is null",
    "testType": "unit",
    "functionUnderTest": "mergeSettings",
    "whatItTests": "Valida que **`mergeSettings`** consegue return params when fileSettings is null. **Valida√ß√µes**: `result` = `\"params\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "params = ...",
      "result = ..."
    ],
    "when": "mergeSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "params",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - mergeSettings > should merge fileSettings with params, giving precedence to params",
    "testType": "unit",
    "functionUnderTest": "mergeSettings",
    "whatItTests": "Valida que **`mergeSettings`** consegue merge fileSettings with params, giving precedence to params. **Valida√ß√µes**: `result.product` = `\"ParamProduct\"`, `result.base_url` = `\"https://param.example.com\"`, `result.domains` = `\"[...]\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "fileSettings = ...",
      "params = ...",
      "result = ..."
    ],
    "when": "mergeSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "ParamProduct",
        "path": "result.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://param.example.com",
        "path": "result.base_url"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.domains"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 85,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - mergeSettings > should deep merge targets object",
    "testType": "unit",
    "functionUnderTest": "mergeSettings",
    "whatItTests": "Valida que **`mergeSettings`** consegue deep merge targets object. **Valida√ß√µes**: `result.targets` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "fileSettings = ...",
      "params = ...",
      "result = ..."
    ],
    "when": "mergeSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.targets"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should return params when fileSettings is null",
    "testType": "unit",
    "functionUnderTest": "mergeSettings",
    "whatItTests": "Valida que **`mergeSettings`** consegue return params when fileSettings is null. **Valida√ß√µes**: `result` = `\"params\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "params = ...",
      "result = ..."
    ],
    "when": "mergeSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "params",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should merge fileSettings with params, giving precedence to params",
    "testType": "unit",
    "functionUnderTest": "mergeSettings",
    "whatItTests": "Valida que **`mergeSettings`** consegue merge fileSettings with params, giving precedence to params. **Valida√ß√µes**: `result.product` = `\"ParamProduct\"`, `result.base_url` = `\"https://param.example.com\"`, `result.domains` = `\"[...]\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "fileSettings = ...",
      "params = ...",
      "result = ..."
    ],
    "when": "mergeSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "ParamProduct",
        "path": "result.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://param.example.com",
        "path": "result.base_url"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.domains"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 85,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should deep merge targets object",
    "testType": "unit",
    "functionUnderTest": "mergeSettings",
    "whatItTests": "Valida que **`mergeSettings`** consegue deep merge targets object. **Valida√ß√µes**: `result.targets` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "fileSettings = ...",
      "params = ...",
      "result = ..."
    ],
    "when": "mergeSettings",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.targets"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - createMCPSettingsTemplate > should create directory structure and settings template",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue create directory structure and settings template. **Valida√ß√µes**: `writtenContent` = `\"{...}\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toHaveBeenCalledWith, toHaveBeenCalled, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mkdirSpy = ...",
      "writeFileSpy = ...",
      "result = ...",
      "writtenContent = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "mkdirSpy"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "writeFileSpy"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "writtenContent"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - createMCPSettingsTemplate > should not overwrite existing settings file",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue not overwrite existing settings file. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "writeFileSpy = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [],
    "mocks": [
      true,
      true,
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('config.ts - createMCPSettingsTemplate > should not...', () => {\n  const result = createMCPSettingsTemplate(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('config.ts - createMCPSettingsTemplate > should not...', () => {\n  const result = createMCPSettingsTemplate(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - createMCPSettingsTemplate > should use generic localhost environments (agn√≥stico)",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue use generic localhost environments (agn√≥stico). **Valida√ß√µes**: `writtenContent.environments` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "writeFileSpy = ...",
      "writtenContent = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "writtenContent.environments"
      }
    ],
    "mocks": [
      "undefined",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should create directory structure and settings template",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue create directory structure and settings template. **Valida√ß√µes**: `writtenContent` = `\"{...}\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toHaveBeenCalledWith, toHaveBeenCalled, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mkdirSpy = ...",
      "writeFileSpy = ...",
      "result = ...",
      "writtenContent = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "result"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "mkdirSpy"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "writeFileSpy"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "writtenContent"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should not overwrite existing settings file",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue not overwrite existing settings file. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "writeFileSpy = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [],
    "mocks": [
      true,
      true,
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('should not overwrite existing settings file...', () => {\n  const result = createMCPSettingsTemplate(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('should not overwrite existing settings file...', () => {\n  const result = createMCPSettingsTemplate(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should use generic localhost environments (agn√≥stico)",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue use generic localhost environments (agn√≥stico). **Valida√ß√µes**: `writtenContent.environments` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "writeFileSpy = ...",
      "writtenContent = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "writtenContent.environments"
      }
    ],
    "mocks": [
      "undefined",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - MCPSettingsSchema validation > should validate correct schema",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.safeParse",
    "whatItTests": "Valida que **`MCPSettingsSchema.safeParse`** consegue validate correct schema. **Valida√ß√µes**: `result.success` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "validSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.safeParse",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - MCPSettingsSchema validation > should reject invalid product name (empty)",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.safeParse",
    "whatItTests": "Valida que **`MCPSettingsSchema.safeParse`** consegue reject invalid product name (empty). **Valida√ß√µes**: `result.success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.safeParse",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - MCPSettingsSchema validation > should reject invalid base_url",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.safeParse",
    "whatItTests": "Valida que **`MCPSettingsSchema.safeParse`** consegue reject invalid base_url. **Valida√ß√µes**: `result.success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.safeParse",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - MCPSettingsSchema validation > should reject diff_coverage_min out of range",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.safeParse",
    "whatItTests": "Valida que **`MCPSettingsSchema.safeParse`** consegue reject diff_coverage_min out of range. **Valida√ß√µes**: `result.success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.safeParse",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - MCPSettingsSchema validation > should apply default values for optional fields",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.parse",
    "whatItTests": "Valida que **`MCPSettingsSchema.parse`** consegue apply default values for optional fields. **Valida√ß√µes**: `result.domains` = `\"[...]\"`, `result.critical_flows` = `\"[...]\"`, `result.targets` = `\"{...}\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "minimalSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.domains"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.critical_flows"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.targets"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.environments"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.auth"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should validate correct schema",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.safeParse",
    "whatItTests": "Valida que **`MCPSettingsSchema.safeParse`** consegue validate correct schema. **Valida√ß√µes**: `result.success` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "validSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.safeParse",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should reject invalid product name (empty)",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.safeParse",
    "whatItTests": "Valida que **`MCPSettingsSchema.safeParse`** consegue reject invalid product name (empty). **Valida√ß√µes**: `result.success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.safeParse",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should reject invalid base_url",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.safeParse",
    "whatItTests": "Valida que **`MCPSettingsSchema.safeParse`** consegue reject invalid base_url. **Valida√ß√µes**: `result.success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.safeParse",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should reject diff_coverage_min out of range",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.safeParse",
    "whatItTests": "Valida que **`MCPSettingsSchema.safeParse`** consegue reject diff_coverage_min out of range. **Valida√ß√µes**: `result.success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "invalidSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.safeParse",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should apply default values for optional fields",
    "testType": "unit",
    "functionUnderTest": "MCPSettingsSchema.parse",
    "whatItTests": "Valida que **`MCPSettingsSchema.parse`** consegue apply default values for optional fields. **Valida√ß√µes**: `result.domains` = `\"[...]\"`, `result.critical_flows` = `\"[...]\"`, `result.targets` = `\"{...}\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "minimalSettings = ...",
      "result = ..."
    ],
    "when": "MCPSettingsSchema.parse",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.domains"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.critical_flows"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.targets"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.environments"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.auth"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - inferProductFromPackageJson > should infer product name from package.json",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue infer product name from package.json. **Valida√ß√µes**: `result` = `\"company-my-awesome-product\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "company-my-awesome-product",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - inferProductFromPackageJson > should return null when package.json not found",
    "testType": "unit",
    "functionUnderTest": "inferProductFromPackageJson",
    "whatItTests": "Valida que **`inferProductFromPackageJson`** consegue return null when package.json not found. **Valida√ß√µes**: `result` = `\"repo\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "inferProductFromPackageJson",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "repo",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - inferProductFromPackageJson > should handle invalid package.json gracefully",
    "testType": "unit",
    "functionUnderTest": "inferProductFromPackageJson",
    "whatItTests": "Valida que **`inferProductFromPackageJson`** consegue handle invalid package.json gracefully. **Valida√ß√µes**: `result` = `\"repo\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "inferProductFromPackageJson",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "repo",
        "path": "result"
      }
    ],
    "mocks": [
      true,
      true,
      "invalid json {{{",
      "invalid json {{{"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should infer product name from package.json",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue infer product name from package.json. **Valida√ß√µes**: `result` = `\"company-my-awesome-product\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "company-my-awesome-product",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should return null when package.json not found",
    "testType": "unit",
    "functionUnderTest": "inferProductFromPackageJson",
    "whatItTests": "Valida que **`inferProductFromPackageJson`** consegue return null when package.json not found. **Valida√ß√µes**: `result` = `\"repo\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "inferProductFromPackageJson",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "repo",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should handle invalid package.json gracefully",
    "testType": "unit",
    "functionUnderTest": "inferProductFromPackageJson",
    "whatItTests": "Valida que **`inferProductFromPackageJson`** consegue handle invalid package.json gracefully. **Valida√ß√µes**: `result` = `\"repo\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "inferProductFromPackageJson",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "repo",
        "path": "result"
      }
    ],
    "mocks": [
      true,
      true,
      "invalid json {{{",
      "invalid json {{{"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - createMCPSettingsTemplate (agn√≥stico) > should create generic template with localhost defaults",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue create generic template with localhost defaults. **Valida√ß√µes**: `exists` = `true`, `content.product` = `\"TestProduct\"`, `content.base_url` = `\"http://localhost:3000\"` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settingsPath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "TestProduct",
        "path": "content.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "http://localhost:3000",
        "path": "content.base_url"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "content.domains"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "content.critical_flows"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "content.targets.diff_coverage_min"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "http://localhost:3000",
        "path": "content.environments.dev.url"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - createMCPSettingsTemplate (agn√≥stico) > should create mcp-settings.example.json automatically",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue create mcp-settings.example.json automatically. **Valida√ß√µes**: `exists` = `true`, `content.product` = `\"MyProduct\"`, `content.domains` = `\"billing\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "examplePath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MyProduct",
        "path": "content.product"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "billing",
        "path": "content.domains"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "login",
        "path": "content.critical_flows"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "config.ts - createMCPSettingsTemplate (agn√≥stico) > should infer product from package.json when not provided",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue infer product from package.json when not provided. **Valida√ß√µes**: `content.product` = `\"my-cool-app\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "pkgContent = ...",
      "settingsPath = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "my-cool-app",
        "path": "content.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should create generic template with localhost defaults",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue create generic template with localhost defaults. **Valida√ß√µes**: `exists` = `true`, `content.product` = `\"TestProduct\"`, `content.base_url` = `\"http://localhost:3000\"` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settingsPath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "TestProduct",
        "path": "content.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "http://localhost:3000",
        "path": "content.base_url"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "content.domains"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "content.critical_flows"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "content.targets.diff_coverage_min"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "http://localhost:3000",
        "path": "content.environments.dev.url"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should create mcp-settings.example.json automatically",
    "testType": "unit",
    "functionUnderTest": "createMCPSettingsTemplate",
    "whatItTests": "Valida que **`createMCPSettingsTemplate`** consegue create mcp-settings.example.json automatically. **Valida√ß√µes**: `exists` = `true`, `content.product` = `\"MyProduct\"`, `content.domains` = `\"billing\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "examplePath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "createMCPSettingsTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MyProduct",
        "path": "content.product"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "billing",
        "path": "content.domains"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "login",
        "path": "content.critical_flows"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/utils/__tests__/config.test.ts",
    "name": "should infer product from package.json when not provided",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue infer product from package.json when not provided. **Valida√ß√µes**: `content.product` = `\"my-cool-app\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "pkgContent = ...",
      "settingsPath = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "my-cool-app",
        "path": "content.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "validate.ts - Mutation Score Gates > deve PASSAR quando mutation score >= threshold",
    "testType": "unit",
    "functionUnderTest": "mkdirSync",
    "whatItTests": "Valida que **`mkdirSync`** consegue PASSAR quando mutation score >= threshold. **Valida√ß√µes**: `result.passed` = `true`, `result.violations` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mutationReport = ...",
      "options = ...",
      "result = ..."
    ],
    "when": "mkdirSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result.violations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "validate.ts - Mutation Score Gates > deve FALHAR quando mutation score < threshold",
    "testType": "unit",
    "functionUnderTest": "mkdirSync",
    "whatItTests": "Valida que **`mkdirSync`** consegue FALHAR quando mutation score < threshold. **Valida√ß√µes**: `result.passed` = `false`, `result.violations` = `1`, `result.violations.?.gate` = `\"Mutation Score\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mutationReport = ...",
      "options = ...",
      "result = ..."
    ],
    "when": "mkdirSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "result.violations"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Mutation Score",
        "path": "result.violations.?.gate"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 70,
        "path": "result.violations.?.threshold"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.violations.?.actual"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "üìä Mutation Score: 40% (threshold: 70%)",
        "path": "result.violations.?.suggestions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "validate.ts - Mutation Score Gates > deve retornar sugest√µes de corre√ß√£o para mutantes sobreviventes",
    "testType": "unit",
    "functionUnderTest": "mkdirSync",
    "whatItTests": "Valida que **`mkdirSync`** consegue retornar sugest√µes de corre√ß√£o para mutantes sobreviventes. **Valida√ß√µes**: `result.passed` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mutationReport = ...",
      "options = ...",
      "result = ..."
    ],
    "when": "mkdirSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "path": "result.violations.?.suggestions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "validate.ts - Mutation Score Gates > deve FALHAR quando relat√≥rio de muta√ß√£o n√£o existe",
    "testType": "unit",
    "functionUnderTest": "validate",
    "whatItTests": "Valida que **`validate`** consegue FALHAR quando relat√≥rio de muta√ß√£o n√£o existe. **Valida√ß√µes**: `result.passed` = `false`, `result.violations` = `1`, `result.violations.?.message` = `\"Nenhum relat√≥rio de muta√ß√£o encontrado\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "validate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "result.violations"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Nenhum relat√≥rio de muta√ß√£o encontrado",
        "path": "result.violations.?.message"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "1. Instale Stryker: npm install --save-dev @stryker-mutator/core @stryker-mutator/vitest-runner",
        "path": "result.violations.?.suggestions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "validate.ts - Mutation Score Gates > deve lidar com relat√≥rio JSON malformado",
    "testType": "unit",
    "functionUnderTest": "mkdirSync",
    "whatItTests": "Valida que **`mkdirSync`** consegue lidar com relat√≥rio JSON malformado. **Valida√ß√µes**: `result.passed` = `false`, `result.violations` = `1`, `result.violations.?.message` = `\"Erro ao ler relat√≥rio de muta√ß√£o\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "mkdirSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "result.violations"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Erro ao ler relat√≥rio de muta√ß√£o",
        "path": "result.violations.?.message"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "validate.ts - Mutation Score Gates > deve ignorar minMutation se n√£o fornecido",
    "testType": "unit",
    "functionUnderTest": "validate",
    "whatItTests": "Valida que **`validate`** consegue ignorar minMutation se n√£o fornecido. **Valida√ß√µes**: `result.passed` = `true`, `result.violations` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "validate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result.violations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "deve PASSAR quando mutation score >= threshold",
    "testType": "unit",
    "functionUnderTest": "mkdirSync",
    "whatItTests": "Valida que **`mkdirSync`** consegue PASSAR quando mutation score >= threshold. **Valida√ß√µes**: `result.passed` = `true`, `result.violations` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mutationReport = ...",
      "options = ...",
      "result = ..."
    ],
    "when": "mkdirSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result.violations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "deve FALHAR quando mutation score < threshold",
    "testType": "unit",
    "functionUnderTest": "mkdirSync",
    "whatItTests": "Valida que **`mkdirSync`** consegue FALHAR quando mutation score < threshold. **Valida√ß√µes**: `result.passed` = `false`, `result.violations` = `1`, `result.violations.?.gate` = `\"Mutation Score\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mutationReport = ...",
      "options = ...",
      "result = ..."
    ],
    "when": "mkdirSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "result.violations"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Mutation Score",
        "path": "result.violations.?.gate"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 70,
        "path": "result.violations.?.threshold"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.violations.?.actual"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "üìä Mutation Score: 40% (threshold: 70%)",
        "path": "result.violations.?.suggestions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "deve retornar sugest√µes de corre√ß√£o para mutantes sobreviventes",
    "testType": "unit",
    "functionUnderTest": "mkdirSync",
    "whatItTests": "Valida que **`mkdirSync`** consegue retornar sugest√µes de corre√ß√£o para mutantes sobreviventes. **Valida√ß√µes**: `result.passed` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mutationReport = ...",
      "options = ...",
      "result = ..."
    ],
    "when": "mkdirSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "path": "result.violations.?.suggestions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "deve FALHAR quando relat√≥rio de muta√ß√£o n√£o existe",
    "testType": "unit",
    "functionUnderTest": "validate",
    "whatItTests": "Valida que **`validate`** consegue FALHAR quando relat√≥rio de muta√ß√£o n√£o existe. **Valida√ß√µes**: `result.passed` = `false`, `result.violations` = `1`, `result.violations.?.message` = `\"Nenhum relat√≥rio de muta√ß√£o encontrado\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "validate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "result.violations"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Nenhum relat√≥rio de muta√ß√£o encontrado",
        "path": "result.violations.?.message"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "1. Instale Stryker: npm install --save-dev @stryker-mutator/core @stryker-mutator/vitest-runner",
        "path": "result.violations.?.suggestions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "deve lidar com relat√≥rio JSON malformado",
    "testType": "unit",
    "functionUnderTest": "mkdirSync",
    "whatItTests": "Valida que **`mkdirSync`** consegue lidar com relat√≥rio JSON malformado. **Valida√ß√µes**: `result.passed` = `false`, `result.violations` = `1`, `result.violations.?.message` = `\"Erro ao ler relat√≥rio de muta√ß√£o\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "mkdirSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "result.violations"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Erro ao ler relat√≥rio de muta√ß√£o",
        "path": "result.violations.?.message"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/validate.test.ts",
    "name": "deve ignorar minMutation se n√£o fornecido",
    "testType": "unit",
    "functionUnderTest": "validate",
    "whatItTests": "Valida que **`validate`** consegue ignorar minMutation se n√£o fornecido. **Valida√ß√µes**: `result.passed` = `true`, `result.violations` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "validate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result.violations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/suite-health.test.ts",
    "name": "suiteHealth > deve medir sa√∫de b√°sica da su√≠te",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue medir sa√∫de b√°sica da su√≠te. **Valida√ß√µes**: `result.ok` = `true`, `result.total_runtime_sec` = `0`, `result.flaky_tests_count` = `0` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "qaDir = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.total_runtime_sec"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.flaky_tests_count"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.instability_index"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "result.instability_index"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/suite-health.test.ts",
    "name": "suiteHealth > deve calcular instability index",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue calcular instability index. **Valida√ß√µes**: `unknown` = `\"number\"`, `result.instability_index` = `0`, `result.instability_index` = `1`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "qaDir = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.instability_index"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "number",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.instability_index"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "result.instability_index"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/suite-health.test.ts",
    "name": "suiteHealth > deve gerar recomenda√ß√µes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue gerar recomenda√ß√µes. **Valida√ß√µes**: `Array.isArray()` = `true`, `result.recommendations.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "qaDir = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/suite-health.test.ts",
    "name": "suiteHealth > deve salvar relat√≥rio em JSON",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue salvar relat√≥rio em JSON. **Valida√ß√µes**: `result.output` = `\"suite-health.json\"`, `exists` = `true`, `content` = `\"timestamp\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain, toBe, toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "qaDir = ...",
      "result = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "suite-health.json",
        "path": "result.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "timestamp",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "total_runtime_sec",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "instability_index",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "recommendations",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/suite-health.test.ts",
    "name": "deve medir sa√∫de b√°sica da su√≠te",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue medir sa√∫de b√°sica da su√≠te. **Valida√ß√µes**: `result.ok` = `true`, `result.total_runtime_sec` = `0`, `result.flaky_tests_count` = `0` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "qaDir = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.total_runtime_sec"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.flaky_tests_count"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.instability_index"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "result.instability_index"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/suite-health.test.ts",
    "name": "deve calcular instability index",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue calcular instability index. **Valida√ß√µes**: `unknown` = `\"number\"`, `result.instability_index` = `0`, `result.instability_index` = `1`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "qaDir = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.instability_index"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "number",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.instability_index"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "result.instability_index"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/suite-health.test.ts",
    "name": "deve gerar recomenda√ß√µes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue gerar recomenda√ß√µes. **Valida√ß√µes**: `Array.isArray()` = `true`, `result.recommendations.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "qaDir = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/suite-health.test.ts",
    "name": "deve salvar relat√≥rio em JSON",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue salvar relat√≥rio em JSON. **Valida√ß√µes**: `result.output` = `\"suite-health.json\"`, `exists` = `true`, `content` = `\"timestamp\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain, toBe, toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "qaDir = ...",
      "result = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "suite-health.json",
        "path": "result.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "timestamp",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "total_runtime_sec",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "instability_index",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "recommendations",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/slo-canary-check.test.ts",
    "name": "deve retornar ok=true quando todos os SLOs s√£o atendidos",
    "testType": "unit",
    "functionUnderTest": "sloCanaryCheck",
    "whatItTests": "Valida que **`sloCanaryCheck`** consegue retornar ok=true quando todos os SLOs s√£o atendidos. **Valida√ß√µes**: `result.summary.total_cujs` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "sloCanaryCheck",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.summary"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.summary.total_cujs"
      }
    ],
    "mocks": [
      true,
      true,
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/slo-canary-check.test.ts",
    "name": "deve detectar viola√ß√µes de SLOs",
    "testType": "unit",
    "functionUnderTest": "sloCanaryCheck",
    "whatItTests": "Valida que **`sloCanaryCheck`** consegue detectar viola√ß√µes de SLOs. **2 valida√ß√µes** usando: toBeDefined, toBeDefined",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "sloCanaryCheck",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.violations"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      }
    ],
    "mocks": [
      true,
      true,
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/slo-canary-check.test.ts",
    "name": "deve gerar recomenda√ß√µes quando h√° viola√ß√µes",
    "testType": "unit",
    "functionUnderTest": "sloCanaryCheck",
    "whatItTests": "Valida que **`sloCanaryCheck`** consegue gerar recomenda√ß√µes quando h√° viola√ß√µes. **Valida√ß√µes**: `Array.isArray()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "sloCanaryCheck",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [
      true,
      true,
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve criar diret√≥rios de testes",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue criar diret√≥rios de testes. **Valida√ß√µes**: `result.ok` = `true`, `authExists` = `true`, `claimExists` = `true` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "authExists = ...",
      "claimExists = ...",
      "searchExists = ...",
      "fixturesExists = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "authExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "claimExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "searchExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "fixturesExists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve gerar playwright.config.ts",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue gerar playwright.config.ts. **Valida√ß√µes**: `result.ok` = `true`, `configExists` = `true`, `configContent` = `\"defineConfig\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "configPath = ...",
      "configExists = ...",
      "configContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "configExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "defineConfig",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "timeout",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "baseURL",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve criar fixture de autentica√ß√£o",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue criar fixture de autentica√ß√£o. **Valida√ß√µes**: `result.ok` = `true`, `fixtureExists` = `true`, `fixtureContent` = `\"base\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "fixturePath = ...",
      "fixtureExists = ...",
      "fixtureContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "fixtureExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "base",
        "path": "fixtureContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "deprecated",
        "path": "fixtureContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve gerar spec de login",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue gerar spec de login. **Valida√ß√µes**: `result.ok` = `true`, `loginExists` = `true`, `loginContent` = `\"test\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "loginPath = ...",
      "loginExists = ...",
      "loginContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "loginExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test",
        "path": "loginContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "login",
        "path": "loginContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Email",
        "path": "loginContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Senha",
        "path": "loginContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve gerar spec de reclama√ß√£o",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue gerar spec de reclama√ß√£o. **Valida√ß√µes**: `result.ok` = `true`, `claimExists` = `true`, `claimContent` = `\"test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "claimPath = ...",
      "claimExists = ...",
      "claimContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "claimExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test",
        "path": "claimContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reclama√ß√£o",
        "path": "claimContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve gerar spec de busca",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue gerar spec de busca. **Valida√ß√µes**: `result.ok` = `true`, `searchExists` = `true`, `searchContent` = `\"test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "searchPath = ...",
      "searchExists = ...",
      "searchContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "searchExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test",
        "path": "searchContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "buscar empresa",
        "path": "searchContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve retornar caminho do diret√≥rio E2E",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue retornar caminho do diret√≥rio E2E. **Valida√ß√µes**: `result.ok` = `true`, `result.e2e_dir` = `\"e2e\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "e2e",
        "path": "result.e2e_dir"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve configurar reporters no playwright.config.ts",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue configurar reporters no playwright.config.ts. **Valida√ß√µes**: `result.ok` = `true`, `configContent` = `\"reporter\"`, `configContent` = `\"html\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "configContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reporter",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "html",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "junit",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "json",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve configurar retry e timeout no playwright.config.ts",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue configurar retry e timeout no playwright.config.ts. **Valida√ß√µes**: `result.ok` = `true`, `configContent` = `\"retries\"`, `configContent` = `\"timeout\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "configContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "retries",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "timeout",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "scaffoldPlaywright > deve configurar trace e screenshot no playwright.config.ts",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue configurar trace e screenshot no playwright.config.ts. **Valida√ß√µes**: `result.ok` = `true`, `configContent` = `\"trace\"`, `configContent` = `\"screenshot\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "configContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "trace",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "screenshot",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "video",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve criar diret√≥rios de testes",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue criar diret√≥rios de testes. **Valida√ß√µes**: `result.ok` = `true`, `authExists` = `true`, `claimExists` = `true` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "authExists = ...",
      "claimExists = ...",
      "searchExists = ...",
      "fixturesExists = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "authExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "claimExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "searchExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "fixturesExists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve gerar playwright.config.ts",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue gerar playwright.config.ts. **Valida√ß√µes**: `result.ok` = `true`, `configExists` = `true`, `configContent` = `\"defineConfig\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "configPath = ...",
      "configExists = ...",
      "configContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "configExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "defineConfig",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "timeout",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "baseURL",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve criar fixture de autentica√ß√£o",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue criar fixture de autentica√ß√£o. **Valida√ß√µes**: `result.ok` = `true`, `fixtureExists` = `true`, `fixtureContent` = `\"base\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "fixturePath = ...",
      "fixtureExists = ...",
      "fixtureContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "fixtureExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "base",
        "path": "fixtureContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "deprecated",
        "path": "fixtureContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve gerar spec de login",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue gerar spec de login. **Valida√ß√µes**: `result.ok` = `true`, `loginExists` = `true`, `loginContent` = `\"test\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "loginPath = ...",
      "loginExists = ...",
      "loginContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "loginExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test",
        "path": "loginContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "login",
        "path": "loginContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Email",
        "path": "loginContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Senha",
        "path": "loginContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve gerar spec de reclama√ß√£o",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue gerar spec de reclama√ß√£o. **Valida√ß√µes**: `result.ok` = `true`, `claimExists` = `true`, `claimContent` = `\"test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "claimPath = ...",
      "claimExists = ...",
      "claimContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "claimExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test",
        "path": "claimContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reclama√ß√£o",
        "path": "claimContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve gerar spec de busca",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue gerar spec de busca. **Valida√ß√µes**: `result.ok` = `true`, `searchExists` = `true`, `searchContent` = `\"test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "searchPath = ...",
      "searchExists = ...",
      "searchContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "searchExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test",
        "path": "searchContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "buscar empresa",
        "path": "searchContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve retornar caminho do diret√≥rio E2E",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue retornar caminho do diret√≥rio E2E. **Valida√ß√µes**: `result.ok` = `true`, `result.e2e_dir` = `\"e2e\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "e2e",
        "path": "result.e2e_dir"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve configurar reporters no playwright.config.ts",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue configurar reporters no playwright.config.ts. **Valida√ß√µes**: `result.ok` = `true`, `configContent` = `\"reporter\"`, `configContent` = `\"html\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "configContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reporter",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "html",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "junit",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "json",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve configurar retry e timeout no playwright.config.ts",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue configurar retry e timeout no playwright.config.ts. **Valida√ß√µes**: `result.ok` = `true`, `configContent` = `\"retries\"`, `configContent` = `\"timeout\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "configContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "retries",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "timeout",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold.test.ts",
    "name": "deve configurar trace e screenshot no playwright.config.ts",
    "testType": "unit",
    "functionUnderTest": "scaffoldPlaywright",
    "whatItTests": "Valida que **`scaffoldPlaywright`** consegue configurar trace e screenshot no playwright.config.ts. **Valida√ß√µes**: `result.ok` = `true`, `configContent` = `\"trace\"`, `configContent` = `\"screenshot\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "configContent = ..."
    ],
    "when": "scaffoldPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "trace",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "screenshot",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "video",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve detectar framework Vitest",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar framework Vitest. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve detectar framework Jest",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar framework Jest. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve detectar framework Mocha",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar framework Mocha. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"mocha\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mocha",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve gerar testes para m√∫ltiplos arquivos",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar testes para m√∫ltiplos arquivos. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve limitar a 20 arquivos por vez",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue limitar a 20 arquivos por vez. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `20`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "files = ...",
      "fileName = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 20,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve atualizar package.json com scripts de teste",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue atualizar package.json com scripts de teste. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "packageJson = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "packageJson.scripts.test"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve gerar guia de testes unit√°rios",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar guia de testes unit√°rios. **Valida√ß√µes**: `result.ok` = `true`, `exists` = `true`, `content` = `\"Unit Testing\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "guidePath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Unit Testing",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve lidar com erro quando arquivo fonte n√£o existe",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com erro quando arquivo fonte n√£o existe. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "scaffoldUnitTests > deve auto-detectar arquivos quando n√£o especificados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue auto-detectar arquivos quando n√£o especificados. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeGreaterThan. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve detectar framework Vitest",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar framework Vitest. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve detectar framework Jest",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar framework Jest. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve detectar framework Mocha",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar framework Mocha. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"mocha\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mocha",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve gerar testes para m√∫ltiplos arquivos",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar testes para m√∫ltiplos arquivos. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve limitar a 20 arquivos por vez",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue limitar a 20 arquivos por vez. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `20`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "files = ...",
      "fileName = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 20,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve atualizar package.json com scripts de teste",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue atualizar package.json com scripts de teste. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "packageJson = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "packageJson.scripts.test"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve gerar guia de testes unit√°rios",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar guia de testes unit√°rios. **Valida√ß√µes**: `result.ok` = `true`, `exists` = `true`, `content` = `\"Unit Testing\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "guidePath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Unit Testing",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve lidar com erro quando arquivo fonte n√£o existe",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com erro quando arquivo fonte n√£o existe. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-unit.test.ts",
    "name": "deve auto-detectar arquivos quando n√£o especificados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue auto-detectar arquivos quando n√£o especificados. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeGreaterThan. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-integration.test.ts",
    "name": "scaffoldIntegrationTests > deve lidar com base_url inv√°lida",
    "testType": "unit",
    "functionUnderTest": ".rejects.toThrow",
    "whatItTests": "Valida que **`.rejects.toThrow`** consegue lidar com base_url inv√°lida. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".rejects.toThrow",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('scaffoldIntegrationTests > deve lidar com base_url...', () => {\n  const result = .rejects.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('scaffoldIntegrationTests > deve lidar com base_url...', () => {\n  const result = .rejects.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-integration.test.ts",
    "name": "scaffoldIntegrationTests > deve lidar com endpoints vazios",
    "testType": "unit",
    "functionUnderTest": "scaffoldIntegrationTests",
    "whatItTests": "Valida que **`scaffoldIntegrationTests`** consegue lidar com endpoints vazios. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldIntegrationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-integration.test.ts",
    "name": "deve lidar com base_url inv√°lida",
    "testType": "unit",
    "functionUnderTest": ".rejects.toThrow",
    "whatItTests": "Valida que **`.rejects.toThrow`** consegue lidar com base_url inv√°lida. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".rejects.toThrow",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve lidar com base_url inv√°lida...', () => {\n  const result = .rejects.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve lidar com base_url inv√°lida...', () => {\n  const result = .rejects.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-integration.test.ts",
    "name": "deve lidar com endpoints vazios",
    "testType": "unit",
    "functionUnderTest": "scaffoldIntegrationTests",
    "whatItTests": "Valida que **`scaffoldIntegrationTests`** consegue lidar com endpoints vazios. **Valida√ß√µes**: `result.ok` = `true`, `result.generated.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldIntegrationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.generated.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve retornar erro se nenhum servi√ßo for detectado",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue retornar erro se nenhum servi√ßo for detectado. **Valida√ß√µes**: `result.ok` = `false`, `result.message` = `\"No services or integrations detected\"`, `result.total_contracts` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "No services or integrations detected",
        "path": "result.message"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total_contracts"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve gerar contratos quando endpoints s√£o detectados",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar contratos quando endpoints s√£o detectados. **Valida√ß√µes**: `result.ok` = `true`, `result.total_contracts` = `0`",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeGreaterThan, toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_contracts"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.consumer_tests"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.provider_tests"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.catalog_path"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.config_path"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve gerar config TypeScript para projeto TypeScript",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar config TypeScript para projeto TypeScript. **Valida√ß√µes**: `result.config_path` = `\"pact.config.ts\"`, `configCalls.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "configCalls = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "pact.config.ts",
        "path": "result.config_path"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "configCalls.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve gerar consumer tests para cada contrato",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar consumer tests para cada contrato. **Valida√ß√µes**: `unknown.length` = `0`, `.some()` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.consumer_tests"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": ".some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve gerar provider tests",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar provider tests. **Valida√ß√µes**: `unknown.length` = `0`, `.some()` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.provider_tests"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": ".some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve incluir broker_url no config se fornecido",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue incluir broker_url no config se fornecido. **Valida√ß√µes**: `configContent` = `\"brokerUrl\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "brokerUrl = ...",
      "result = ...",
      "configContent = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "brokerUrl",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve gerar recomenda√ß√µes apropriadas",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar recomenda√ß√µes apropriadas. **Valida√ß√µes**: `result.recommendations.length` = `0`, `result.recommendations.some()` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.recommendations.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve detectar Python e gerar config Python",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue detectar Python e gerar config Python. **Valida√ß√µes**: `result.config_path` = `\"pact_config.py\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "pact_config.py",
        "path": "result.config_path"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "scaffold-contracts-pact > deve salvar catalog de contratos",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue salvar catalog de contratos. **Valida√ß√µes**: `result.catalog_path` = `\"contract-catalog.json\"`, `catalogCalls.length` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalogCalls = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.catalog_path"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "contract-catalog.json",
        "path": "result.catalog_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "catalogCalls.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve retornar erro se nenhum servi√ßo for detectado",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue retornar erro se nenhum servi√ßo for detectado. **Valida√ß√µes**: `result.ok` = `false`, `result.message` = `\"No services or integrations detected\"`, `result.total_contracts` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "No services or integrations detected",
        "path": "result.message"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total_contracts"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve gerar contratos quando endpoints s√£o detectados",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar contratos quando endpoints s√£o detectados. **Valida√ß√µes**: `result.ok` = `true`, `result.total_contracts` = `0`",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeGreaterThan, toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_contracts"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.consumer_tests"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.provider_tests"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.catalog_path"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.config_path"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve gerar config TypeScript para projeto TypeScript",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar config TypeScript para projeto TypeScript. **Valida√ß√µes**: `result.config_path` = `\"pact.config.ts\"`, `configCalls.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "configCalls = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "pact.config.ts",
        "path": "result.config_path"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "configCalls.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve gerar consumer tests para cada contrato",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar consumer tests para cada contrato. **Valida√ß√µes**: `unknown.length` = `0`, `.some()` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.consumer_tests"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": ".some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve gerar provider tests",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar provider tests. **Valida√ß√µes**: `unknown.length` = `0`, `.some()` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.provider_tests"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": ".some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve incluir broker_url no config se fornecido",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue incluir broker_url no config se fornecido. **Valida√ß√µes**: `configContent` = `\"brokerUrl\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "brokerUrl = ...",
      "result = ...",
      "configContent = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "brokerUrl",
        "path": "configContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve gerar recomenda√ß√µes apropriadas",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue gerar recomenda√ß√µes apropriadas. **Valida√ß√µes**: `result.recommendations.length` = `0`, `result.recommendations.some()` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.recommendations.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve detectar Python e gerar config Python",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue detectar Python e gerar config Python. **Valida√ß√µes**: `result.config_path` = `\"pact_config.py\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "pact_config.py",
        "path": "result.config_path"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/scaffold-contracts-pact.test.ts",
    "name": "deve salvar catalog de contratos",
    "testType": "unit",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue salvar catalog de contratos. **Valida√ß√µes**: `result.catalog_path` = `\"contract-catalog.json\"`, `catalogCalls.length` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalogCalls = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.catalog_path"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "contract-catalog.json",
        "path": "result.catalog_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "catalogCalls.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "runPlaywright > deve executar testes Playwright com todas as op√ß√µes",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue executar testes Playwright com todas as op√ß√µes. **Valida√ß√µes**: `result.ok` = `true`, `result.reports.html` = `\"reports/html\"`, `result.reports.json` = `\"reports/json\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.reports"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/html",
        "path": "result.reports.html"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/json",
        "path": "result.reports.json"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/junit",
        "path": "result.reports.junit"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "runPlaywright > deve configurar vari√°veis de ambiente",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue configurar vari√°veis de ambiente. **Valida√ß√µes**: `capturedEnv.E2E_BASE_URL` = `\"https://test.com\"`, `capturedEnv.E2E_USER` = `\"testuser\"`, `capturedEnv.E2E_PASS` = `\"testpass\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "capturedEnv = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://test.com",
        "path": "capturedEnv.E2E_BASE_URL"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "testuser",
        "path": "capturedEnv.E2E_USER"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "testpass",
        "path": "capturedEnv.E2E_PASS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "runPlaywright > deve usar valores padr√£o para env quando n√£o especificados",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue usar valores padr√£o para env quando n√£o especificados. **3 valida√ß√µes** usando: toBeDefined, toBeDefined, toBeDefined",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "capturedEnv = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "capturedEnv.E2E_BASE_URL"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "capturedEnv.E2E_USER"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "capturedEnv.E2E_PASS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "runPlaywright > deve configurar modo headless",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue configurar modo headless. **Valida√ß√µes**: `capturedEnv.HEADLESS` = `\"1\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "capturedEnv = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "1",
        "path": "capturedEnv.HEADLESS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "runPlaywright > deve configurar modo headed",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue configurar modo headed. **Valida√ß√µes**: `capturedEnv.HEADLESS` = `\"0\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "capturedEnv = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "0",
        "path": "capturedEnv.HEADLESS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "runPlaywright > deve retornar caminhos dos relat√≥rios",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue retornar caminhos dos relat√≥rios. **Valida√ß√µes**: `result.ok` = `true`, `result.reports.html` = `\"reports/html\"`, `result.reports.junit` = `\"reports/junit/results.xml\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.reports"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/html",
        "path": "result.reports.html"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/junit/results.xml",
        "path": "result.reports.junit"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/json/results.json",
        "path": "result.reports.json"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "runPlaywright > deve lidar com erro ao instalar Playwright",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue lidar com erro ao instalar Playwright. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "runPlaywright > deve lidar com erro ao executar testes",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue lidar com erro ao executar testes. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "callCount = ...",
      "result = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "deve executar testes Playwright com todas as op√ß√µes",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue executar testes Playwright com todas as op√ß√µes. **Valida√ß√µes**: `result.ok` = `true`, `result.reports.html` = `\"reports/html\"`, `result.reports.json` = `\"reports/json\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.reports"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/html",
        "path": "result.reports.html"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/json",
        "path": "result.reports.json"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/junit",
        "path": "result.reports.junit"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "deve configurar vari√°veis de ambiente",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue configurar vari√°veis de ambiente. **Valida√ß√µes**: `capturedEnv.E2E_BASE_URL` = `\"https://test.com\"`, `capturedEnv.E2E_USER` = `\"testuser\"`, `capturedEnv.E2E_PASS` = `\"testpass\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "capturedEnv = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://test.com",
        "path": "capturedEnv.E2E_BASE_URL"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "testuser",
        "path": "capturedEnv.E2E_USER"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "testpass",
        "path": "capturedEnv.E2E_PASS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "deve usar valores padr√£o para env quando n√£o especificados",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue usar valores padr√£o para env quando n√£o especificados. **3 valida√ß√µes** usando: toBeDefined, toBeDefined, toBeDefined",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "capturedEnv = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "capturedEnv.E2E_BASE_URL"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "capturedEnv.E2E_USER"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "capturedEnv.E2E_PASS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "deve configurar modo headless",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue configurar modo headless. **Valida√ß√µes**: `capturedEnv.HEADLESS` = `\"1\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "capturedEnv = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "1",
        "path": "capturedEnv.HEADLESS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "deve configurar modo headed",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue configurar modo headed. **Valida√ß√µes**: `capturedEnv.HEADLESS` = `\"0\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "capturedEnv = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "0",
        "path": "capturedEnv.HEADLESS"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "deve retornar caminhos dos relat√≥rios",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue retornar caminhos dos relat√≥rios. **Valida√ß√µes**: `result.ok` = `true`, `result.reports.html` = `\"reports/html\"`, `result.reports.junit` = `\"reports/junit/results.xml\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.reports"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/html",
        "path": "result.reports.html"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/junit/results.xml",
        "path": "result.reports.junit"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "reports/json/results.json",
        "path": "result.reports.json"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "deve lidar com erro ao instalar Playwright",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue lidar com erro ao instalar Playwright. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run.test.ts",
    "name": "deve lidar com erro ao executar testes",
    "testType": "unit",
    "functionUnderTest": "runPlaywright",
    "whatItTests": "Valida que **`runPlaywright`** consegue lidar com erro ao executar testes. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "callCount = ...",
      "result = ..."
    ],
    "when": "runPlaywright",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-mutation-tests.test.ts",
    "name": "runMutationTests > deve executar mutation tests com sucesso",
    "testType": "unit",
    "functionUnderTest": "runMutationTests",
    "whatItTests": "Valida que **`runMutationTests`** consegue executar mutation tests com sucesso. **Valida√ß√µes**: `result.ok` = `true`, `result.overallScore` = `0`, `result.passed` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runMutationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.overallScore"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.passed"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-mutation-tests.test.ts",
    "name": "runMutationTests > deve retornar passed=false se score < minScore",
    "testType": "unit",
    "functionUnderTest": "runMutationTests",
    "whatItTests": "Valida que **`runMutationTests`** consegue retornar passed=false se score < minScore. **Valida√ß√µes**: `result.ok` = `false`, `result.passed` = `false`, `result.overallScore` = `30`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runMutationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 30,
        "path": "result.overallScore"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-mutation-tests.test.ts",
    "name": "runMutationTests > deve lidar com erro graciosamente",
    "testType": "unit",
    "functionUnderTest": "runMutationTests",
    "whatItTests": "Valida que **`runMutationTests`** consegue lidar com erro graciosamente. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "runMutationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-mutation-tests.test.ts",
    "name": "deve executar mutation tests com sucesso",
    "testType": "unit",
    "functionUnderTest": "runMutationTests",
    "whatItTests": "Valida que **`runMutationTests`** consegue executar mutation tests com sucesso. **Valida√ß√µes**: `result.ok` = `true`, `result.overallScore` = `0`, `result.passed` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runMutationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.overallScore"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.passed"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-mutation-tests.test.ts",
    "name": "deve retornar passed=false se score < minScore",
    "testType": "unit",
    "functionUnderTest": "runMutationTests",
    "whatItTests": "Valida que **`runMutationTests`** consegue retornar passed=false se score < minScore. **Valida√ß√µes**: `result.ok` = `false`, `result.passed` = `false`, `result.overallScore` = `30`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runMutationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.passed"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 30,
        "path": "result.overallScore"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-mutation-tests.test.ts",
    "name": "deve lidar com erro graciosamente",
    "testType": "unit",
    "functionUnderTest": "runMutationTests",
    "whatItTests": "Valida que **`runMutationTests`** consegue lidar com erro graciosamente. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "runMutationTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-diff-coverage.test.ts",
    "name": "deve retornar 100% quando n√£o h√° mudan√ßas",
    "testType": "unit",
    "functionUnderTest": "runDiffCoverage",
    "whatItTests": "Valida que **`runDiffCoverage`** consegue retornar 100% quando n√£o h√° mudan√ßas. **Valida√ß√µes**: `result.ok` = `true`, `result.diffCoverage` = `100`, `result.linesAdded` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockProcess = ...",
      "mockProcess = ...",
      "result = ..."
    ],
    "when": "runDiffCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.diffCoverage"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.linesAdded"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result.files"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-diff-coverage.test.ts",
    "name": "deve usar configura√ß√£o do mcp-settings.json",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue usar configura√ß√£o do mcp-settings.json. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockProcess = ...",
      "mockProcess = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.ok"
      }
    ],
    "mocks": [
      true,
      true,
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve executar cobertura e analisar resultados com status excellent",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue executar cobertura e analisar resultados com status excellent. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `85`, `result.analysis.status` = `\"excellent\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 85,
        "path": "result.summary.lines.pct"
      },
      {
        "type": "status",
        "matcher": "toBe",
        "value": "excellent",
        "path": "result.analysis.status"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.analysis.meetsThresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve identificar gaps quando cobertura baixa (critical)",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue identificar gaps quando cobertura baixa (critical). **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.status` = `\"critical\"`, `result.analysis.meetsThresholds` = `false` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "status",
        "matcher": "toBe",
        "value": "critical",
        "path": "result.analysis.status"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.analysis.meetsThresholds"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.analysis.gaps.length"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.analysis.recommendations.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve identificar status good quando cobertura est√° entre 70-80%",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue identificar status good quando cobertura est√° entre 70-80%. **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.status` = `\"good\"`, `result.analysis.meetsThresholds` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "status",
        "matcher": "toBe",
        "value": "good",
        "path": "result.analysis.status"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.analysis.meetsThresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve priorizar arquivos com menor cobertura",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue priorizar arquivos com menor cobertura. **Valida√ß√µes**: `result.files.length` = `2`, `result.files.?.path` = `\"file1\"`, `result.files.?.lines` = `10` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.files.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "file1",
        "path": "result.files.?.path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 10,
        "path": "result.files.?.lines"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.analysis.priorities.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "result.analysis.priorities.?.priority"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve gerar relat√≥rio detalhado em Markdown",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar relat√≥rio detalhado em Markdown. **Valida√ß√µes**: `result.reportPath` = `\"COVERAGE-ANALYSIS.md\"`, `reportExists` = `true`, `reportContent` = `\"Relat√≥rio de Cobertura\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toBeDefined, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "reportExists = ...",
      "reportContent = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "COVERAGE-ANALYSIS.md",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "reportExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Relat√≥rio de Cobertura",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "70",
        "path": "reportContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve usar thresholds customizados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue usar thresholds customizados. **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.meetsThresholds` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.analysis.meetsThresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve lidar com arquivo de cobertura inexistente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com arquivo de cobertura inexistente. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve calcular gaps corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular gaps corretamente. **Valida√ß√µes**: `result.ok` = `true`, `linesGap` = `\"200 linhas\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "linesGap = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "linesGap"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "200 linhas",
        "path": "linesGap"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve gerar recomenda√ß√µes espec√≠ficas baseadas nos gaps",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar recomenda√ß√µes espec√≠ficas baseadas nos gaps. **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.recommendations.length` = `0`, `result.analysis.recommendations.some()` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.analysis.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.analysis.recommendations.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "runCoverageAnalysis > deve classificar prioridades corretamente (high, medium, low)",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue classificar prioridades corretamente (high, medium, low). **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.priorities.length` = `3`",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "highPriority = ...",
      "mediumPriority = ...",
      "lowPriority = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.analysis.priorities.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "highPriority"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "mediumPriority"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "lowPriority"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve executar cobertura e analisar resultados com status excellent",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue executar cobertura e analisar resultados com status excellent. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `85`, `result.analysis.status` = `\"excellent\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 85,
        "path": "result.summary.lines.pct"
      },
      {
        "type": "status",
        "matcher": "toBe",
        "value": "excellent",
        "path": "result.analysis.status"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.analysis.meetsThresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve identificar gaps quando cobertura baixa (critical)",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue identificar gaps quando cobertura baixa (critical). **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.status` = `\"critical\"`, `result.analysis.meetsThresholds` = `false` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "status",
        "matcher": "toBe",
        "value": "critical",
        "path": "result.analysis.status"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.analysis.meetsThresholds"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.analysis.gaps.length"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.analysis.recommendations.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve identificar status good quando cobertura est√° entre 70-80%",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue identificar status good quando cobertura est√° entre 70-80%. **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.status` = `\"good\"`, `result.analysis.meetsThresholds` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "status",
        "matcher": "toBe",
        "value": "good",
        "path": "result.analysis.status"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.analysis.meetsThresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve priorizar arquivos com menor cobertura",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue priorizar arquivos com menor cobertura. **Valida√ß√µes**: `result.files.length` = `2`, `result.files.?.path` = `\"file1\"`, `result.files.?.lines` = `10` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.files.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "file1",
        "path": "result.files.?.path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 10,
        "path": "result.files.?.lines"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.analysis.priorities.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "result.analysis.priorities.?.priority"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve gerar relat√≥rio detalhado em Markdown",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar relat√≥rio detalhado em Markdown. **Valida√ß√µes**: `result.reportPath` = `\"COVERAGE-ANALYSIS.md\"`, `reportExists` = `true`, `reportContent` = `\"Relat√≥rio de Cobertura\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toBeDefined, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "reportExists = ...",
      "reportContent = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "COVERAGE-ANALYSIS.md",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "reportExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Relat√≥rio de Cobertura",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "70",
        "path": "reportContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve usar thresholds customizados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue usar thresholds customizados. **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.meetsThresholds` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.analysis.meetsThresholds"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com arquivo de cobertura inexistente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com arquivo de cobertura inexistente. **Valida√ß√µes**: `result.ok` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve calcular gaps corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular gaps corretamente. **Valida√ß√µes**: `result.ok` = `true`, `linesGap` = `\"200 linhas\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "linesGap = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "linesGap"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "200 linhas",
        "path": "linesGap"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve gerar recomenda√ß√µes espec√≠ficas baseadas nos gaps",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar recomenda√ß√µes espec√≠ficas baseadas nos gaps. **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.recommendations.length` = `0`, `result.analysis.recommendations.some()` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.analysis.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.analysis.recommendations.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve classificar prioridades corretamente (high, medium, low)",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue classificar prioridades corretamente (high, medium, low). **Valida√ß√µes**: `result.ok` = `true`, `result.analysis.priorities.length` = `3`",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "highPriority = ...",
      "mediumPriority = ...",
      "lowPriority = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.analysis.priorities.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "highPriority"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "mediumPriority"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "lowPriority"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoverageFile - Dispatcher (CR√çTICO) > deve processar arquivo JSON do Vitest/Jest corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar arquivo JSON do Vitest/Jest corretamente. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `80`, `result.summary.functions.pct` = `80`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.functions.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoverageFile - Dispatcher (CR√çTICO) > deve processar arquivo JSON do Mocha corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar arquivo JSON do Mocha corretamente. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `80`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve processar arquivo JSON do Vitest/Jest corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar arquivo JSON do Vitest/Jest corretamente. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `80`, `result.summary.functions.pct` = `80`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.functions.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve processar arquivo JSON do Mocha corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar arquivo JSON do Mocha corretamente. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `80`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML - Java (CR√çTICO) > deve validar detec√ß√£o de projeto Java com Maven",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Java com Maven. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML - Java (CR√çTICO) > deve validar detec√ß√£o de projeto Java com Gradle",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Java com Gradle. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML - Java (CR√çTICO) > deve processar XML JaCoCo quando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar XML JaCoCo quando dispon√≠vel. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "jacocoXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar detec√ß√£o de projeto Java com Maven",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Java com Maven. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar detec√ß√£o de projeto Java com Gradle",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Java com Gradle. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve processar XML JaCoCo quando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar XML JaCoCo quando dispon√≠vel. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "jacocoXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage - Python (CR√çTICO) > deve validar detec√ß√£o de projeto Python com pytest",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Python com pytest. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage - Python (CR√çTICO) > deve validar estrutura de projeto Python com pyproject.toml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar estrutura de projeto Python com pyproject.toml. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar detec√ß√£o de projeto Python com pytest",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Python com pytest. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar estrutura de projeto Python com pyproject.toml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar estrutura de projeto Python com pyproject.toml. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage - Go (CR√çTICO) > deve validar detec√ß√£o de projeto Go",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Go. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageOut = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage - Go (CR√çTICO) > deve validar formato coverage.out com modo atomic",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar formato coverage.out com modo atomic. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageOut = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage - Go (CR√çTICO) > deve validar projeto Go com coverage.out vazio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar projeto Go com coverage.out vazio. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar detec√ß√£o de projeto Go",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Go. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageOut = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar formato coverage.out com modo atomic",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar formato coverage.out com modo atomic. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageOut = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar projeto Go com coverage.out vazio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar projeto Go com coverage.out vazio. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov - Ruby (M√âDIA) > deve validar detec√ß√£o de projeto Ruby",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Ruby. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "simpleCovJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov - Ruby (M√âDIA) > deve validar formato SimpleCov alternativo",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar formato SimpleCov alternativo. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "simpleCovJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar detec√ß√£o de projeto Ruby",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Ruby. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "simpleCovJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve validar formato SimpleCov alternativo",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar formato SimpleCov alternativo. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "simpleCovJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoberturaXML - C# (M√âDIA) > deve lidar com detec√ß√£o de C# mesmo sem comando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com detec√ß√£o de C# mesmo sem comando dispon√≠vel. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coberturaXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com detec√ß√£o de C# mesmo sem comando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com detec√ß√£o de C# mesmo sem comando dispon√≠vel. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coberturaXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCloverXML - PHP (M√âDIA) > deve lidar com detec√ß√£o de PHP mesmo sem comando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com detec√ß√£o de PHP mesmo sem comando dispon√≠vel. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cloverXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com detec√ß√£o de PHP mesmo sem comando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com detec√ß√£o de PHP mesmo sem comando dispon√≠vel. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cloverXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML (unit) > deve parsear XML JaCoCo com todos os counters",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue parsear XML JaCoCo com todos os counters. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.covered` = `80`, `result.total.lines.pct` = `80` e mais 6",
    "whyItTests": "Valida 9 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~9) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 30,
        "path": "result.total.branches.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 20,
        "path": "result.total.functions.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 15,
        "path": "result.total.functions.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.functions.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML (unit) > deve lidar com XML sem counters",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue lidar com XML sem counters. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML (unit) > deve lidar com counters parciais",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue lidar com counters parciais. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.pct` = `70`, `result.total.branches.total` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 70,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.functions.total"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve parsear XML JaCoCo com todos os counters",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue parsear XML JaCoCo com todos os counters. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.covered` = `80`, `result.total.lines.pct` = `80` e mais 6",
    "whyItTests": "Valida 9 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~9) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 30,
        "path": "result.total.branches.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 20,
        "path": "result.total.functions.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 15,
        "path": "result.total.functions.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.functions.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com XML sem counters",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue lidar com XML sem counters. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com counters parciais",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue lidar com counters parciais. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.pct` = `70`, `result.total.branches.total` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 70,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.functions.total"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage (unit) > deve parsear coverage.out completo",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue parsear coverage.out completo. **Valida√ß√µes**: `result.total.statements.total` = `5`, `result.total.statements.covered` = `3`, `result.total.statements.pct` = `60`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 60,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage (unit) > deve ignorar linha mode",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue ignorar linha mode. **Valida√ß√µes**: `result.total.statements.total` = `1`, `result.total.statements.covered` = `1`, `result.total.statements.pct` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage (unit) > deve lidar com arquivo vazio",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue lidar com arquivo vazio. **Valida√ß√µes**: `result.total.statements.total` = `0`, `result.total.statements.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage (unit) > deve contar corretamente statements com count 0",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue contar corretamente statements com count 0. **Valida√ß√µes**: `result.total.statements.total` = `3`, `result.total.statements.covered` = `1`, `result.total.statements.pct` = `33.33`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 33.33,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve parsear coverage.out completo",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue parsear coverage.out completo. **Valida√ß√µes**: `result.total.statements.total` = `5`, `result.total.statements.covered` = `3`, `result.total.statements.pct` = `60`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 60,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve ignorar linha mode",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue ignorar linha mode. **Valida√ß√µes**: `result.total.statements.total` = `1`, `result.total.statements.covered` = `1`, `result.total.statements.pct` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com arquivo vazio",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue lidar com arquivo vazio. **Valida√ß√µes**: `result.total.statements.total` = `0`, `result.total.statements.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve contar corretamente statements com count 0",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue contar corretamente statements com count 0. **Valida√ß√µes**: `result.total.statements.total` = `3`, `result.total.statements.covered` = `1`, `result.total.statements.pct` = `33.33`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 33.33,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov (unit) > deve parsear JSON SimpleCov com wrapper coverage",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON SimpleCov com wrapper coverage. **Valida√ß√µes**: `result.total.lines.total` = `9`, `result.total.lines.covered` = `8`, `result.total.lines.pct` = `88.89`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 9,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 88.89,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov (unit) > deve parsear JSON SimpleCov sem wrapper",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON SimpleCov sem wrapper. **Valida√ß√µes**: `result.total.lines.total` = `4`, `result.total.lines.covered` = `3`, `result.total.lines.pct` = `75`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov (unit) > deve lidar com arquivo sem cobertura",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue lidar com arquivo sem cobertura. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov (unit) > deve contar corretamente m√∫ltiplos arquivos",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue contar corretamente m√∫ltiplos arquivos. **Valida√ß√µes**: `result.total.lines.total` = `8`, `result.total.lines.covered` = `4`, `result.total.lines.pct` = `50`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve parsear JSON SimpleCov com wrapper coverage",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON SimpleCov com wrapper coverage. **Valida√ß√µes**: `result.total.lines.total` = `9`, `result.total.lines.covered` = `8`, `result.total.lines.pct` = `88.89`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 9,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 88.89,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve parsear JSON SimpleCov sem wrapper",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON SimpleCov sem wrapper. **Valida√ß√µes**: `result.total.lines.total` = `4`, `result.total.lines.covered` = `3`, `result.total.lines.pct` = `75`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com arquivo sem cobertura",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue lidar com arquivo sem cobertura. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve contar corretamente m√∫ltiplos arquivos",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue contar corretamente m√∫ltiplos arquivos. **Valida√ß√µes**: `result.total.lines.total` = `8`, `result.total.lines.covered` = `4`, `result.total.lines.pct` = `50`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage (unit) > deve parsear JSON coverage.py completo",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON coverage.py completo. **Valida√ß√µes**: `result.total.lines.total` = `200`, `result.total.lines.covered` = `160`, `result.total.lines.pct` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 160,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.branches.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage (unit) > deve lidar com JSON sem branches",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue lidar com JSON sem branches. **Valida√ß√µes**: `result.total.lines.pct` = `75`, `result.total.branches.total` = `0`, `result.total.branches.pct` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage (unit) > deve calcular branch percentage corretamente",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue calcular branch percentage corretamente. **Valida√ß√µes**: `result.total.branches.pct` = `75`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve parsear JSON coverage.py completo",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON coverage.py completo. **Valida√ß√µes**: `result.total.lines.total` = `200`, `result.total.lines.covered` = `160`, `result.total.lines.pct` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 160,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.branches.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com JSON sem branches",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue lidar com JSON sem branches. **Valida√ß√µes**: `result.total.lines.pct` = `75`, `result.total.branches.total` = `0`, `result.total.branches.pct` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve calcular branch percentage corretamente",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue calcular branch percentage corretamente. **Valida√ß√µes**: `result.total.branches.pct` = `75`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoberturaXML (unit) > deve parsear XML Cobertura com rates",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue parsear XML Cobertura com rates. **Valida√ß√µes**: `result.total.lines.pct` = `85`, `result.total.branches.pct` = `75`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 85,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoberturaXML (unit) > deve lidar com XML sem rates",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue lidar com XML sem rates. **Valida√ß√µes**: `result.total.lines.pct` = `0`, `result.total.branches.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoberturaXML (unit) > deve processar rates decimais corretamente",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue processar rates decimais corretamente. **Valida√ß√µes**: `result.total.lines.pct` = `95.25`, `result.total.branches.pct` = `67.89`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 95.25,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 67.89,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve parsear XML Cobertura com rates",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue parsear XML Cobertura com rates. **Valida√ß√µes**: `result.total.lines.pct` = `85`, `result.total.branches.pct` = `75`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 85,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com XML sem rates",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue lidar com XML sem rates. **Valida√ß√µes**: `result.total.lines.pct` = `0`, `result.total.branches.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve processar rates decimais corretamente",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue processar rates decimais corretamente. **Valida√ß√µes**: `result.total.lines.pct` = `95.25`, `result.total.branches.pct` = `67.89`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 95.25,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 67.89,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCloverXML (unit) > deve parsear XML Clover com metrics completas",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue parsear XML Clover com metrics completas. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.covered` = `80`, `result.total.lines.pct` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 150,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCloverXML (unit) > deve lidar com XML sem metrics",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue lidar com XML sem metrics. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCloverXML (unit) > deve processar apenas elements se statements n√£o existir",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue processar apenas elements se statements n√£o existir. **Valida√ß√µes**: `result.total.lines.total` = `50`, `result.total.lines.covered` = `40`, `result.total.lines.pct` = `80` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.total"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve parsear XML Clover com metrics completas",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue parsear XML Clover com metrics completas. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.covered` = `80`, `result.total.lines.pct` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 150,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve lidar com XML sem metrics",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue lidar com XML sem metrics. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "Parsers Multi-linguagem > deve processar apenas elements se statements n√£o existir",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue processar apenas elements se statements n√£o existir. **Valida√ß√µes**: `result.total.lines.total` = `50`, `result.total.lines.covered` = `40`, `result.total.lines.pct` = `80` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.total"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoverageFile - Dispatcher (CR√çTICO) > deve processar arquivo JSON do Vitest/Jest corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar arquivo JSON do Vitest/Jest corretamente. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `80`, `result.summary.functions.pct` = `80`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.functions.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoverageFile - Dispatcher (CR√çTICO) > deve processar arquivo JSON do Mocha corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar arquivo JSON do Mocha corretamente. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `80`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve processar arquivo JSON do Vitest/Jest corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar arquivo JSON do Vitest/Jest corretamente. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `80`, `result.summary.functions.pct` = `80`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.functions.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve processar arquivo JSON do Mocha corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar arquivo JSON do Mocha corretamente. **Valida√ß√µes**: `result.ok` = `true`, `result.summary.lines.pct` = `80`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.summary.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML - Java (CR√çTICO) > deve validar detec√ß√£o de projeto Java com Maven",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Java com Maven. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML - Java (CR√çTICO) > deve validar detec√ß√£o de projeto Java com Gradle",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Java com Gradle. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML - Java (CR√çTICO) > deve processar XML JaCoCo quando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar XML JaCoCo quando dispon√≠vel. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "jacocoXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar detec√ß√£o de projeto Java com Maven",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Java com Maven. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar detec√ß√£o de projeto Java com Gradle",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Java com Gradle. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve processar XML JaCoCo quando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue processar XML JaCoCo quando dispon√≠vel. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "jacocoXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage - Python (CR√çTICO) > deve validar detec√ß√£o de projeto Python com pytest",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Python com pytest. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage - Python (CR√çTICO) > deve validar estrutura de projeto Python com pyproject.toml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar estrutura de projeto Python com pyproject.toml. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar detec√ß√£o de projeto Python com pytest",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Python com pytest. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar estrutura de projeto Python com pyproject.toml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar estrutura de projeto Python com pyproject.toml. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage - Go (CR√çTICO) > deve validar detec√ß√£o de projeto Go",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Go. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageOut = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage - Go (CR√çTICO) > deve validar formato coverage.out com modo atomic",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar formato coverage.out com modo atomic. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageOut = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage - Go (CR√çTICO) > deve validar projeto Go com coverage.out vazio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar projeto Go com coverage.out vazio. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar detec√ß√£o de projeto Go",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Go. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageOut = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar formato coverage.out com modo atomic",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar formato coverage.out com modo atomic. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverageOut = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar projeto Go com coverage.out vazio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar projeto Go com coverage.out vazio. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov - Ruby (M√âDIA) > deve validar detec√ß√£o de projeto Ruby",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Ruby. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "simpleCovJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov - Ruby (M√âDIA) > deve validar formato SimpleCov alternativo",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar formato SimpleCov alternativo. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "simpleCovJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar detec√ß√£o de projeto Ruby",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar detec√ß√£o de projeto Ruby. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "simpleCovJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve validar formato SimpleCov alternativo",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue validar formato SimpleCov alternativo. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "simpleCovJson = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoberturaXML - C# (M√âDIA) > deve lidar com detec√ß√£o de C# mesmo sem comando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com detec√ß√£o de C# mesmo sem comando dispon√≠vel. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coberturaXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com detec√ß√£o de C# mesmo sem comando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com detec√ß√£o de C# mesmo sem comando dispon√≠vel. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coberturaXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCloverXML - PHP (M√âDIA) > deve lidar com detec√ß√£o de PHP mesmo sem comando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com detec√ß√£o de PHP mesmo sem comando dispon√≠vel. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cloverXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com detec√ß√£o de PHP mesmo sem comando dispon√≠vel",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com detec√ß√£o de PHP mesmo sem comando dispon√≠vel. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "cloverXml = ...",
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML (unit) > deve parsear XML JaCoCo com todos os counters",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue parsear XML JaCoCo com todos os counters. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.covered` = `80`, `result.total.lines.pct` = `80` e mais 6",
    "whyItTests": "Valida 9 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~9) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 30,
        "path": "result.total.branches.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 20,
        "path": "result.total.functions.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 15,
        "path": "result.total.functions.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.functions.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML (unit) > deve lidar com XML sem counters",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue lidar com XML sem counters. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseJaCoCoXML (unit) > deve lidar com counters parciais",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue lidar com counters parciais. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.pct` = `70`, `result.total.branches.total` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 70,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.functions.total"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve parsear XML JaCoCo com todos os counters",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue parsear XML JaCoCo com todos os counters. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.covered` = `80`, `result.total.lines.pct` = `80` e mais 6",
    "whyItTests": "Valida 9 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~9) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 30,
        "path": "result.total.branches.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 20,
        "path": "result.total.functions.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 15,
        "path": "result.total.functions.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.functions.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com XML sem counters",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue lidar com XML sem counters. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com counters parciais",
    "testType": "unit",
    "functionUnderTest": "parseJaCoCoXML",
    "whatItTests": "Valida que **`parseJaCoCoXML`** consegue lidar com counters parciais. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.pct` = `70`, `result.total.branches.total` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseJaCoCoXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 70,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.functions.total"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage (unit) > deve parsear coverage.out completo",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue parsear coverage.out completo. **Valida√ß√µes**: `result.total.statements.total` = `5`, `result.total.statements.covered` = `3`, `result.total.statements.pct` = `60`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 60,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage (unit) > deve ignorar linha mode",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue ignorar linha mode. **Valida√ß√µes**: `result.total.statements.total` = `1`, `result.total.statements.covered` = `1`, `result.total.statements.pct` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage (unit) > deve lidar com arquivo vazio",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue lidar com arquivo vazio. **Valida√ß√µes**: `result.total.statements.total` = `0`, `result.total.statements.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseGoCoverage (unit) > deve contar corretamente statements com count 0",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue contar corretamente statements com count 0. **Valida√ß√µes**: `result.total.statements.total` = `3`, `result.total.statements.covered` = `1`, `result.total.statements.pct` = `33.33`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 33.33,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve parsear coverage.out completo",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue parsear coverage.out completo. **Valida√ß√µes**: `result.total.statements.total` = `5`, `result.total.statements.covered` = `3`, `result.total.statements.pct` = `60`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 60,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve ignorar linha mode",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue ignorar linha mode. **Valida√ß√µes**: `result.total.statements.total` = `1`, `result.total.statements.covered` = `1`, `result.total.statements.pct` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com arquivo vazio",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue lidar com arquivo vazio. **Valida√ß√µes**: `result.total.statements.total` = `0`, `result.total.statements.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve contar corretamente statements com count 0",
    "testType": "unit",
    "functionUnderTest": "parseGoCoverage",
    "whatItTests": "Valida que **`parseGoCoverage`** consegue contar corretamente statements com count 0. **Valida√ß√µes**: `result.total.statements.total` = `3`, `result.total.statements.covered` = `1`, `result.total.statements.pct` = `33.33`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "content = ...",
      "result = ..."
    ],
    "when": "parseGoCoverage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 33.33,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov (unit) > deve parsear JSON SimpleCov com wrapper coverage",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON SimpleCov com wrapper coverage. **Valida√ß√µes**: `result.total.lines.total` = `9`, `result.total.lines.covered` = `8`, `result.total.lines.pct` = `88.89`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 9,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 88.89,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov (unit) > deve parsear JSON SimpleCov sem wrapper",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON SimpleCov sem wrapper. **Valida√ß√µes**: `result.total.lines.total` = `4`, `result.total.lines.covered` = `3`, `result.total.lines.pct` = `75`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov (unit) > deve lidar com arquivo sem cobertura",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue lidar com arquivo sem cobertura. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseSimpleCov (unit) > deve contar corretamente m√∫ltiplos arquivos",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue contar corretamente m√∫ltiplos arquivos. **Valida√ß√µes**: `result.total.lines.total` = `8`, `result.total.lines.covered` = `4`, `result.total.lines.pct` = `50`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve parsear JSON SimpleCov com wrapper coverage",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON SimpleCov com wrapper coverage. **Valida√ß√µes**: `result.total.lines.total` = `9`, `result.total.lines.covered` = `8`, `result.total.lines.pct` = `88.89`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 9,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 88.89,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve parsear JSON SimpleCov sem wrapper",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON SimpleCov sem wrapper. **Valida√ß√µes**: `result.total.lines.total` = `4`, `result.total.lines.covered` = `3`, `result.total.lines.pct` = `75`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com arquivo sem cobertura",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue lidar com arquivo sem cobertura. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve contar corretamente m√∫ltiplos arquivos",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue contar corretamente m√∫ltiplos arquivos. **Valida√ß√µes**: `result.total.lines.total` = `8`, `result.total.lines.covered` = `4`, `result.total.lines.pct` = `50`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage (unit) > deve parsear JSON coverage.py completo",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON coverage.py completo. **Valida√ß√µes**: `result.total.lines.total` = `200`, `result.total.lines.covered` = `160`, `result.total.lines.pct` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 160,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.branches.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage (unit) > deve lidar com JSON sem branches",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue lidar com JSON sem branches. **Valida√ß√µes**: `result.total.lines.pct` = `75`, `result.total.branches.total` = `0`, `result.total.branches.pct` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parsePytestCoverage (unit) > deve calcular branch percentage corretamente",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue calcular branch percentage corretamente. **Valida√ß√µes**: `result.total.branches.pct` = `75`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve parsear JSON coverage.py completo",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue parsear JSON coverage.py completo. **Valida√ß√µes**: `result.total.lines.total` = `200`, `result.total.lines.covered` = `160`, `result.total.lines.pct` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 160,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.branches.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com JSON sem branches",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue lidar com JSON sem branches. **Valida√ß√µes**: `result.total.lines.pct` = `75`, `result.total.branches.total` = `0`, `result.total.branches.pct` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve calcular branch percentage corretamente",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue calcular branch percentage corretamente. **Valida√ß√µes**: `result.total.branches.pct` = `75`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "json = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoberturaXML (unit) > deve parsear XML Cobertura com rates",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue parsear XML Cobertura com rates. **Valida√ß√µes**: `result.total.lines.pct` = `85`, `result.total.branches.pct` = `75`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 85,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoberturaXML (unit) > deve lidar com XML sem rates",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue lidar com XML sem rates. **Valida√ß√µes**: `result.total.lines.pct` = `0`, `result.total.branches.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCoberturaXML (unit) > deve processar rates decimais corretamente",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue processar rates decimais corretamente. **Valida√ß√µes**: `result.total.lines.pct` = `95.25`, `result.total.branches.pct` = `67.89`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 95.25,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 67.89,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve parsear XML Cobertura com rates",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue parsear XML Cobertura com rates. **Valida√ß√µes**: `result.total.lines.pct` = `85`, `result.total.branches.pct` = `75`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 85,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com XML sem rates",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue lidar com XML sem rates. **Valida√ß√µes**: `result.total.lines.pct` = `0`, `result.total.branches.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve processar rates decimais corretamente",
    "testType": "unit",
    "functionUnderTest": "parseCoberturaXML",
    "whatItTests": "Valida que **`parseCoberturaXML`** consegue processar rates decimais corretamente. **Valida√ß√µes**: `result.total.lines.pct` = `95.25`, `result.total.branches.pct` = `67.89`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCoberturaXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 95.25,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 67.89,
        "path": "result.total.branches.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCloverXML (unit) > deve parsear XML Clover com metrics completas",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue parsear XML Clover com metrics completas. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.covered` = `80`, `result.total.lines.pct` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 150,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCloverXML (unit) > deve lidar com XML sem metrics",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue lidar com XML sem metrics. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "parseCloverXML (unit) > deve processar apenas elements se statements n√£o existir",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue processar apenas elements se statements n√£o existir. **Valida√ß√µes**: `result.total.lines.total` = `50`, `result.total.lines.covered` = `40`, `result.total.lines.pct` = `80` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.total"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve parsear XML Clover com metrics completas",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue parsear XML Clover com metrics completas. **Valida√ß√µes**: `result.total.lines.total` = `100`, `result.total.lines.covered` = `80`, `result.total.lines.pct` = `80` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "result.total.statements.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 150,
        "path": "result.total.statements.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.total.statements.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve lidar com XML sem metrics",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue lidar com XML sem metrics. **Valida√ß√µes**: `result.total.lines.total` = `0`, `result.total.lines.pct` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.lines.pct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-coverage.test.ts",
    "name": "deve processar apenas elements se statements n√£o existir",
    "testType": "unit",
    "functionUnderTest": "parseCloverXML",
    "whatItTests": "Valida que **`parseCloverXML`** consegue processar apenas elements se statements n√£o existir. **Valida√ß√µes**: `result.total.lines.total` = `50`, `result.total.lines.covered` = `40`, `result.total.lines.pct` = `80` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "xml = ...",
      "result = ..."
    ],
    "when": "parseCloverXML",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 50,
        "path": "result.total.lines.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 40,
        "path": "result.total.lines.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "result.total.lines.pct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total.statements.total"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve retornar erro se diret√≥rio de pacts n√£o existir",
    "testType": "unit",
    "functionUnderTest": "runContractsVerify",
    "whatItTests": "Valida que **`runContractsVerify`** consegue retornar erro se diret√≥rio de pacts n√£o existir. **Valida√ß√µes**: `result.ok` = `false`, `result.message` = `\"No Pact contracts found\"`, `result.verification_rate` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runContractsVerify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "No Pact contracts found",
        "path": "result.message"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Run `quality scaffold --type contracts` to generate Pact contracts",
        "path": "result.recommendations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve retornar erro se nenhum arquivo pact for encontrado",
    "testType": "unit",
    "functionUnderTest": "runContractsVerify",
    "whatItTests": "Valida que **`runContractsVerify`** consegue retornar erro se nenhum arquivo pact for encontrado. **Valida√ß√µes**: `result.ok` = `false`, `result.verification_rate` = `0`, `result.total_interactions` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runContractsVerify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total_interactions"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve verificar contratos com sucesso",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue verificar contratos com sucesso. **Valida√ß√µes**: `result.ok` = `true`, `result.total_interactions` = `1`, `result.verified` = `1` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockPactContent = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.verified"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.failed"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.verification_rate"
      }
    ],
    "mocks": [
      true,
      true,
      "mockPactContent",
      "mockPactContent"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve calcular verification_rate corretamente",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue calcular verification_rate corretamente. **Valida√ß√µes**: `result.total_interactions` = `3`, `result.verification_rate` = `0`, `result.verification_rate` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockPactContent = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "result.verification_rate"
      }
    ],
    "mocks": [
      true,
      true,
      "mockPactContent",
      "mockPactContent"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve gerar relat√≥rio JSON",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue gerar relat√≥rio JSON. **Valida√ß√µes**: `result.report_path` = `\"contracts-verify.json\"`, `reportCalls.length` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "reportCalls = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "contracts-verify.json",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "reportCalls.length"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve gerar relat√≥rio Markdown",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue gerar relat√≥rio Markdown. **Valida√ß√µes**: `mdCalls.length` = `1`, `mdContent` = `\"Contract Verification Report\"`, `mdContent` = `\"Summary\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "mdCalls = ...",
      "mdContent = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "mdCalls.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Contract Verification Report",
        "path": "mdContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Summary",
        "path": "mdContent"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve incluir falhas no resultado quando houver",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue incluir falhas no resultado quando houver. **Valida√ß√µes**: `Array.isArray()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.failures"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve gerar recomenda√ß√µes baseadas nos resultados",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue gerar recomenda√ß√µes baseadas nos resultados. **Valida√ß√µes**: `result.recommendations.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve processar m√∫ltiplos arquivos pact",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue processar m√∫ltiplos arquivos pact. **Valida√ß√µes**: `result.total_interactions` = `2`, `vi.mocked()` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveBeenCalledTimes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.total_interactions"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledTimes",
        "value": 2,
        "path": "vi.mocked()"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "run-contracts-verify > deve aceitar provider_base_url customizado",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue aceitar provider_base_url customizado. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "customUrl = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve retornar erro se diret√≥rio de pacts n√£o existir",
    "testType": "unit",
    "functionUnderTest": "runContractsVerify",
    "whatItTests": "Valida que **`runContractsVerify`** consegue retornar erro se diret√≥rio de pacts n√£o existir. **Valida√ß√µes**: `result.ok` = `false`, `result.message` = `\"No Pact contracts found\"`, `result.verification_rate` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runContractsVerify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "No Pact contracts found",
        "path": "result.message"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Run `quality scaffold --type contracts` to generate Pact contracts",
        "path": "result.recommendations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve retornar erro se nenhum arquivo pact for encontrado",
    "testType": "unit",
    "functionUnderTest": "runContractsVerify",
    "whatItTests": "Valida que **`runContractsVerify`** consegue retornar erro se nenhum arquivo pact for encontrado. **Valida√ß√µes**: `result.ok` = `false`, `result.verification_rate` = `0`, `result.total_interactions` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "runContractsVerify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total_interactions"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve verificar contratos com sucesso",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue verificar contratos com sucesso. **Valida√ß√µes**: `result.ok` = `true`, `result.total_interactions` = `1`, `result.verified` = `1` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockPactContent = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.verified"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.failed"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.verification_rate"
      }
    ],
    "mocks": [
      true,
      true,
      "mockPactContent",
      "mockPactContent"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve calcular verification_rate corretamente",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue calcular verification_rate corretamente. **Valida√ß√µes**: `result.total_interactions` = `3`, `result.verification_rate` = `0`, `result.verification_rate` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockPactContent = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "result.verification_rate"
      }
    ],
    "mocks": [
      true,
      true,
      "mockPactContent",
      "mockPactContent"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve gerar relat√≥rio JSON",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue gerar relat√≥rio JSON. **Valida√ß√µes**: `result.report_path` = `\"contracts-verify.json\"`, `reportCalls.length` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "reportCalls = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "contracts-verify.json",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "reportCalls.length"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve gerar relat√≥rio Markdown",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue gerar relat√≥rio Markdown. **Valida√ß√µes**: `mdCalls.length` = `1`, `mdContent` = `\"Contract Verification Report\"`, `mdContent` = `\"Summary\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "mdCalls = ...",
      "mdContent = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "mdCalls.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Contract Verification Report",
        "path": "mdContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Summary",
        "path": "mdContent"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve incluir falhas no resultado quando houver",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue incluir falhas no resultado quando houver. **Valida√ß√µes**: `Array.isArray()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.failures"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve gerar recomenda√ß√µes baseadas nos resultados",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue gerar recomenda√ß√µes baseadas nos resultados. **Valida√ß√µes**: `result.recommendations.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve processar m√∫ltiplos arquivos pact",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue processar m√∫ltiplos arquivos pact. **Valida√ß√µes**: `result.total_interactions` = `2`, `vi.mocked()` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveBeenCalledTimes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.total_interactions"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledTimes",
        "value": 2,
        "path": "vi.mocked()"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/run-contracts-verify.test.ts",
    "name": "deve aceitar provider_base_url customizado",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue aceitar provider_base_url customizado. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "customUrl = ...",
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      }
    ],
    "mocks": [
      true,
      true
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "buildReport > deve ler JSON do Playwright e gerar relat√≥rio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue ler JSON do Playwright e gerar relat√≥rio. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"QA Report\"`, `content` = `\"| **Passou** | 45 (90.00%) |\"` e mais 2",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "path": "result.out"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "QA Report",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "| **Passou** | 45 (90.00%) |",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "| **Falhou** | 3 |",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "| **Flaky** | 2 (4.00%) ‚ùå |",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "buildReport > deve incluir artefatos no relat√≥rio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue incluir artefatos no relat√≥rio. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"Artefatos\"`, `content` = `\"html/index.html\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Artefatos",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "html/index.html",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "junit/results.xml",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "json/results.json",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "buildReport > deve adicionar recomenda√ß√µes ao relat√≥rio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue adicionar recomenda√ß√µes ao relat√≥rio. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"Pr√≥ximas A√ß√µes\"`, `content` = `\"flaky\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Pr√≥ximas A√ß√µes",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "flaky",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "buildReport > deve verificar thresholds de flaky",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue verificar thresholds de flaky. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"‚ùå Resolver testes flaky (meta: ‚â§ 3%)\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "‚ùå Resolver testes flaky (meta: ‚â§ 3%)",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "buildReport > deve verificar thresholds de diff-coverage",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue verificar thresholds de diff-coverage. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"N/A*\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "N/A*",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "buildReport > deve lidar com arquivo JSON inexistente",
    "testType": "unit",
    "functionUnderTest": "buildReport",
    "whatItTests": "Valida que **`buildReport`** consegue lidar com arquivo JSON inexistente. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"0 (0.00%)\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "buildReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0 (0.00%)",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "buildReport > deve calcular dura√ß√£o em segundos corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular dura√ß√£o em segundos corretamente. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"125s\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "125s",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "buildReport > deve usar thresholds padr√£o quando n√£o especificados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue usar thresholds padr√£o quando n√£o especificados. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"‚úÖ Resolver testes flaky (meta: ‚â§ 3%)\"`, `content` = `\"N/A*\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "‚úÖ Resolver testes flaky (meta: ‚â§ 3%)",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "N/A*",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "deve ler JSON do Playwright e gerar relat√≥rio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue ler JSON do Playwright e gerar relat√≥rio. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"QA Report\"`, `content` = `\"| **Passou** | 45 (90.00%) |\"` e mais 2",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "path": "result.out"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "QA Report",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "| **Passou** | 45 (90.00%) |",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "| **Falhou** | 3 |",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "| **Flaky** | 2 (4.00%) ‚ùå |",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "deve incluir artefatos no relat√≥rio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue incluir artefatos no relat√≥rio. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"Artefatos\"`, `content` = `\"html/index.html\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Artefatos",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "html/index.html",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "junit/results.xml",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "json/results.json",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "deve adicionar recomenda√ß√µes ao relat√≥rio",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue adicionar recomenda√ß√µes ao relat√≥rio. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"Pr√≥ximas A√ß√µes\"`, `content` = `\"flaky\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Pr√≥ximas A√ß√µes",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "flaky",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "deve verificar thresholds de flaky",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue verificar thresholds de flaky. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"‚ùå Resolver testes flaky (meta: ‚â§ 3%)\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "‚ùå Resolver testes flaky (meta: ‚â§ 3%)",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "deve verificar thresholds de diff-coverage",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue verificar thresholds de diff-coverage. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"N/A*\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "N/A*",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "deve lidar com arquivo JSON inexistente",
    "testType": "unit",
    "functionUnderTest": "buildReport",
    "whatItTests": "Valida que **`buildReport`** consegue lidar com arquivo JSON inexistente. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"0 (0.00%)\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "buildReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0 (0.00%)",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "deve calcular dura√ß√£o em segundos corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular dura√ß√£o em segundos corretamente. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"125s\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "125s",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/report.test.ts",
    "name": "deve usar thresholds padr√£o quando n√£o especificados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue usar thresholds padr√£o quando n√£o especificados. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"‚úÖ Resolver testes flaky (meta: ‚â§ 3%)\"`, `content` = `\"N/A*\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "‚úÖ Resolver testes flaky (meta: ‚â§ 3%)",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "N/A*",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/release-quality-gate.test.ts",
    "name": "releaseQualityGate > deve retornar exit_code=0 quando todos os gates passam",
    "testType": "unit",
    "functionUnderTest": "releaseQualityGate",
    "whatItTests": "Valida que **`releaseQualityGate`** consegue retornar exit_code=0 quando todos os gates passam. **Valida√ß√µes**: `result.exit_code` = `0`, `result.summary.blocking_violations` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "releaseQualityGate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.exit_code"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.summary.blocking_violations"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/release-quality-gate.test.ts",
    "name": "deve retornar exit_code=0 quando todos os gates passam",
    "testType": "unit",
    "functionUnderTest": "releaseQualityGate",
    "whatItTests": "Valida que **`releaseQualityGate`** consegue retornar exit_code=0 quando todos os gates passam. **Valida√ß√µes**: `result.exit_code` = `0`, `result.summary.blocking_violations` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "releaseQualityGate",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.exit_code"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.summary.blocking_violations"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "recommendTestStrategy > deve detectar isCLI=true se tem commander",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar isCLI=true se tem commander. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"CLI\"`, `unknown` = `\"90\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "CLI",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "90",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "recommendTestStrategy > deve detectar isMCPServer=true se tem @modelcontextprotocol/sdk",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue . **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"MCP\"`, `unknown` = `\"90\"` e mais 1",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "MCP",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "90",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "recommendTestStrategy > deve detectar hasWebUI=true se tem react/next",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar hasWebUI=true se tem react/next. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"Web\"`, `e2ePct` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain, toBeGreaterThan. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "e2ePct = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Web",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "e2ePct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "recommendTestStrategy > deve calcular complexity baseado em features",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular complexity baseado em features. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"high\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "recommendTestStrategy > deve recomendar 90% unit para CLI tools",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue recomendar 90% unit para CLI tools. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"90\"`, `unknown` = `\"10\"` e mais 2",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "90",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "10",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0",
        "path": "unknown"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "recommendTestStrategy > deve recomendar 60/25/15 para web apps complexos",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue recomendar 60/25/15 para web apps complexos. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"high\"`, `unitPct` = `50` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "unitPct = ...",
      "integrationPct = ...",
      "e2ePct = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 50,
        "path": "unitPct"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 70,
        "path": "unitPct"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 20,
        "path": "integrationPct"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "e2ePct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "recommendTestStrategy > deve detectar se documento j√° existe",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar se documento j√° existe. **Valida√ß√µes**: `result1.ok` = `true`, `result2.ok` = `true`, `result2.exists` = `true`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result1 = ...",
      "result2 = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result1.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result1.file"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result2.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result2.exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "recommendTestStrategy > deve identificar arquivos priorit√°rios",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue identificar arquivos priorit√°rios. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `0`, `parserFile.priority` = `\"HIGH\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "parserFile = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "parserFile.priority"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "deve detectar isCLI=true se tem commander",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar isCLI=true se tem commander. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"CLI\"`, `unknown` = `\"90\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "CLI",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "90",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "deve detectar isMCPServer=true se tem @modelcontextprotocol/sdk",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue . **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"MCP\"`, `unknown` = `\"90\"` e mais 1",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "MCP",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "90",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "deve detectar hasWebUI=true se tem react/next",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar hasWebUI=true se tem react/next. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"Web\"`, `e2ePct` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain, toBeGreaterThan. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "e2ePct = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Web",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "e2ePct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "deve calcular complexity baseado em features",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular complexity baseado em features. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"high\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "deve recomendar 90% unit para CLI tools",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue recomendar 90% unit para CLI tools. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"90\"`, `unknown` = `\"10\"` e mais 2",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "90",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "10",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0",
        "path": "unknown"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "deve recomendar 60/25/15 para web apps complexos",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue recomendar 60/25/15 para web apps complexos. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"high\"`, `unitPct` = `50` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "unitPct = ...",
      "integrationPct = ...",
      "e2ePct = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 50,
        "path": "unitPct"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 70,
        "path": "unitPct"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 20,
        "path": "integrationPct"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "e2ePct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "deve detectar se documento j√° existe",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar se documento j√° existe. **Valida√ß√µes**: `result1.ok` = `true`, `result2.ok` = `true`, `result2.exists` = `true`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result1 = ...",
      "result2 = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result1.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result1.file"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result2.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result2.exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/recommend-strategy.test.ts",
    "name": "deve identificar arquivos priorit√°rios",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue identificar arquivos priorit√°rios. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `0`, `parserFile.priority` = `\"HIGH\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "parserFile = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "parserFile.priority"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "pyramid-report.ts > deve gerar relat√≥rio HTML da pir√¢mide",
    "testType": "unit",
    "functionUnderTest": "generatePyramidReport",
    "whatItTests": "Valida que **`generatePyramidReport`** consegue gerar relat√≥rio HTML da pir√¢mide. **Valida√ß√µes**: `result.ok` = `true`, `result.report_path` = `\".html\"`, `exists` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "exists = ..."
    ],
    "when": "generatePyramidReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".html",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "pyramid-report.ts > deve gerar relat√≥rio Markdown da pir√¢mide",
    "testType": "unit",
    "functionUnderTest": "generatePyramidReport",
    "whatItTests": "Valida que **`generatePyramidReport`** consegue gerar relat√≥rio Markdown da pir√¢mide. **Valida√ß√µes**: `result.ok` = `true`, `result.report_path` = `\".md\"`, `content` = `\"Pir√¢mide de Testes\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePyramidReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".md",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Pir√¢mide de Testes",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Unit",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Integration",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "E2E",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "pyramid-report.ts > deve incluir visualiza√ß√£o gr√°fica no HTML",
    "testType": "unit",
    "functionUnderTest": "generatePyramidReport",
    "whatItTests": "Valida que **`generatePyramidReport`** consegue incluir visualiza√ß√£o gr√°fica no HTML. **Valida√ß√µes**: `isHTML` = `true`, `content` = `\"TestProduct\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ...",
      "isHTML = ..."
    ],
    "when": "generatePyramidReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isHTML"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "pyramid-report.ts > deve incluir status de sa√∫de no relat√≥rio",
    "testType": "unit",
    "functionUnderTest": "generatePyramidReport",
    "whatItTests": "Valida que **`generatePyramidReport`** consegue incluir status de sa√∫de no relat√≥rio. **Valida√ß√µes**: `hasHealth` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ...",
      "hasHealth = ..."
    ],
    "when": "generatePyramidReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasHealth"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "pyramid-report.ts > deve lidar com aus√™ncia de coverage-analysis.json",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lidar com aus√™ncia de coverage-analysis.json. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "emptyRepoPath = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('pyramid-report.ts > deve lidar com aus√™ncia de cov...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('pyramid-report.ts > deve lidar com aus√™ncia de cov...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "deve gerar relat√≥rio HTML da pir√¢mide",
    "testType": "unit",
    "functionUnderTest": "generatePyramidReport",
    "whatItTests": "Valida que **`generatePyramidReport`** consegue gerar relat√≥rio HTML da pir√¢mide. **Valida√ß√µes**: `result.ok` = `true`, `result.report_path` = `\".html\"`, `exists` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "exists = ..."
    ],
    "when": "generatePyramidReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".html",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "deve gerar relat√≥rio Markdown da pir√¢mide",
    "testType": "unit",
    "functionUnderTest": "generatePyramidReport",
    "whatItTests": "Valida que **`generatePyramidReport`** consegue gerar relat√≥rio Markdown da pir√¢mide. **Valida√ß√µes**: `result.ok` = `true`, `result.report_path` = `\".md\"`, `content` = `\"Pir√¢mide de Testes\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePyramidReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".md",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Pir√¢mide de Testes",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Unit",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Integration",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "E2E",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "deve incluir visualiza√ß√£o gr√°fica no HTML",
    "testType": "unit",
    "functionUnderTest": "generatePyramidReport",
    "whatItTests": "Valida que **`generatePyramidReport`** consegue incluir visualiza√ß√£o gr√°fica no HTML. **Valida√ß√µes**: `isHTML` = `true`, `content` = `\"TestProduct\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ...",
      "isHTML = ..."
    ],
    "when": "generatePyramidReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isHTML"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "deve incluir status de sa√∫de no relat√≥rio",
    "testType": "unit",
    "functionUnderTest": "generatePyramidReport",
    "whatItTests": "Valida que **`generatePyramidReport`** consegue incluir status de sa√∫de no relat√≥rio. **Valida√ß√µes**: `hasHealth` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ...",
      "hasHealth = ..."
    ],
    "when": "generatePyramidReport",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasHealth"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/pyramid-report.test.ts",
    "name": "deve lidar com aus√™ncia de coverage-analysis.json",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue lidar com aus√™ncia de coverage-analysis.json. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "emptyRepoPath = ..."
    ],
    "when": "join",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve lidar com aus√™ncia de coverage-analysis.json...', () => {\n  const result = join(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve lidar com aus√™ncia de coverage-analysis.json...', () => {\n  const result = join(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/prod-metrics-ingest.test.ts",
    "name": "prodMetricsIngest > deve coletar m√©tricas e calcular DORA",
    "testType": "unit",
    "functionUnderTest": "prodMetricsIngest",
    "whatItTests": "Valida que **`prodMetricsIngest`** consegue coletar m√©tricas e calcular DORA. **Valida√ß√µes**: `result.ok` = `true`, `result.dora_metrics.deployment_frequency` = `0`, `result.dora_metrics.change_failure_rate` = `0` e mais 2",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThanOrEqual, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "prodMetricsIngest",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.dora_metrics"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.dora_metrics.deployment_frequency"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.dora_metrics.change_failure_rate"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.dora_metrics.mttr_minutes"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.dora_metrics.dora_tier"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/prod-metrics-ingest.test.ts",
    "name": "prodMetricsIngest > deve calcular DORA tier corretamente",
    "testType": "unit",
    "functionUnderTest": "prodMetricsIngest",
    "whatItTests": "Valida que **`prodMetricsIngest`** consegue calcular DORA tier corretamente. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "prodMetricsIngest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/prod-metrics-ingest.test.ts",
    "name": "prodMetricsIngest > deve usar mock data quando credenciais n√£o fornecidas",
    "testType": "unit",
    "functionUnderTest": "prodMetricsIngest",
    "whatItTests": "Valida que **`prodMetricsIngest`** consegue usar mock data quando credenciais n√£o fornecidas. **Valida√ß√µes**: `result.ok` = `true`, `result.releases.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "prodMetricsIngest",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.releases.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.dora_metrics"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/prod-metrics-ingest.test.ts",
    "name": "deve coletar m√©tricas e calcular DORA",
    "testType": "unit",
    "functionUnderTest": "prodMetricsIngest",
    "whatItTests": "Valida que **`prodMetricsIngest`** consegue coletar m√©tricas e calcular DORA. **Valida√ß√µes**: `result.ok` = `true`, `result.dora_metrics.deployment_frequency` = `0`, `result.dora_metrics.change_failure_rate` = `0` e mais 2",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThanOrEqual, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "prodMetricsIngest",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.dora_metrics"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.dora_metrics.deployment_frequency"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.dora_metrics.change_failure_rate"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.dora_metrics.mttr_minutes"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.dora_metrics.dora_tier"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/prod-metrics-ingest.test.ts",
    "name": "deve calcular DORA tier corretamente",
    "testType": "unit",
    "functionUnderTest": "prodMetricsIngest",
    "whatItTests": "Valida que **`prodMetricsIngest`** consegue calcular DORA tier corretamente. **1 valida√ß√µes** usando: toContain",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "prodMetricsIngest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/prod-metrics-ingest.test.ts",
    "name": "deve usar mock data quando credenciais n√£o fornecidas",
    "testType": "unit",
    "functionUnderTest": "prodMetricsIngest",
    "whatItTests": "Valida que **`prodMetricsIngest`** consegue usar mock data quando credenciais n√£o fornecidas. **Valida√ß√µes**: `result.ok` = `true`, `result.releases.length` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "prodMetricsIngest",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.releases.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.dora_metrics"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve gerar plano de testes b√°sico",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue gerar plano de testes b√°sico. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.plan"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve criar arquivo TEST-PLAN.md",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue criar arquivo TEST-PLAN.md. **Valida√ß√µes**: `exists` = `true`, `content` = `\"TestProduct2\"`, `content` = `\"Plano de Testes\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct2",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Plano de Testes",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve incluir exemplos quando solicitado",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue incluir exemplos quando solicitado. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve usar configura√ß√£o de mcp-settings.json",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue usar configura√ß√£o de mcp-settings.json. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "qaDir = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve organizar por dom√≠nios quando fornecidos",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue organizar por dom√≠nios quando fornecidos. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve validar par√¢metros obrigat√≥rios",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue validar par√¢metros obrigat√≥rios. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve incluir TODOs autom√°ticos no plano",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue incluir TODOs autom√°ticos no plano. **Valida√ß√µes**: `content` = `\"üéØ A√ß√µes Recomendadas\"`, `content` = `\"TODO: Create auth fixtures\"`, `content` = `\"TODO: Consider Testcontainers\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "üéØ A√ß√µes Recomendadas",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TODO: Create auth fixtures",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TODO: Consider Testcontainers",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TODO: Configure CI/CD pipeline",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve incluir Quality Gates com thresholds",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue incluir Quality Gates com thresholds. **Valida√ß√µes**: `content` = `\"Quality Gates\"`, `content` = `\"Required Coverage\"`, `content` = `\"Performance\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quality Gates",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Required Coverage",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Performance",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Blocking Criteria",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "plan.ts > deve calcular risk scores quando houver dados de an√°lise",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue calcular risk scores quando houver dados de an√°lise. **Valida√ß√µes**: `content` = `\"üî• Risk Score Analysis\"`, `content` = `{}`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAnalysis = ...",
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "üî• Risk Score Analysis",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve gerar plano de testes b√°sico",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue gerar plano de testes b√°sico. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.plan"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve criar arquivo TEST-PLAN.md",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue criar arquivo TEST-PLAN.md. **Valida√ß√µes**: `exists` = `true`, `content` = `\"TestProduct2\"`, `content` = `\"Plano de Testes\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct2",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Plano de Testes",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve incluir exemplos quando solicitado",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue incluir exemplos quando solicitado. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve usar configura√ß√£o de mcp-settings.json",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue usar configura√ß√£o de mcp-settings.json. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "qaDir = ...",
      "result = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve organizar por dom√≠nios quando fornecidos",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue organizar por dom√≠nios quando fornecidos. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve validar par√¢metros obrigat√≥rios",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue validar par√¢metros obrigat√≥rios. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve incluir TODOs autom√°ticos no plano",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue incluir TODOs autom√°ticos no plano. **Valida√ß√µes**: `content` = `\"üéØ A√ß√µes Recomendadas\"`, `content` = `\"TODO: Create auth fixtures\"`, `content` = `\"TODO: Consider Testcontainers\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "üéØ A√ß√µes Recomendadas",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TODO: Create auth fixtures",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TODO: Consider Testcontainers",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TODO: Configure CI/CD pipeline",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve incluir Quality Gates com thresholds",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue incluir Quality Gates com thresholds. **Valida√ß√µes**: `content` = `\"Quality Gates\"`, `content` = `\"Required Coverage\"`, `content` = `\"Performance\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quality Gates",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Required Coverage",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Performance",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Blocking Criteria",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/plan.test.ts",
    "name": "deve calcular risk scores quando houver dados de an√°lise",
    "testType": "unit",
    "functionUnderTest": "generatePlan",
    "whatItTests": "Valida que **`generatePlan`** consegue calcular risk scores quando houver dados de an√°lise. **Valida√ß√µes**: `content` = `\"üî• Risk Score Analysis\"`, `content` = `{}`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAnalysis = ...",
      "result = ...",
      "content = ..."
    ],
    "when": "generatePlan",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "üî• Risk Score Analysis",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect FULL mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect FULL mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect ANALYZE mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect ANALYZE mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect PLAN mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect PLAN mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect SCAFFOLD mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"scaffold\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `SCAFFOLD`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "scaffold",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect SCAFFOLD mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"scaffold\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `SCAFFOLD`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "scaffold",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect RUN mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect RUN mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should default to FULL mode for unrecognized queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect FULL mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect FULL mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect ANALYZE mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect ANALYZE mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect PLAN mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect PLAN mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect SCAFFOLD mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"scaffold\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `SCAFFOLD`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "scaffold",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect SCAFFOLD mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"scaffold\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `SCAFFOLD`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "scaffold",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect RUN mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should detect RUN mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should default to FULL mode for unrecognized queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue default to FULL mode for unrecognized queries. **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should extract repo override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract repo override. **Valida√ß√µes**: `result.repo` = `\"/home/user/project\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/home/user/project",
        "path": "result.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should extract product override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract product override. **Valida√ß√µes**: `result.product` = `\"MyApp\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MyApp",
        "path": "result.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should extract mode override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract mode override. **Valida√ß√µes**: `result.mode` = `\"analyze\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should extract multiple overrides",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract multiple overrides. **Valida√ß√µes**: `result.repo` = `\"/tmp/test\"`, `result.product` = `\"Portal\"`, `result.mode` = `\"plan\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/tmp/test",
        "path": "result.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Portal",
        "path": "result.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should return empty object for no overrides",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue return empty object for no overrides. **Valida√ß√µes**: `result` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should extract repo override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract repo override. **Valida√ß√µes**: `result.repo` = `\"/home/user/project\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/home/user/project",
        "path": "result.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should extract product override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract product override. **Valida√ß√µes**: `result.product` = `\"MyApp\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MyApp",
        "path": "result.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should extract mode override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract mode override. **Valida√ß√µes**: `result.mode` = `\"analyze\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should extract multiple overrides",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract multiple overrides. **Valida√ß√µes**: `result.repo` = `\"/tmp/test\"`, `result.product` = `\"Portal\"`, `result.mode` = `\"plan\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/tmp/test",
        "path": "result.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Portal",
        "path": "result.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should return empty object for no overrides",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue return empty object for no overrides. **Valida√ß√µes**: `result` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should execute with detected mode from query",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.detected_mode"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should merge extracted overrides with detected mode",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"analyze\"`, `result.extracted_params` = `\"{...}\"` e mais 1",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.extracted_params"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.final_params"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should apply defaults and override with extracted params",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue apply defaults and override with extracted params. **Valida√ß√µes**: `result.success` = `true`, `result.final_params` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.final_params"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should prioritize explicit mode override over detected mode",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.detected_mode` = `\"full\"`, `result.final_params.mode` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.final_params.mode"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should handle errors gracefully",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue handle errors gracefully. **Valida√ß√µes**: `result.success` = `false`, `result.error` = `\"Test error\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Test error",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should execute with detected mode from query",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.detected_mode"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should merge extracted overrides with detected mode",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"analyze\"`, `result.extracted_params` = `\"{...}\"` e mais 1",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.extracted_params"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.final_params"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should apply defaults and override with extracted params",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue apply defaults and override with extracted params. **Valida√ß√µes**: `result.success` = `true`, `result.final_params` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.final_params"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should prioritize explicit mode override over detected mode",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.detected_mode` = `\"full\"`, `result.final_params.mode` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.final_params.mode"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should handle errors gracefully",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue handle errors gracefully. **Valida√ß√µes**: `result.success` = `false`, `result.error` = `\"Test error\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Test error",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "runNLCommand > should return true on success",
    "testType": "unit",
    "functionUnderTest": "runNLCommand",
    "whatItTests": "Valida que **`runNLCommand`** consegue return true on success. **Valida√ß√µes**: `success` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runNLCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "runNLCommand > should return false on error",
    "testType": "unit",
    "functionUnderTest": "runNLCommand",
    "whatItTests": "Valida que **`runNLCommand`** consegue return false on error. **Valida√ß√µes**: `success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runNLCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should return true on success",
    "testType": "unit",
    "functionUnderTest": "runNLCommand",
    "whatItTests": "Valida que **`runNLCommand`** consegue return true on success. **Valida√ß√µes**: `success` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runNLCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nl-command > should return false on error",
    "testType": "unit",
    "functionUnderTest": "runNLCommand",
    "whatItTests": "Valida que **`runNLCommand`** consegue return false on error. **Valida√ß√µes**: `success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runNLCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect FULL mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect FULL mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect ANALYZE mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect ANALYZE mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect PLAN mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect PLAN mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect SCAFFOLD mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"scaffold\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `SCAFFOLD`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "scaffold",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect SCAFFOLD mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"scaffold\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `SCAFFOLD`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "scaffold",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect RUN mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should detect RUN mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "detectMode > should default to FULL mode for unrecognized queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect FULL mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect FULL mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `FULL`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect ANALYZE mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect ANALYZE mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `ANALYZE`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect PLAN mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect PLAN mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `PLAN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect SCAFFOLD mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"scaffold\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `SCAFFOLD`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "scaffold",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect SCAFFOLD mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"scaffold\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `SCAFFOLD`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "scaffold",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect RUN mode from PT queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should detect RUN mode from EN queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue . **Valida√ß√µes**: `detectMode()` = `\"run\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `RUN`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should default to FULL mode for unrecognized queries",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue default to FULL mode for unrecognized queries. **Valida√ß√µes**: `detectMode()` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "detectMode()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should extract repo override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract repo override. **Valida√ß√µes**: `result.repo` = `\"/home/user/project\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/home/user/project",
        "path": "result.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should extract product override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract product override. **Valida√ß√µes**: `result.product` = `\"MyApp\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MyApp",
        "path": "result.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should extract mode override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract mode override. **Valida√ß√µes**: `result.mode` = `\"analyze\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should extract multiple overrides",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract multiple overrides. **Valida√ß√µes**: `result.repo` = `\"/tmp/test\"`, `result.product` = `\"Portal\"`, `result.mode` = `\"plan\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/tmp/test",
        "path": "result.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Portal",
        "path": "result.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "extractOverrides > should return empty object for no overrides",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue return empty object for no overrides. **Valida√ß√µes**: `result` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should extract repo override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract repo override. **Valida√ß√µes**: `result.repo` = `\"/home/user/project\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/home/user/project",
        "path": "result.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should extract product override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract product override. **Valida√ß√µes**: `result.product` = `\"MyApp\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "MyApp",
        "path": "result.product"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should extract mode override",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract mode override. **Valida√ß√µes**: `result.mode` = `\"analyze\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should extract multiple overrides",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue extract multiple overrides. **Valida√ß√µes**: `result.repo` = `\"/tmp/test\"`, `result.product` = `\"Portal\"`, `result.mode` = `\"plan\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "/tmp/test",
        "path": "result.repo"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Portal",
        "path": "result.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should return empty object for no overrides",
    "testType": "unit",
    "functionUnderTest": "extractOverrides",
    "whatItTests": "Valida que **`extractOverrides`** consegue return empty object for no overrides. **Valida√ß√µes**: `result` = `\"{...}\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "extractOverrides",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should execute with detected mode from query",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.detected_mode"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should merge extracted overrides with detected mode",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"analyze\"`, `result.extracted_params` = `\"{...}\"` e mais 1",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.extracted_params"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.final_params"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should apply defaults and override with extracted params",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue apply defaults and override with extracted params. **Valida√ß√µes**: `result.success` = `true`, `result.final_params` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.final_params"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should prioritize explicit mode override over detected mode",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.detected_mode` = `\"full\"`, `result.final_params.mode` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.final_params.mode"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "nlCommand > should handle errors gracefully",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue handle errors gracefully. **Valida√ß√µes**: `result.success` = `false`, `result.error` = `\"Test error\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Test error",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should execute with detected mode from query",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"plan\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "plan",
        "path": "result.detected_mode"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should merge extracted overrides with detected mode",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.success` = `true`, `result.detected_mode` = `\"analyze\"`, `result.extracted_params` = `\"{...}\"` e mais 1",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 1 propriedades relacionadas ao modo: `result.detected_mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "{...}",
        "path": "result.extracted_params"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.final_params"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should apply defaults and override with extracted params",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue apply defaults and override with extracted params. **Valida√ß√µes**: `result.success` = `true`, `result.final_params` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "result.final_params"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should prioritize explicit mode override over detected mode",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue . **Valida√ß√µes**: `result.detected_mode` = `\"full\"`, `result.final_params.mode` = `\"analyze\"`",
    "whyItTests": "Garante que o **NLP** (Natural Language Processing) mapeia corretamente comandos em portugu√™s/ingl√™s para o modo `desconhecido`. Valida 2 propriedades relacionadas ao modo: `result.detected_mode`, `result.final_params.mode`. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üéØ **UX**: Permitir que usu√°rios usem comandos naturais (portugu√™s/ingl√™s) ao inv√©s de flags CLI complexas\n- üìâ **CFR**: Reduzir erros de uso do CLI (comandos inv√°lidos/confusos) ‚Üí menos suporte\n- ‚ö° **Produtividade**: Usu√°rios expressam inten√ß√£o diretamente (\"criar plano de testes\") ‚Üí onboarding mais r√°pido\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "result.detected_mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "result.final_params.mode"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "path": "autoQualityRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should handle errors gracefully",
    "testType": "unit",
    "functionUnderTest": "nlCommand",
    "whatItTests": "Valida que **`nlCommand`** consegue handle errors gracefully. **Valida√ß√µes**: `result.success` = `false`, `result.error` = `\"Test error\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "nlCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.success"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Test error",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "runNLCommand > should return true on success",
    "testType": "unit",
    "functionUnderTest": "runNLCommand",
    "whatItTests": "Valida que **`runNLCommand`** consegue return true on success. **Valida√ß√µes**: `success` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runNLCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "runNLCommand > should return false on error",
    "testType": "unit",
    "functionUnderTest": "runNLCommand",
    "whatItTests": "Valida que **`runNLCommand`** consegue return false on error. **Valida√ß√µes**: `success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runNLCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should return true on success",
    "testType": "unit",
    "functionUnderTest": "runNLCommand",
    "whatItTests": "Valida que **`runNLCommand`** consegue return true on success. **Valida√ß√µes**: `success` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runNLCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/nl-command.test.ts",
    "name": "should return false on error",
    "testType": "unit",
    "functionUnderTest": "runNLCommand",
    "whatItTests": "Valida que **`runNLCommand`** consegue return false on error. **Valida√ß√µes**: `success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runNLCommand",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "initProduct > deve criar estrutura completa de QA para produto",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar estrutura completa de QA para produto. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "path": "result.path"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "initProduct > deve criar diret√≥rios de testes",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar diret√≥rios de testes. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "qaDir = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "initProduct > deve criar mcp-settings.json com configura√ß√µes corretas",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar mcp-settings.json com configura√ß√µes corretas. **Valida√ß√µes**: `unknown` = `true`, `settings.product` = `\"TestProduct\"`, `settings.base_url` = `\"https://www.example.com\"` e mais 5",
    "whyItTests": "Valida 9 aspecto(s) usando: toBe, toEqual, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~9) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settingsPath = ...",
      "content = ...",
      "settings = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "TestProduct",
        "path": "settings.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://www.example.com",
        "path": "settings.base_url"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "settings.domains"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "settings.critical_flows"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "settings.targets"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "settings.targets.diff_coverage_min"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "settings.targets.flaky_pct_max"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "settings.targets.ci_p95_min"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "initProduct > deve criar GETTING_STARTED.md",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar GETTING_STARTED.md. **Valida√ß√µes**: `unknown` = `true`, `content` = `\"TestProduct\"`, `content` = `\"https://www.example.com\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "gettingStartedPath = ...",
      "content = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "https://www.example.com",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Responsabilidades",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quality Gates",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "initProduct > deve criar README.md",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar README.md. **Valida√ß√µes**: `unknown` = `true`, `content` = `\"TestProduct\"`, `content` = `\"Quick Start\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "readmePath = ...",
      "content = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quick Start",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "initProduct > deve criar .gitignore apropriado",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar .gitignore apropriado. **Valida√ß√µes**: `unknown` = `true`, `content` = `\"storageState.json\"`, `content` = `\"*.bak\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "gitignorePath = ...",
      "content = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "storageState.json",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "*.bak",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "node_modules",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "initProduct > n√£o deve sobrescrever mcp-settings.json existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sobrescrever mcp-settings.json existente. **Valida√ß√µes**: `finalSettings.custom_field` = `\"test\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "settingsPath = ...",
      "originalContent = ...",
      "settings = ...",
      "finalContent = ...",
      "finalSettings = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "test",
        "path": "finalSettings.custom_field"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "initProduct > deve criar environments corretos baseado na base_url",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar environments corretos baseado na base_url. **Valida√ß√µes**: `settings.environments.dev.url` = `\"https://dev.example.com\"`, `settings.environments.stg.url` = `\"https://stg.example.com\"`, `settings.environments.prod.url` = `\"https://www.example.com\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settingsPath = ...",
      "content = ...",
      "settings = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "settings.environments"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://dev.example.com",
        "path": "settings.environments.dev.url"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://stg.example.com",
        "path": "settings.environments.stg.url"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://www.example.com",
        "path": "settings.environments.prod.url"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "deve criar estrutura completa de QA para produto",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar estrutura completa de QA para produto. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "path": "result.path"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "deve criar diret√≥rios de testes",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar diret√≥rios de testes. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "qaDir = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "deve criar mcp-settings.json com configura√ß√µes corretas",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar mcp-settings.json com configura√ß√µes corretas. **Valida√ß√µes**: `unknown` = `true`, `settings.product` = `\"TestProduct\"`, `settings.base_url` = `\"https://www.example.com\"` e mais 5",
    "whyItTests": "Valida 9 aspecto(s) usando: toBe, toEqual, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~9) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settingsPath = ...",
      "content = ...",
      "settings = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "TestProduct",
        "path": "settings.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://www.example.com",
        "path": "settings.base_url"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "settings.domains"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "settings.critical_flows"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "settings.targets"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 80,
        "path": "settings.targets.diff_coverage_min"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "settings.targets.flaky_pct_max"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "settings.targets.ci_p95_min"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "deve criar GETTING_STARTED.md",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar GETTING_STARTED.md. **Valida√ß√µes**: `unknown` = `true`, `content` = `\"TestProduct\"`, `content` = `\"https://www.example.com\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "gettingStartedPath = ...",
      "content = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "https://www.example.com",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Responsabilidades",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quality Gates",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "deve criar README.md",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar README.md. **Valida√ß√µes**: `unknown` = `true`, `content` = `\"TestProduct\"`, `content` = `\"Quick Start\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "readmePath = ...",
      "content = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quick Start",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "deve criar .gitignore apropriado",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar .gitignore apropriado. **Valida√ß√µes**: `unknown` = `true`, `content` = `\"storageState.json\"`, `content` = `\"*.bak\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "gitignorePath = ...",
      "content = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "storageState.json",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "*.bak",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "node_modules",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "n√£o deve sobrescrever mcp-settings.json existente",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sobrescrever mcp-settings.json existente. **Valida√ß√µes**: `finalSettings.custom_field` = `\"test\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "settingsPath = ...",
      "originalContent = ...",
      "settings = ...",
      "finalContent = ...",
      "finalSettings = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "test",
        "path": "finalSettings.custom_field"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/init-product.test.ts",
    "name": "deve criar environments corretos baseado na base_url",
    "testType": "unit",
    "functionUnderTest": "initProduct",
    "whatItTests": "Valida que **`initProduct`** consegue criar environments corretos baseado na base_url. **Valida√ß√µes**: `settings.environments.dev.url` = `\"https://dev.example.com\"`, `settings.environments.stg.url` = `\"https://stg.example.com\"`, `settings.environments.prod.url` = `\"https://www.example.com\"`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "settingsPath = ...",
      "content = ...",
      "settings = ..."
    ],
    "when": "initProduct",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "settings.environments"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://dev.example.com",
        "path": "settings.environments.dev.url"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://stg.example.com",
        "path": "settings.environments.stg.url"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "https://www.example.com",
        "path": "settings.environments.prod.url"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "explain-tests > deve retornar estrutura b√°sica mesmo sem testes",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue retornar estrutura b√°sica mesmo sem testes. **Valida√ß√µes**: `result` = `\"ok\"`, `result` = `\"explanations\"`, `result` = `\"metrics\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "ok",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "explanations",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "metrics",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "explain-tests > deve gerar m√©tricas corretas para testes vazios",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue gerar m√©tricas corretas para testes vazios. **Valida√ß√µes**: `result.metrics.totalTests` = `0`, `result.metrics.assertStrongPct` = `0`, `result.metrics.assertMediumPct` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.metrics.totalTests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.metrics.assertStrongPct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.metrics.assertMediumPct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.metrics.assertWeakPct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "explain-tests > deve falhar quando failOn=\"weak\" e houver testes fracos",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue falhar quando failOn=\"weak\" e houver testes fracos. **Valida√ß√µes**: `result.ok` = `false`, `result` = `\"explanations\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveProperty. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "explanations",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "explain-tests > deve gerar outputs JSON e MD conforme solicitado",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue gerar outputs JSON e MD conforme solicitado. **Valida√ß√µes**: `result.outputPaths` = `\"explanationsJson\"`, `result.outputPaths` = `\"explanationsMd\"`, `result.outputPaths` = `\"qualitySummaryMd\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "explanationsJson",
        "path": "result.outputPaths"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "explanationsMd",
        "path": "result.outputPaths"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "qualitySummaryMd",
        "path": "result.outputPaths"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "metricsJson",
        "path": "result.outputPaths"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "explain-tests > deve calcular KR3a status corretamente",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue calcular KR3a status corretamente. **Valida√ß√µes**: `result.kr3aStatus` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.kr3aStatus"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "deve retornar estrutura b√°sica mesmo sem testes",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue retornar estrutura b√°sica mesmo sem testes. **Valida√ß√µes**: `result` = `\"ok\"`, `result` = `\"explanations\"`, `result` = `\"metrics\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveProperty, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "ok",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "explanations",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "metrics",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "deve gerar m√©tricas corretas para testes vazios",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue gerar m√©tricas corretas para testes vazios. **Valida√ß√µes**: `result.metrics.totalTests` = `0`, `result.metrics.assertStrongPct` = `0`, `result.metrics.assertMediumPct` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.metrics.totalTests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.metrics.assertStrongPct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.metrics.assertMediumPct"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.metrics.assertWeakPct"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "deve falhar quando failOn=\"weak\" e houver testes fracos",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue falhar quando failOn=\"weak\" e houver testes fracos. **Valida√ß√µes**: `result.ok` = `false`, `result` = `\"explanations\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveProperty. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "explanations",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "deve gerar outputs JSON e MD conforme solicitado",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue gerar outputs JSON e MD conforme solicitado. **Valida√ß√µes**: `result.outputPaths` = `\"explanationsJson\"`, `result.outputPaths` = `\"explanationsMd\"`, `result.outputPaths` = `\"qualitySummaryMd\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "explanationsJson",
        "path": "result.outputPaths"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "explanationsMd",
        "path": "result.outputPaths"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "qualitySummaryMd",
        "path": "result.outputPaths"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "metricsJson",
        "path": "result.outputPaths"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/explain-tests.test.ts",
    "name": "deve calcular KR3a status corretamente",
    "testType": "unit",
    "functionUnderTest": "explainTests",
    "whatItTests": "Valida que **`explainTests`** consegue calcular KR3a status corretamente. **Valida√ß√µes**: `result.kr3aStatus` = `{}`",
    "whyItTests": "Valida 1 aspecto(s) usando: toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "options = ...",
      "result = ..."
    ],
    "when": "explainTests",
    "then": [
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.kr3aStatus"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve identificar fun√ß√µes exportadas sem testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue identificar fun√ß√µes exportadas sem testes. **Valida√ß√µes**: `result.ok` = `true`, `result.functions.length` = `3`, `result.untested.length` = `3`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContainEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.functions.length"
      },
      {
        "type": "value",
        "matcher": "toContainEqual",
        "path": "result.functions"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.untested.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve categorizar fun√ß√µes corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue categorizar fun√ß√µes corretamente. **Valida√ß√µes**: `unknown` = `\"parser\"`, `unknown` = `\"validator\"`, `unknown` = `\"core\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "parser = ...",
      "validator = ...",
      "core = ...",
      "util = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "parser",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "validator",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "core",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "util",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve determinar criticidade corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue determinar criticidade corretamente. **Valida√ß√µes**: `unknown` = `\"CRITICAL\"`, `unknown` = `\"HIGH\"`, `unknown` = `\"LOW\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "jacocoParser = ...",
      "goParser = ...",
      "validator = ...",
      "util = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve detectar fun√ß√µes com testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar fun√ß√µes com testes. **Valida√ß√µes**: `unknown` = `true`, `unknown` = `2`, `unknown` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "addFunc = ...",
      "multiplyFunc = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve calcular m√©tricas de qualidade",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular m√©tricas de qualidade. **Valida√ß√µes**: `result.metrics.qualityScore` = `50`, `result.metrics.criticalFunctionsTotal` = `2`, `result.metrics.criticalFunctionsTested` = `2` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 50,
        "path": "result.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.metrics.criticalFunctionsTotal"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.metrics.criticalFunctionsTested"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.metrics.usesDescribeBlocks"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.metrics.usesBeforeAfterHooks"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.metrics.hasEdgeCaseTests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.metrics.hasErrorHandlingTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve gerar recomenda√ß√µes para fun√ß√µes cr√≠ticas sem testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar recomenda√ß√µes para fun√ß√µes cr√≠ticas sem testes. **Valida√ß√µes**: `result.recommendations.length` = `0`, `result.recommendations.some()` = `true`, `unknown` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "jacoco = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.recommendations.some()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve calcular quality score e grade corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular quality score e grade corretamente. **Valida√ß√µes**: `result.metrics.qualityScore` = `60`, `result.metrics.grade` = `{}`, `result.metrics.avgAssertionsPerTest` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThan, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 60,
        "path": "result.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.metrics.grade"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 1,
        "path": "result.metrics.avgAssertionsPerTest"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve gerar relat√≥rio de qualidade",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar relat√≥rio de qualidade. **Valida√ß√µes**: `reportContent` = `\"# üéØ Relat√≥rio de Qualidade de Testes\"`, `reportContent` = `\"TestProduct\"`, `reportContent` = `\"Quality Score:\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "reportContent = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "# üéØ Relat√≥rio de Qualidade de Testes",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quality Score:",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Grade:",
        "path": "reportContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "evaluateTestQuality > deve detectar testes sem assertions",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar testes sem assertions. **Valida√ß√µes**: `result.metrics.avgAssertionsPerTest` = `2`, `result.recommendations.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeLessThan, toBeGreaterThan. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 2,
        "path": "result.metrics.avgAssertionsPerTest"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve identificar fun√ß√µes exportadas sem testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue identificar fun√ß√µes exportadas sem testes. **Valida√ß√µes**: `result.ok` = `true`, `result.functions.length` = `3`, `result.untested.length` = `3`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContainEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.functions.length"
      },
      {
        "type": "value",
        "matcher": "toContainEqual",
        "path": "result.functions"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.untested.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve categorizar fun√ß√µes corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue categorizar fun√ß√µes corretamente. **Valida√ß√µes**: `unknown` = `\"parser\"`, `unknown` = `\"validator\"`, `unknown` = `\"core\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "parser = ...",
      "validator = ...",
      "core = ...",
      "util = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "parser",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "validator",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "core",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "util",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve determinar criticidade corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue determinar criticidade corretamente. **Valida√ß√µes**: `unknown` = `\"CRITICAL\"`, `unknown` = `\"HIGH\"`, `unknown` = `\"LOW\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "jacocoParser = ...",
      "goParser = ...",
      "validator = ...",
      "util = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve detectar fun√ß√µes com testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar fun√ß√µes com testes. **Valida√ß√µes**: `unknown` = `true`, `unknown` = `2`, `unknown` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "addFunc = ...",
      "multiplyFunc = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve calcular m√©tricas de qualidade",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular m√©tricas de qualidade. **Valida√ß√µes**: `result.metrics.qualityScore` = `50`, `result.metrics.criticalFunctionsTotal` = `2`, `result.metrics.criticalFunctionsTested` = `2` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 50,
        "path": "result.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.metrics.criticalFunctionsTotal"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.metrics.criticalFunctionsTested"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.metrics.usesDescribeBlocks"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.metrics.usesBeforeAfterHooks"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.metrics.hasEdgeCaseTests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.metrics.hasErrorHandlingTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve gerar recomenda√ß√µes para fun√ß√µes cr√≠ticas sem testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar recomenda√ß√µes para fun√ß√µes cr√≠ticas sem testes. **Valida√ß√µes**: `result.recommendations.length` = `0`, `result.recommendations.some()` = `true`, `unknown` = `0` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "jacoco = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.recommendations.some()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve calcular quality score e grade corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue calcular quality score e grade corretamente. **Valida√ß√µes**: `result.metrics.qualityScore` = `60`, `result.metrics.grade` = `{}`, `result.metrics.avgAssertionsPerTest` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThan, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 60,
        "path": "result.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.metrics.grade"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 1,
        "path": "result.metrics.avgAssertionsPerTest"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve gerar relat√≥rio de qualidade",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar relat√≥rio de qualidade. **Valida√ß√µes**: `reportContent` = `\"# üéØ Relat√≥rio de Qualidade de Testes\"`, `reportContent` = `\"TestProduct\"`, `reportContent` = `\"Quality Score:\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "reportContent = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "# üéØ Relat√≥rio de Qualidade de Testes",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestProduct",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Quality Score:",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Grade:",
        "path": "reportContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/evaluate-test-quality.test.ts",
    "name": "deve detectar testes sem assertions",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar testes sem assertions. **Valida√ß√µes**: `result.metrics.avgAssertionsPerTest` = `2`, `result.recommendations.length` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeLessThan, toBeGreaterThan. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 2,
        "path": "result.metrics.avgAssertionsPerTest"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/define-slos.test.ts",
    "name": "defineSLOs > deve gerar SLOs com defaults baseados em criticidade",
    "testType": "unit",
    "functionUnderTest": "setupQAStructure",
    "whatItTests": "Valida que **`setupQAStructure`** consegue gerar SLOs com defaults baseados em criticidade. **Valida√ß√µes**: `result.ok` = `true`, `result.slos_count` = `2`, `result.custom_slos_count` = `0` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toHaveLength, toBeLessThanOrEqual, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ...",
      "cujCatalog = ...",
      "result = ...",
      "slosData = ...",
      "criticalSLO = ..."
    ],
    "when": "setupQAStructure",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.slos_count"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.custom_slos_count"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "slosData.slos"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 500,
        "path": "criticalSLO.latency_p99_ms"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 0.01,
        "path": "criticalSLO.error_rate_max"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0.995,
        "path": "criticalSLO.availability_min"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/define-slos.test.ts",
    "name": "defineSLOs > deve aplicar SLOs customizados quando fornecidos",
    "testType": "unit",
    "functionUnderTest": "setupQAStructure",
    "whatItTests": "Valida que **`setupQAStructure`** consegue aplicar SLOs customizados quando fornecidos. **Valida√ß√µes**: `result.ok` = `true`, `result.custom_slos_count` = `1`, `searchSLO.latency_p99_ms` = `200` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ...",
      "cujCatalog = ...",
      "result = ...",
      "slosData = ...",
      "searchSLO = ..."
    ],
    "when": "setupQAStructure",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.custom_slos_count"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "searchSLO.latency_p99_ms"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0.001,
        "path": "searchSLO.error_rate_max"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/define-slos.test.ts",
    "name": "defineSLOs > deve aplicar defaults customizados globais",
    "testType": "unit",
    "functionUnderTest": "setupQAStructure",
    "whatItTests": "Valida que **`setupQAStructure`** consegue aplicar defaults customizados globais. **Valida√ß√µes**: `result.ok` = `true`, `testSLO.latency_p99_ms` = `1000`, `testSLO.error_rate_max` = `0.05` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ...",
      "cujCatalog = ...",
      "result = ...",
      "slosData = ...",
      "testSLO = ..."
    ],
    "when": "setupQAStructure",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1000,
        "path": "testSLO.latency_p99_ms"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0.05,
        "path": "testSLO.error_rate_max"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0.99,
        "path": "testSLO.availability_min"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/define-slos.test.ts",
    "name": "defineSLOs > deve lidar com cat√°logo vazio",
    "testType": "unit",
    "functionUnderTest": "setupQAStructure",
    "whatItTests": "Valida que **`setupQAStructure`** consegue lidar com cat√°logo vazio. **Valida√ß√µes**: `result.ok` = `true`, `result.slos_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ...",
      "cujCatalog = ...",
      "result = ..."
    ],
    "when": "setupQAStructure",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.slos_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/define-slos.test.ts",
    "name": "deve gerar SLOs com defaults baseados em criticidade",
    "testType": "unit",
    "functionUnderTest": "setupQAStructure",
    "whatItTests": "Valida que **`setupQAStructure`** consegue gerar SLOs com defaults baseados em criticidade. **Valida√ß√µes**: `result.ok` = `true`, `result.slos_count` = `2`, `result.custom_slos_count` = `0` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toHaveLength, toBeLessThanOrEqual, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ...",
      "cujCatalog = ...",
      "result = ...",
      "slosData = ...",
      "criticalSLO = ..."
    ],
    "when": "setupQAStructure",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.slos_count"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.custom_slos_count"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "slosData.slos"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 500,
        "path": "criticalSLO.latency_p99_ms"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 0.01,
        "path": "criticalSLO.error_rate_max"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0.995,
        "path": "criticalSLO.availability_min"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/define-slos.test.ts",
    "name": "deve aplicar SLOs customizados quando fornecidos",
    "testType": "unit",
    "functionUnderTest": "setupQAStructure",
    "whatItTests": "Valida que **`setupQAStructure`** consegue aplicar SLOs customizados quando fornecidos. **Valida√ß√µes**: `result.ok` = `true`, `result.custom_slos_count` = `1`, `searchSLO.latency_p99_ms` = `200` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ...",
      "cujCatalog = ...",
      "result = ...",
      "slosData = ...",
      "searchSLO = ..."
    ],
    "when": "setupQAStructure",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.custom_slos_count"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 200,
        "path": "searchSLO.latency_p99_ms"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0.001,
        "path": "searchSLO.error_rate_max"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/define-slos.test.ts",
    "name": "deve aplicar defaults customizados globais",
    "testType": "unit",
    "functionUnderTest": "setupQAStructure",
    "whatItTests": "Valida que **`setupQAStructure`** consegue aplicar defaults customizados globais. **Valida√ß√µes**: `result.ok` = `true`, `testSLO.latency_p99_ms` = `1000`, `testSLO.error_rate_max` = `0.05` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "paths = ...",
      "cujCatalog = ...",
      "result = ...",
      "slosData = ...",
      "testSLO = ..."
    ],
    "when": "setupQAStructure",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1000,
        "path": "testSLO.latency_p99_ms"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0.05,
        "path": "testSLO.error_rate_max"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0.99,
        "path": "testSLO.availability_min"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/define-slos.test.ts",
    "name": "deve lidar com cat√°logo vazio",
    "testType": "unit",
    "functionUnderTest": "setupQAStructure",
    "whatItTests": "Valida que **`setupQAStructure`** consegue lidar com cat√°logo vazio. **Valida√ß√µes**: `result.ok` = `true`, `result.slos_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "paths = ...",
      "cujCatalog = ...",
      "result = ..."
    ],
    "when": "setupQAStructure",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.slos_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "generateDashboard > deve coletar m√©tricas de testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue coletar m√©tricas de testes. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "generateDashboard > deve gerar dashboard HTML",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar dashboard HTML. **Valida√ß√µes**: `result.ok` = `true`, `exists` = `true`, `content` = `\"<!DOCTYPE html>\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "dashboardPath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "<!DOCTYPE html>",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestApp",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "generateDashboard > deve incluir gr√°ficos de cobertura",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue incluir gr√°ficos de cobertura. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"50:30:20\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "dashboardPath = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "50:30:20",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "generateDashboard > deve gerar dashboard com visualiza√ß√£o da pir√¢mide",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar dashboard com visualiza√ß√£o da pir√¢mide. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"Visualiza√ß√£o da Pir√¢mide\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "dashboardPath = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Visualiza√ß√£o da Pir√¢mide",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "generateDashboard > deve lidar com aus√™ncia de m√©tricas",
    "testType": "unit",
    "functionUnderTest": "generateDashboard",
    "whatItTests": "Valida que **`generateDashboard`** consegue lidar com aus√™ncia de m√©tricas. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "generateDashboard",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "generateDashboard > deve exibir status de sa√∫de dos testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue exibir status de sa√∫de dos testes. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"85/100\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "dashboardPath = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "85/100",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "deve coletar m√©tricas de testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue coletar m√©tricas de testes. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "deve gerar dashboard HTML",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar dashboard HTML. **Valida√ß√µes**: `result.ok` = `true`, `exists` = `true`, `content` = `\"<!DOCTYPE html>\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "dashboardPath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "<!DOCTYPE html>",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestApp",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "deve incluir gr√°ficos de cobertura",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue incluir gr√°ficos de cobertura. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"50:30:20\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "dashboardPath = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "50:30:20",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "deve gerar dashboard com visualiza√ß√£o da pir√¢mide",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue gerar dashboard com visualiza√ß√£o da pir√¢mide. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"Visualiza√ß√£o da Pir√¢mide\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "dashboardPath = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Visualiza√ß√£o da Pir√¢mide",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "deve lidar com aus√™ncia de m√©tricas",
    "testType": "unit",
    "functionUnderTest": "generateDashboard",
    "whatItTests": "Valida que **`generateDashboard`** consegue lidar com aus√™ncia de m√©tricas. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "generateDashboard",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/dashboard.test.ts",
    "name": "deve exibir status de sa√∫de dos testes",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue exibir status de sa√∫de dos testes. **Valida√ß√µes**: `result.ok` = `true`, `content` = `\"85/100\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "dashboardPath = ...",
      "content = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "85/100",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/coverage.test.ts",
    "name": "deve calcular % de unit/integration/E2E corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue calcular % de unit/integration/E2E corretamente. **Valida√ß√µes**: `totalTests` = `3`, `result.pyramid.unit.files_found` = `1`, `result.pyramid.integration.files_found` = `1` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "totalTests = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "totalTests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.pyramid.unit.files_found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.pyramid.integration.files_found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.pyramid.e2e.files_found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/coverage.test.ts",
    "name": "deve marcar como saud√°vel se unit >= 70%",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue marcar como saud√°vel se unit >= 70%. **Valida√ß√µes**: `result.health` = `\"healthy\"`, `result.summary` = `\"SAUD√ÅVEL\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "healthy",
        "path": "result.health"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "SAUD√ÅVEL",
        "path": "result.summary"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/coverage.test.ts",
    "name": "deve alertar se E2E > unit",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue alertar se E2E > unit. **Valida√ß√µes**: `result.health` = `\"inverted\"`, `hasInvertedWarning` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "hasInvertedWarning = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "inverted",
        "path": "result.health"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasInvertedWarning"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/coverage.test.ts",
    "name": "deve sugerir mais unit tests se < 70%",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue sugerir mais unit tests se < 70%. **Valida√ß√µes**: `hasUnitRecommendation` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "hasUnitRecommendation = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasUnitRecommendation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/coverage.test.ts",
    "name": "deve salvar COVERAGE-REPORT.md e coverage-analysis.json",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue salvar COVERAGE-REPORT.md e coverage-analysis.json. **Valida√ß√µes**: `reportExists` = `true`, `analysisExists` = `true`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "reportPath = ...",
      "analysisPath = ...",
      "reportExists = ...",
      "analysisExists = ...",
      "content = ...",
      "data = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "reportExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "analysisExists"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "data.summary"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "data.pyramid"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/coverage.test.ts",
    "name": "deve lidar com reposit√≥rio sem testes",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue lidar com reposit√≥rio sem testes. **Valida√ß√µes**: `result.pyramid.unit.files_found` = `0`, `result.pyramid.integration.files_found` = `0`, `result.pyramid.e2e.files_found` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.pyramid.unit.files_found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.pyramid.integration.files_found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.pyramid.e2e.files_found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "catalogScenarios > deve listar cen√°rios de teste",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue listar cen√°rios de teste. **Valida√ß√µes**: `result.total_scenarios` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_scenarios"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "catalogScenarios > deve atribuir squads aos cen√°rios",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue atribuir squads aos cen√°rios. **Valida√ß√µes**: `Object.keys().length` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "Object.keys().length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "catalogScenarios > deve detectar cen√°rios duplicados",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar cen√°rios duplicados. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "testContent = ...",
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.duplicates"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "catalogScenarios > deve gerar matriz de responsabilidades",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar matriz de responsabilidades. **Valida√ß√µes**: `exists` = `true`, `content` = `\"Matriz de Responsabilidade - Testes\"`, `content` = `\"Squad A\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "matrixPath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Matriz de Responsabilidade - Testes",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Squad A",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "catalogScenarios > deve salvar cat√°logo em Markdown",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue salvar cat√°logo em Markdown. **Valida√ß√µes**: `exists` = `true`, `content` = `\"Cat√°logo de Cen√°rios\"`, `content` = `\"TestApp\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalogPath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Cat√°logo de Cen√°rios",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestApp",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "catalogScenarios > deve lidar com reposit√≥rio sem testes",
    "testType": "unit",
    "functionUnderTest": "catalogScenarios",
    "whatItTests": "Valida que **`catalogScenarios`** consegue lidar com reposit√≥rio sem testes. **Valida√ß√µes**: `result.total_scenarios` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogScenarios",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total_scenarios"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "catalogScenarios > deve contar cen√°rios por squad",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue contar cen√°rios por squad. **Valida√ß√µes**: `result.total_scenarios` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_scenarios"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "catalogScenarios > deve identificar cen√°rios por prioridade",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue identificar cen√°rios por prioridade. **Valida√ß√µes**: `result.by_priority.P1.length` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.by_priority.P1.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "deve listar cen√°rios de teste",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue listar cen√°rios de teste. **Valida√ß√µes**: `result.total_scenarios` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_scenarios"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "deve atribuir squads aos cen√°rios",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue atribuir squads aos cen√°rios. **Valida√ß√µes**: `Object.keys().length` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "Object.keys().length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "deve detectar cen√°rios duplicados",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar cen√°rios duplicados. **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "testContent = ...",
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.duplicates"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "deve gerar matriz de responsabilidades",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar matriz de responsabilidades. **Valida√ß√µes**: `exists` = `true`, `content` = `\"Matriz de Responsabilidade - Testes\"`, `content` = `\"Squad A\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "matrixPath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Matriz de Responsabilidade - Testes",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Squad A",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "deve salvar cat√°logo em Markdown",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue salvar cat√°logo em Markdown. **Valida√ß√µes**: `exists` = `true`, `content` = `\"Cat√°logo de Cen√°rios\"`, `content` = `\"TestApp\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalogPath = ...",
      "exists = ...",
      "content = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "exists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Cat√°logo de Cen√°rios",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TestApp",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "deve lidar com reposit√≥rio sem testes",
    "testType": "unit",
    "functionUnderTest": "catalogScenarios",
    "whatItTests": "Valida que **`catalogScenarios`** consegue lidar com reposit√≥rio sem testes. **Valida√ß√µes**: `result.total_scenarios` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogScenarios",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total_scenarios"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "deve contar cen√°rios por squad",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue contar cen√°rios por squad. **Valida√ß√µes**: `result.total_scenarios` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_scenarios"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog.test.ts",
    "name": "deve identificar cen√°rios por prioridade",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue identificar cen√°rios por prioridade. **Valida√ß√µes**: `result.by_priority.P1.length` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.by_priority.P1.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve catalogar rotas Express b√°sicas",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue catalogar rotas Express b√°sicas. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `1`, `result.output` = `\"cuj-catalog.json\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.cujs_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cuj-catalog.json",
        "path": "result.output"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve classificar /api/auth como critical",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/auth como critical. **Valida√ß√µes**: `catalogData.cujs` = `1`, `catalogData.cujs.?.criticality` = `\"critical\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "critical",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve classificar /api/checkout como critical",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/checkout como critical. **Valida√ß√µes**: `catalogData.cujs.?.criticality` = `\"critical\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "critical",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve classificar /api/search como high",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/search como high. **Valida√ß√µes**: `catalogData.cujs.?.criticality` = `\"high\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve degradar /api/admin de critical para high",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue degradar /api/admin de critical para high. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Express routes discovery > deve degradar /api/admi...', () => {\n  const result = catalogCUJs(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Express routes discovery > deve degradar /api/admi...', () => {\n  const result = catalogCUJs(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve catalogar rotas Express b√°sicas",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue catalogar rotas Express b√°sicas. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `1`, `result.output` = `\"cuj-catalog.json\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.cujs_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cuj-catalog.json",
        "path": "result.output"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve classificar /api/auth como critical",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/auth como critical. **Valida√ß√µes**: `catalogData.cujs` = `1`, `catalogData.cujs.?.criticality` = `\"critical\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "critical",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve classificar /api/checkout como critical",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/checkout como critical. **Valida√ß√µes**: `catalogData.cujs.?.criticality` = `\"critical\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "critical",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve classificar /api/search como high",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/search como high. **Valida√ß√µes**: `catalogData.cujs.?.criticality` = `\"high\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve degradar /api/admin de critical para high",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue degradar /api/admin de critical para high. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('catalogCUJs > deve degradar /api/admin de critical...', () => {\n  const result = catalogCUJs(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('catalogCUJs > deve degradar /api/admin de critical...', () => {\n  const result = catalogCUJs(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Next.js routes discovery > deve catalogar rotas Next.js",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue catalogar rotas Next.js. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve catalogar rotas Next.js",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue catalogar rotas Next.js. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "README discovery > deve extrair features do README",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue extrair features do README. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `3`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockReadme = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "mockReadme",
      "mockReadme",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve extrair features do README",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue extrair features do README. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `3`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockReadme = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "mockReadme",
      "mockReadme",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Deduplication > deve mesclar endpoints duplicados no mesmo CUJ",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue mesclar endpoints duplicados no mesmo CUJ. **Valida√ß√µes**: `catalogData.cujs` = `1`, `catalogData.cujs.?.id` = `\"auth-api\"`, `catalogData.cujs.?.endpoints` = `3`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auth-api",
        "path": "catalogData.cujs.?.id"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "catalogData.cujs.?.endpoints"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve mesclar endpoints duplicados no mesmo CUJ",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue mesclar endpoints duplicados no mesmo CUJ. **Valida√ß√µes**: `catalogData.cujs` = `1`, `catalogData.cujs.?.id` = `\"auth-api\"`, `catalogData.cujs.?.endpoints` = `3`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auth-api",
        "path": "catalogData.cujs.?.id"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "catalogData.cujs.?.endpoints"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Multi-language support > deve detectar projeto TypeScript",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto TypeScript. **Valida√ß√µes**: `result.ok` = `true`, `catalogData.cujs` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Multi-language support > deve detectar projeto Python",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto Python. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Multi-language support > deve detectar projeto Java",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto Java. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve detectar projeto TypeScript",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto TypeScript. **Valida√ß√µes**: `result.ok` = `true`, `catalogData.cujs` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve detectar projeto Python",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto Python. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve detectar projeto Java",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto Java. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Error handling > deve retornar ok=false se language detection falhar",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue retornar ok=false se language detection falhar. **Valida√ß√µes**: `result.ok` = `false`, `result.error` = `\"Language detection failed\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Language detection failed",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Error handling > deve retornar ok=false se writeFile falhar",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue retornar ok=false se writeFile falhar. **Valida√ß√µes**: `result.ok` = `false`, `result.error` = `\"Disk full\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Disk full",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve retornar ok=false se language detection falhar",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue retornar ok=false se language detection falhar. **Valida√ß√µes**: `result.ok` = `false`, `result.error` = `\"Language detection failed\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Language detection failed",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve retornar ok=false se writeFile falhar",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue retornar ok=false se writeFile falhar. **Valida√ß√µes**: `result.ok` = `false`, `result.error` = `\"Disk full\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Disk full",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Multi-source integration > deve combinar rotas + README",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue combinar rotas + README. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockReadme = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "mockReadme",
      "mockReadme",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "catalogCUJs > deve combinar rotas + README",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue combinar rotas + README. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockReadme = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "mockReadme",
      "mockReadme",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve catalogar rotas Express b√°sicas",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue catalogar rotas Express b√°sicas. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `1`, `result.output` = `\"cuj-catalog.json\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.cujs_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cuj-catalog.json",
        "path": "result.output"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve classificar /api/auth como critical",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/auth como critical. **Valida√ß√µes**: `catalogData.cujs` = `1`, `catalogData.cujs.?.criticality` = `\"critical\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "critical",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve classificar /api/checkout como critical",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/checkout como critical. **Valida√ß√µes**: `catalogData.cujs.?.criticality` = `\"critical\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "critical",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve classificar /api/search como high",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/search como high. **Valida√ß√µes**: `catalogData.cujs.?.criticality` = `\"high\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Express routes discovery > deve degradar /api/admin de critical para high",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue degradar /api/admin de critical para high. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Express routes discovery > deve degradar /api/admi...', () => {\n  const result = catalogCUJs(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Express routes discovery > deve degradar /api/admi...', () => {\n  const result = catalogCUJs(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve catalogar rotas Express b√°sicas",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue catalogar rotas Express b√°sicas. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `1`, `result.output` = `\"cuj-catalog.json\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.cujs_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cuj-catalog.json",
        "path": "result.output"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve classificar /api/auth como critical",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/auth como critical. **Valida√ß√µes**: `catalogData.cujs` = `1`, `catalogData.cujs.?.criticality` = `\"critical\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "critical",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve classificar /api/checkout como critical",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/checkout como critical. **Valida√ß√µes**: `catalogData.cujs.?.criticality` = `\"critical\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "critical",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve classificar /api/search como high",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue classificar /api/search como high. **Valida√ß√µes**: `catalogData.cujs.?.criticality` = `\"high\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "catalogData.cujs.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve degradar /api/admin de critical para high",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue degradar /api/admin de critical para high. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve degradar /api/admin de critical para high...', () => {\n  const result = catalogCUJs(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve degradar /api/admin de critical para high...', () => {\n  const result = catalogCUJs(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Next.js routes discovery > deve catalogar rotas Next.js",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue catalogar rotas Next.js. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve catalogar rotas Next.js",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue catalogar rotas Next.js. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "README discovery > deve extrair features do README",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue extrair features do README. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `3`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockReadme = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "mockReadme",
      "mockReadme",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve extrair features do README",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue extrair features do README. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `3`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockReadme = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "mockReadme",
      "mockReadme",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Deduplication > deve mesclar endpoints duplicados no mesmo CUJ",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue mesclar endpoints duplicados no mesmo CUJ. **Valida√ß√µes**: `catalogData.cujs` = `1`, `catalogData.cujs.?.id` = `\"auth-api\"`, `catalogData.cujs.?.endpoints` = `3`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auth-api",
        "path": "catalogData.cujs.?.id"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "catalogData.cujs.?.endpoints"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve mesclar endpoints duplicados no mesmo CUJ",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue mesclar endpoints duplicados no mesmo CUJ. **Valida√ß√µes**: `catalogData.cujs` = `1`, `catalogData.cujs.?.id` = `\"auth-api\"`, `catalogData.cujs.?.endpoints` = `3`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "catalogData = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auth-api",
        "path": "catalogData.cujs.?.id"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "catalogData.cujs.?.endpoints"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Multi-language support > deve detectar projeto TypeScript",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto TypeScript. **Valida√ß√µes**: `result.ok` = `true`, `catalogData.cujs` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Multi-language support > deve detectar projeto Python",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto Python. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Multi-language support > deve detectar projeto Java",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto Java. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve detectar projeto TypeScript",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto TypeScript. **Valida√ß√µes**: `result.ok` = `true`, `catalogData.cujs` = `1`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "catalogData = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "catalogData.cujs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve detectar projeto Python",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto Python. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve detectar projeto Java",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue detectar projeto Java. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Error handling > deve retornar ok=false se language detection falhar",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue retornar ok=false se language detection falhar. **Valida√ß√µes**: `result.ok` = `false`, `result.error` = `\"Language detection failed\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Language detection failed",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Error handling > deve retornar ok=false se writeFile falhar",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue retornar ok=false se writeFile falhar. **Valida√ß√µes**: `result.ok` = `false`, `result.error` = `\"Disk full\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Disk full",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve retornar ok=false se language detection falhar",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue retornar ok=false se language detection falhar. **Valida√ß√µes**: `result.ok` = `false`, `result.error` = `\"Language detection failed\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Language detection failed",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve retornar ok=false se writeFile falhar",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue retornar ok=false se writeFile falhar. **Valida√ß√µes**: `result.ok` = `false`, `result.error` = `\"Disk full\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Disk full",
        "path": "result.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "Multi-source integration > deve combinar rotas + README",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue combinar rotas + README. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockReadme = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "mockReadme",
      "mockReadme",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/catalog-cujs.test.ts",
    "name": "deve combinar rotas + README",
    "testType": "unit",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue combinar rotas + README. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `2`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockReadme = ...",
      "result = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.cujs_count"
      }
    ],
    "mocks": [
      "mockReadme",
      "mockReadme",
      "undefined",
      "undefined"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "excessive-mocks",
        "description": "Excesso de mocks (4 mocks) - teste muito acoplado √† implementa√ß√£o",
        "severity": "high",
        "impact": "Teste fr√°gil que quebra com mudan√ßas internas. Dificulta refatora√ß√£o. Baixo acoplamento com c√≥digo real.",
        "howToFix": {
          "before": "// ‚ùå MAU - Muitos mocks (4 mocks)\nit('should send email', () => {\n  const mockDb = vi.fn();\n  const mockLogger = vi.fn();\n  const mockEmailService = vi.fn();\n  const mockQueue = vi.fn();\n  const mockCache = vi.fn(); // 4¬∫ mock! üö®\n  const mockMetrics = vi.fn();\n  \n  sendEmailWithLogging(data, mockDb, mockLogger, ...);\n  \n  expect(mockDb).toHaveBeenCalled();\n  expect(mockLogger).toHaveBeenCalled();\n  // Testando demais a implementa√ß√£o!\n});",
          "after": "// ‚úÖ BOM - Teste de integra√ß√£o com mocks essenciais\nit('should send email', async () => {\n  // Mock apenas APIs externas (n√£o control√°veis)\n  const mockEmailProvider = vi.fn().mockResolvedValue({ sent: true });\n  \n  // Use implementa√ß√µes reais para o resto\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test',\n    provider: mockEmailProvider\n  });\n  \n  // Valide o COMPORTAMENTO, n√£o a implementa√ß√£o\n  expect(result.sent).toBe(true);\n  expect(mockEmailProvider).toHaveBeenCalledWith(\n    expect.objectContaining({ to: 'test@example.com' })\n  );\n});\n\n// üí° Alternativa: Teste de integra√ß√£o real\nit('should send email (integration)', async () => {\n  // Sem mocks - usa banco de teste real\n  const result = await emailService.send({\n    to: 'test@example.com',\n    subject: 'Test'\n  });\n  \n  expect(result.sent).toBe(true);\n  \n  // Verificar no banco de teste\n  const sentEmails = await db.emails.findAll();\n  expect(sentEmails).toHaveLength(1);\n});",
          "explanation": "Reduza mocks para o m√≠nimo necess√°rio: (1) APIs externas n√£o control√°veis, (2) Recursos caros (rede, I/O). Para o resto, use implementa√ß√µes reais. Considere testes de integra√ß√£o ao inv√©s de unit tests com muitos mocks."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Reduzir depend√™ncias mockadas, considerar testes de integra√ß√£o",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - detectRepoContext > should detect product from package.json",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detect product from package.json. **Valida√ß√µes**: `context.product` = `\"my-awesome-app\"`, `context.hasPackageJson` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "context = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "my-awesome-app",
        "path": "context.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "context.hasPackageJson"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - detectRepoContext > should detect existing tests",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detect existing tests. **Valida√ß√µes**: `context.hasTests` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "context = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "context.hasTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - detectRepoContext > should detect test framework from package.json",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detect test framework from package.json. **Valida√ß√µes**: `context.testFramework` = `\"vitest\"`, `context.language` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "context = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "context.testFramework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "context.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - detectRepoContext > should fallback to directory name if no package.json",
    "testType": "unit",
    "functionUnderTest": "detectRepoContext",
    "whatItTests": "Valida que **`detectRepoContext`** consegue fallback to directory name if no package.json. **Valida√ß√µes**: `context.product` = `\".test-auto-\"`, `context.hasPackageJson` = `false`, `context.hasTests` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "context = ..."
    ],
    "when": "detectRepoContext",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".test-auto-",
        "path": "context.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "context.hasPackageJson"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "context.hasTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - detectRepoContext > should handle package.json without name",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue handle package.json without name. **Valida√ß√µes**: `context.product` = `\".test-auto-\"`, `context.hasPackageJson` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "context = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".test-auto-",
        "path": "context.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "context.hasPackageJson"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should detect product from package.json",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detect product from package.json. **Valida√ß√µes**: `context.product` = `\"my-awesome-app\"`, `context.hasPackageJson` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "context = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "my-awesome-app",
        "path": "context.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "context.hasPackageJson"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should detect existing tests",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detect existing tests. **Valida√ß√µes**: `context.hasTests` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "context = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "context.hasTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should detect test framework from package.json",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detect test framework from package.json. **Valida√ß√µes**: `context.testFramework` = `\"vitest\"`, `context.language` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "context = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "context.testFramework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "context.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should fallback to directory name if no package.json",
    "testType": "unit",
    "functionUnderTest": "detectRepoContext",
    "whatItTests": "Valida que **`detectRepoContext`** consegue fallback to directory name if no package.json. **Valida√ß√µes**: `context.product` = `\".test-auto-\"`, `context.hasPackageJson` = `false`, `context.hasTests` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "context = ..."
    ],
    "when": "detectRepoContext",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".test-auto-",
        "path": "context.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "context.hasPackageJson"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "context.hasTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should handle package.json without name",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue handle package.json without name. **Valida√ß√µes**: `context.product` = `\".test-auto-\"`, `context.hasPackageJson` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "context = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": ".test-auto-",
        "path": "context.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "context.hasPackageJson"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - autoQualityRun > should execute analyze mode successfully",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue executar corretamente o modo **analyze** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps` = `\"analyze\"`, `analyze` = `\"{...}\"`",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `analyze` corretamente",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "{...}",
        "path": "analyze"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - autoQualityRun > should execute plan mode (analyze + plan)",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue executar corretamente o modo **plan** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps` = `\"analyze\"`, `result.steps` = `\"plan\"`",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `plan` corretamente",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "plan",
        "path": "result.steps"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "generatePlan"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - autoQualityRun > should execute scaffold mode (analyze + plan + scaffold)",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue . **Valida√ß√µes**: `result.ok` = `true`, `result.steps` = `\"analyze\"`, `result.steps` = `\"plan\"` e mais 1",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `desconhecido` corretamente",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "plan",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "scaffold-unit",
        "path": "result.steps"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "scaffoldUnitTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - autoQualityRun > should skip scaffold if tests already exist",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue skip scaffold if tests already exist. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - autoQualityRun > should execute full mode (all steps)",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue executar corretamente o modo **full** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps` = `\"analyze\"`, `result.steps` = `\"plan\"` e mais 4",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `full` corretamente",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "plan",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "code-analysis-report",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test-plan-report",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "coverage",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "dashboard",
        "path": "result.steps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - autoQualityRun > should skip run if skipRun is true",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue skip run if skipRun is true. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - autoQualityRun > should handle errors gracefully",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue handle errors gracefully. **Valida√ß√µes**: `result.ok` = `false`, `result.steps` = `\"[...]\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toEqual. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.steps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should execute analyze mode successfully",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue executar corretamente o modo **analyze** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps` = `\"analyze\"`, `analyze` = `\"{...}\"`",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `analyze` corretamente",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "{...}",
        "path": "analyze"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should execute plan mode (analyze + plan)",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue executar corretamente o modo **plan** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps` = `\"analyze\"`, `result.steps` = `\"plan\"`",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `plan` corretamente",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "plan",
        "path": "result.steps"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "generatePlan"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should execute scaffold mode (analyze + plan + scaffold)",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue . **Valida√ß√µes**: `result.ok` = `true`, `result.steps` = `\"analyze\"`, `result.steps` = `\"plan\"` e mais 1",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `desconhecido` corretamente",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "plan",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "scaffold-unit",
        "path": "result.steps"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "scaffoldUnitTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should skip scaffold if tests already exist",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue skip scaffold if tests already exist. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should execute full mode (all steps)",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue executar corretamente o modo **full** (an√°lise completa do sistema). **Valida√ß√µes**: `result.ok` = `true`, `result.steps` = `\"analyze\"`, `result.steps` = `\"plan\"` e mais 4",
    "whyItTests": "Valida que o pipeline **`auto.ts`** executa todas as fases do modo `full` corretamente",
    "purposeForWhat": "üîí **Confiabilidade**: Garantir que o pipeline completo funciona ponta-a-ponta sem falhas silenciosas\n- üìâ **CFR**: Prevenir deploys de vers√µes com pipelines quebrados (todos os passos devem executar)\n- ‚è±Ô∏è **MTTR**: Se algo falhar em produ√ß√£o, testes E2E ajudam a reproduzir o problema rapidamente\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "plan",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "code-analysis-report",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test-plan-report",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "coverage",
        "path": "result.steps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "dashboard",
        "path": "result.steps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should skip run if skipRun is true",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue skip run if skipRun is true. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should handle errors gracefully",
    "testType": "unit",
    "functionUnderTest": "autoQualityRun",
    "whatItTests": "Valida que **`autoQualityRun`** consegue handle errors gracefully. **Valida√ß√µes**: `result.ok` = `false`, `result.steps` = `\"[...]\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toEqual. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "autoQualityRun",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.steps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - runAutoMode > should return true on successful run",
    "testType": "unit",
    "functionUnderTest": "runAutoMode",
    "whatItTests": "Valida que **`runAutoMode`** consegue return true on successful run. **Valida√ß√µes**: `success` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runAutoMode",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "auto.ts - runAutoMode > should return false on failed run",
    "testType": "unit",
    "functionUnderTest": "runAutoMode",
    "whatItTests": "Valida que **`runAutoMode`** consegue return false on failed run. **Valida√ß√µes**: `success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runAutoMode",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should return true on successful run",
    "testType": "unit",
    "functionUnderTest": "runAutoMode",
    "whatItTests": "Valida que **`runAutoMode`** consegue return true on successful run. **Valida√ß√µes**: `success` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runAutoMode",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/auto.test.ts",
    "name": "should return false on failed run",
    "testType": "unit",
    "functionUnderTest": "runAutoMode",
    "whatItTests": "Valida que **`runAutoMode`** consegue return false on failed run. **Valida√ß√µes**: `success` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "success = ..."
    ],
    "when": "runAutoMode",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "success"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "analyze > deve encontrar rotas Next.js e classificar como medium risk",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue encontrar rotas Next.js e classificar como medium risk. **Valida√ß√µes**: `result.findings.routes` = `\"/\"`, `result.findings.routes` = `\"/about\"`, `result.summary` = `\"2 rotas web\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "routeRisks = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/",
        "path": "result.findings.routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/about",
        "path": "result.findings.routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "2 rotas web",
        "path": "result.summary"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "routeRisks.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "analyze > deve encontrar endpoints Express e sugerir CDC",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue encontrar endpoints Express e sugerir CDC. **Valida√ß√µes**: `result.findings.endpoints` = `2`, `result.findings.endpoints` = `\"GET /api/users\"`, `result.findings.endpoints` = `\"POST /api/users\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "hasCDCRecommendation = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "result.findings.endpoints"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "GET /api/users",
        "path": "result.findings.endpoints"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "POST /api/users",
        "path": "result.findings.endpoints"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasCDCRecommendation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "analyze > deve encontrar eventos e mapear riscos",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue encontrar eventos e mapear riscos. **Valida√ß√µes**: `result.findings.events` = `2`, `result.findings.events` = `\"kafka:user-created\"`, `result.findings.events` = `\"event:order-placed\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "eventRisks = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "result.findings.events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:user-created",
        "path": "result.findings.events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:order-placed",
        "path": "result.findings.events"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "eventRisks.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "eventRisks.every()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "analyze > deve gerar recomenda√ß√µes baseadas nos findings",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar recomenda√ß√µes baseadas nos findings. **Valida√ß√µes**: `result.recommendations.length` = `0`, `hasE2ERecommendation` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "hasE2ERecommendation = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasE2ERecommendation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "analyze > deve salvar resultado em tests/analyses/analyze.json",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue salvar resultado em tests/analyses/analyze.json. **Valida√ß√µes**: `fileExists` = `true`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "analyzeJsonPath = ...",
      "fileExists = ...",
      "content = ...",
      "data = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "fileExists"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "data.summary"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "data.findings"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "data.recommendations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "analyze > deve lidar com reposit√≥rio sem c√≥digo",
    "testType": "unit",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue lidar com reposit√≥rio sem c√≥digo. **Valida√ß√µes**: `result.findings.routes` = `\"[...]\"`, `result.findings.endpoints` = `\"[...]\"`, `result.findings.events` = `\"[...]\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toEqual, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.findings.routes"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.findings.endpoints"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.findings.events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0 rotas web",
        "path": "result.summary"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0 endpoints",
        "path": "result.summary"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0 eventos",
        "path": "result.summary"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "analyze > deve marcar rotas cr√≠ticas como high risk",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue marcar rotas cr√≠ticas como high risk. **Valida√ß√µes**: `unknown` = `\"high\"`, `unknown` = `\"fluxo cr√≠tico\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "loginRisk = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "loginRisk"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "fluxo cr√≠tico",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "analyze > deve reduzir risco de endpoints quando OpenAPI est√° presente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue reduzir risco de endpoints quando OpenAPI est√° presente. **Valida√ß√µes**: `unknown` = `\"low\"`, `unknown` = `\"contrato OpenAPI\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "endpointRisk = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "endpointRisk"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "low",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "contrato OpenAPI",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "deve encontrar rotas Next.js e classificar como medium risk",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue encontrar rotas Next.js e classificar como medium risk. **Valida√ß√µes**: `result.findings.routes` = `\"/\"`, `result.findings.routes` = `\"/about\"`, `result.summary` = `\"2 rotas web\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "routeRisks = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/",
        "path": "result.findings.routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/about",
        "path": "result.findings.routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "2 rotas web",
        "path": "result.summary"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "routeRisks.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "deve encontrar endpoints Express e sugerir CDC",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue encontrar endpoints Express e sugerir CDC. **Valida√ß√µes**: `result.findings.endpoints` = `2`, `result.findings.endpoints` = `\"GET /api/users\"`, `result.findings.endpoints` = `\"POST /api/users\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "hasCDCRecommendation = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "result.findings.endpoints"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "GET /api/users",
        "path": "result.findings.endpoints"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "POST /api/users",
        "path": "result.findings.endpoints"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasCDCRecommendation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "deve encontrar eventos e mapear riscos",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue encontrar eventos e mapear riscos. **Valida√ß√µes**: `result.findings.events` = `2`, `result.findings.events` = `\"kafka:user-created\"`, `result.findings.events` = `\"event:order-placed\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toContain, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "eventRisks = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "result.findings.events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:user-created",
        "path": "result.findings.events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:order-placed",
        "path": "result.findings.events"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "eventRisks.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "eventRisks.every()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "deve gerar recomenda√ß√µes baseadas nos findings",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar recomenda√ß√µes baseadas nos findings. **Valida√ß√µes**: `result.recommendations.length` = `0`, `hasE2ERecommendation` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "hasE2ERecommendation = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasE2ERecommendation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "deve salvar resultado em tests/analyses/analyze.json",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue salvar resultado em tests/analyses/analyze.json. **Valida√ß√µes**: `fileExists` = `true`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "analyzeJsonPath = ...",
      "fileExists = ...",
      "content = ...",
      "data = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "fileExists"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "data.summary"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "data.findings"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "data.recommendations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "deve lidar com reposit√≥rio sem c√≥digo",
    "testType": "unit",
    "functionUnderTest": "analyze",
    "whatItTests": "Valida que **`analyze`** consegue lidar com reposit√≥rio sem c√≥digo. **Valida√ß√µes**: `result.findings.routes` = `\"[...]\"`, `result.findings.endpoints` = `\"[...]\"`, `result.findings.events` = `\"[...]\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toEqual, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyze",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.findings.routes"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.findings.endpoints"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.findings.events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0 rotas web",
        "path": "result.summary"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0 endpoints",
        "path": "result.summary"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "0 eventos",
        "path": "result.summary"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "deve marcar rotas cr√≠ticas como high risk",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue marcar rotas cr√≠ticas como high risk. **Valida√ß√µes**: `unknown` = `\"high\"`, `unknown` = `\"fluxo cr√≠tico\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "loginRisk = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "loginRisk"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "high",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "fluxo cr√≠tico",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze.test.ts",
    "name": "deve reduzir risco de endpoints quando OpenAPI est√° presente",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue reduzir risco de endpoints quando OpenAPI est√° presente. **Valida√ß√µes**: `unknown` = `\"low\"`, `unknown` = `\"contrato OpenAPI\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "endpointRisk = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "endpointRisk"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "low",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "contrato OpenAPI",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Happy Path > should analyze TypeScript project with basic tests",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue analyze TypeScript project with basic tests. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"typescript\"`, `result.framework` = `\"Vitest\"` e mais 3",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toBeGreaterThan, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "addFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.functions.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "addFunc"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Happy Path > should detect framework automatically",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect framework automatically. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"Jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Happy Path > should calculate scenario coverage correctly",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue calculate scenario coverage correctly. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "validator = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should analyze TypeScript project with basic tests",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue analyze TypeScript project with basic tests. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"typescript\"`, `result.framework` = `\"Vitest\"` e mais 3",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toBeGreaterThan, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "addFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.functions.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "addFunc"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should detect framework automatically",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect framework automatically. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"Jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should calculate scenario coverage correctly",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue calculate scenario coverage correctly. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "validator = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle empty repository",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle empty repository. **Valida√ß√µes**: `result.ok` = `true`, `result.functions` = `\"[...]\"`, `result.metrics.qualityScore` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toEqual, toBeGreaterThanOrEqual. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.functions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.metrics.qualityScore"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle repository without tests",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle repository without tests. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"[...]\"`, `unknown` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toEqual. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "untestedFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle functions with weak assertions",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle functions with weak assertions. **Valida√ß√µes**: `unknown` = `0`, `unknown` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "getUserFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle null/undefined inputs gracefully",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle null/undefined inputs gracefully. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle very large codebase efficiently",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle very large codebase efficiently. **Valida√ß√µes**: `result.ok` = `true`, `result.functions.length` = `10`, `duration` = `10000`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThan. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "startTime = ...",
      "result = ...",
      "duration = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "result.functions.length"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 10000,
        "path": "duration"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle empty repository",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle empty repository. **Valida√ß√µes**: `result.ok` = `true`, `result.functions` = `\"[...]\"`, `result.metrics.qualityScore` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toEqual, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.functions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.metrics.qualityScore"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle repository without tests",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle repository without tests. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"[...]\"`, `unknown` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "untestedFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle functions with weak assertions",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle functions with weak assertions. **Valida√ß√µes**: `unknown` = `0`, `unknown` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "getUserFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle null/undefined inputs gracefully",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle null/undefined inputs gracefully. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle very large codebase efficiently",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle very large codebase efficiently. **Valida√ß√µes**: `result.ok` = `true`, `result.functions.length` = `10`, `duration` = `10000`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "startTime = ...",
      "result = ...",
      "duration = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "result.functions.length"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 10000,
        "path": "duration"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Error Handling > should handle invalid repository path",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle invalid repository path. **Valida√ß√µes**: `result.ok` = `true`, `result.functions` = `\"[...]\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toEqual. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.functions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Error Handling > should handle malformed source files",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle malformed source files. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Error Handling > should handle malformed test files",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle malformed test files. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Error Handling > should handle missing package.json",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle missing package.json. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"Unknown\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Unknown",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle invalid repository path",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle invalid repository path. **Valida√ß√µes**: `result.ok` = `true`, `result.functions` = `\"[...]\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toEqual. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.functions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle malformed source files",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle malformed source files. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle malformed test files",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle malformed test files. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should handle missing package.json",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle missing package.json. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"Unknown\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Unknown",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Side Effects > should generate patches when requested",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue generate patches when requested. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined, toHaveBeenCalled",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "consoleSpy = ...",
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.patches"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Side Effects > should write report to correct location",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue write report to correct location. **Valida√ß√µes**: `result.ok` = `true`, `result.reportPath` = `\"TEST-QUALITY-LOGICAL-REPORT.md\"`, `result.reportPath` = `\"testDir\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TEST-QUALITY-LOGICAL-REPORT.md",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "testDir",
        "path": "result.reportPath"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Side Effects > should log progress to console",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue log progress to console. **Valida√ß√µes**: `hasLogicLogs` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalled, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "consoleSpy = ...",
      "hasLogicLogs = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasLogicLogs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Side Effects > should create output directories if they do not exist",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue create output directories if they do not exist. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should generate patches when requested",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue generate patches when requested. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined, toHaveBeenCalled",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "consoleSpy = ...",
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.patches"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should write report to correct location",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue write report to correct location. **Valida√ß√µes**: `result.ok` = `true`, `result.reportPath` = `\"TEST-QUALITY-LOGICAL-REPORT.md\"`, `result.reportPath` = `\"testDir\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TEST-QUALITY-LOGICAL-REPORT.md",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "testDir",
        "path": "result.reportPath"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should log progress to console",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue log progress to console. **Valida√ß√µes**: `hasLogicLogs` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalled, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "consoleSpy = ...",
      "hasLogicLogs = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasLogicLogs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should create output directories if they do not exist",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue create output directories if they do not exist. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Multi-language Support > should detect Python projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Python projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"python\"`, `result.framework` = `\"Pytest\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Pytest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Multi-language Support > should detect Go projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Go projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"go\"`, `result.framework` = `\"go test\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Multi-language Support > should detect Java projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Java projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"java\"`, `result.framework` = `\"JUnit\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "JUnit",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should detect Python projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Python projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"python\"`, `result.framework` = `\"Pytest\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Pytest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should detect Go projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Go projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"go\"`, `result.framework` = `\"go test\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should detect Java projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Java projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"java\"`, `result.framework` = `\"JUnit\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "JUnit",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Quality Scoring > should calculate quality score based on coverage",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue calculate quality score based on coverage. **Valida√ß√µes**: `result.metrics.qualityScore` = `70`, `result.metrics.scenarioCoverage.happy` = `0`, `unknown` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 70,
        "path": "result.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.metrics.scenarioCoverage.happy"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "analyzeTestLogic > should calculate quality score based on coverage",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue calculate quality score based on coverage. **Valida√ß√µes**: `result.metrics.qualityScore` = `70`, `result.metrics.scenarioCoverage.happy` = `0`, `unknown` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 70,
        "path": "result.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.metrics.scenarioCoverage.happy"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Happy Path > should analyze TypeScript project with basic tests",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue analyze TypeScript project with basic tests. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"typescript\"`, `result.framework` = `\"Vitest\"` e mais 3",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toBeGreaterThan, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "addFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.functions.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "addFunc"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Happy Path > should detect framework automatically",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect framework automatically. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"Jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Happy Path > should calculate scenario coverage correctly",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue calculate scenario coverage correctly. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "validator = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should analyze TypeScript project with basic tests",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue analyze TypeScript project with basic tests. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"typescript\"`, `result.framework` = `\"Vitest\"` e mais 3",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toBeGreaterThan, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "addFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.functions.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "addFunc"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should detect framework automatically",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect framework automatically. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"Jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should calculate scenario coverage correctly",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue calculate scenario coverage correctly. **Valida√ß√µes**: `unknown` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "validator = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle empty repository",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle empty repository. **Valida√ß√µes**: `result.ok` = `true`, `result.functions` = `\"[...]\"`, `result.metrics.qualityScore` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toEqual, toBeGreaterThanOrEqual. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.functions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.metrics.qualityScore"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle repository without tests",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle repository without tests. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"[...]\"`, `unknown` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toEqual. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "untestedFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle functions with weak assertions",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle functions with weak assertions. **Valida√ß√µes**: `unknown` = `0`, `unknown` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "getUserFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle null/undefined inputs gracefully",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle null/undefined inputs gracefully. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Edge Cases > should handle very large codebase efficiently",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle very large codebase efficiently. **Valida√ß√µes**: `result.ok` = `true`, `result.functions.length` = `10`, `duration` = `10000`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThan. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "startTime = ...",
      "result = ...",
      "duration = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "result.functions.length"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 10000,
        "path": "duration"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle empty repository",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle empty repository. **Valida√ß√µes**: `result.ok` = `true`, `result.functions` = `\"[...]\"`, `result.metrics.qualityScore` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toEqual, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.functions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.metrics.qualityScore"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle repository without tests",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle repository without tests. **Valida√ß√µes**: `result.ok` = `true`, `unknown` = `\"[...]\"`, `unknown` = `false`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "untestedFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle functions with weak assertions",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle functions with weak assertions. **Valida√ß√µes**: `unknown` = `0`, `unknown` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "getUserFunc = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle null/undefined inputs gracefully",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle null/undefined inputs gracefully. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle very large codebase efficiently",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle very large codebase efficiently. **Valida√ß√µes**: `result.ok` = `true`, `result.functions.length` = `10`, `duration` = `10000`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "startTime = ...",
      "result = ...",
      "duration = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 10,
        "path": "result.functions.length"
      },
      {
        "type": "value",
        "matcher": "toBeLessThan",
        "value": 10000,
        "path": "duration"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Error Handling > should handle invalid repository path",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle invalid repository path. **Valida√ß√µes**: `result.ok` = `true`, `result.functions` = `\"[...]\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toEqual. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.functions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Error Handling > should handle malformed source files",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle malformed source files. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Error Handling > should handle malformed test files",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle malformed test files. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Error Handling > should handle missing package.json",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle missing package.json. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"Unknown\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Unknown",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle invalid repository path",
    "testType": "unit",
    "functionUnderTest": "analyzeTestLogic",
    "whatItTests": "Valida que **`analyzeTestLogic`** consegue handle invalid repository path. **Valida√ß√µes**: `result.ok` = `true`, `result.functions` = `\"[...]\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeDefined, toBe, toEqual. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "analyzeTestLogic",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.functions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle malformed source files",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle malformed source files. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle malformed test files",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle malformed test files. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should handle missing package.json",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue handle missing package.json. **Valida√ß√µes**: `result.ok` = `true`, `result.framework` = `\"Unknown\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Unknown",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Side Effects > should generate patches when requested",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue generate patches when requested. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined, toHaveBeenCalled",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "consoleSpy = ...",
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.patches"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Side Effects > should write report to correct location",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue write report to correct location. **Valida√ß√µes**: `result.ok` = `true`, `result.reportPath` = `\"TEST-QUALITY-LOGICAL-REPORT.md\"`, `result.reportPath` = `\"testDir\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TEST-QUALITY-LOGICAL-REPORT.md",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "testDir",
        "path": "result.reportPath"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Side Effects > should log progress to console",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue log progress to console. **Valida√ß√µes**: `hasLogicLogs` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalled, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "consoleSpy = ...",
      "hasLogicLogs = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasLogicLogs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Side Effects > should create output directories if they do not exist",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue create output directories if they do not exist. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should generate patches when requested",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue generate patches when requested. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeDefined, toHaveBeenCalled",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "consoleSpy = ...",
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.patches"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should write report to correct location",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue write report to correct location. **Valida√ß√µes**: `result.ok` = `true`, `result.reportPath` = `\"TEST-QUALITY-LOGICAL-REPORT.md\"`, `result.reportPath` = `\"testDir\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "TEST-QUALITY-LOGICAL-REPORT.md",
        "path": "result.reportPath"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "testDir",
        "path": "result.reportPath"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should log progress to console",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue log progress to console. **Valida√ß√µes**: `hasLogicLogs` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveBeenCalled, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "consoleSpy = ...",
      "hasLogicLogs = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "consoleSpy"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasLogicLogs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should create output directories if they do not exist",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue create output directories if they do not exist. **Valida√ß√µes**: `result.ok` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Multi-language Support > should detect Python projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Python projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"python\"`, `result.framework` = `\"Pytest\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Pytest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Multi-language Support > should detect Go projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Go projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"go\"`, `result.framework` = `\"go test\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Multi-language Support > should detect Java projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Java projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"java\"`, `result.framework` = `\"JUnit\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "JUnit",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should detect Python projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Python projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"python\"`, `result.framework` = `\"Pytest\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Pytest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should detect Go projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Go projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"go\"`, `result.framework` = `\"go test\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should detect Java projects",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue detect Java projects. **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"java\"`, `result.framework` = `\"JUnit\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "JUnit",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "Quality Scoring > should calculate quality score based on coverage",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue calculate quality score based on coverage. **Valida√ß√µes**: `result.metrics.qualityScore` = `70`, `result.metrics.scenarioCoverage.happy` = `0`, `unknown` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 70,
        "path": "result.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.metrics.scenarioCoverage.happy"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/tools/__tests__/analyze-test-logic.test.ts",
    "name": "should calculate quality score based on coverage",
    "testType": "unit",
    "functionUnderTest": "mkdir",
    "whatItTests": "Valida que **`mkdir`** consegue calculate quality score based on coverage. **Valida√ß√µes**: `result.metrics.qualityScore` = `70`, `result.metrics.scenarioCoverage.happy` = `0`, `unknown` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 70,
        "path": "result.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.metrics.scenarioCoverage.happy"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve parsear relat√≥rio LCOV corretamente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue parsear relat√≥rio LCOV corretamente. **Valida√ß√µes**: `result.files.size` = `2`, `result.totalLines` = `8`, `result.coveredLines` = `6` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.files.size"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "result.coveredLines"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 75,
        "path": "result.coverage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve extrair linhas cobertas corretamente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue extrair linhas cobertas corretamente. **Valida√ß√µes**: `unknown.lines` = `5`, `unknown.totalLines` = `5`, `unknown.coveredLines` = `4`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "mathFile = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "mathFile"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "unknown.lines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "unknown.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "unknown.coveredLines"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve marcar linhas n√£o cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue marcar linhas n√£o cobertas. **Valida√ß√µes**: `unknown` = `false`, `unknown` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "mathFile = ...",
      "line3 = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve marcar linhas cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue marcar linhas cobertas. **Valida√ß√µes**: `unknown` = `true`, `unknown` = `10`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "mathFile = ...",
      "line1 = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 10,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve lidar com LCOV vazio",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue lidar com LCOV vazio. **Valida√ß√µes**: `result.files.size` = `0`, `result.totalLines` = `0`, `result.coverage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.files.size"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.coverage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve parsear relat√≥rio LCOV corretamente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue parsear relat√≥rio LCOV corretamente. **Valida√ß√µes**: `result.files.size` = `2`, `result.totalLines` = `8`, `result.coveredLines` = `6` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.files.size"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "result.coveredLines"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 75,
        "path": "result.coverage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve extrair linhas cobertas corretamente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue extrair linhas cobertas corretamente. **Valida√ß√µes**: `unknown.lines` = `5`, `unknown.totalLines` = `5`, `unknown.coveredLines` = `4`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "mathFile = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "mathFile"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "unknown.lines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "unknown.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "unknown.coveredLines"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve marcar linhas n√£o cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue marcar linhas n√£o cobertas. **Valida√ß√µes**: `unknown` = `false`, `unknown` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "mathFile = ...",
      "line3 = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve marcar linhas cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue marcar linhas cobertas. **Valida√ß√µes**: `unknown` = `true`, `unknown` = `10`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "mathFile = ...",
      "line1 = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 10,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve lidar com LCOV vazio",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue lidar com LCOV vazio. **Valida√ß√µes**: `result.files.size` = `0`, `result.totalLines` = `0`, `result.coverage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.files.size"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.coverage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "isLineCovered > deve identificar linha coberta",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue identificar linha coberta. **Valida√ß√µes**: `isLineCovered()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "isLineCovered > deve identificar linha n√£o coberta",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue identificar linha n√£o coberta. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "isLineCovered > deve retornar false para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar false para arquivo inexistente. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "isLineCovered > deve retornar false para linha inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar false para linha inexistente. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve identificar linha coberta",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue identificar linha coberta. **Valida√ß√µes**: `isLineCovered()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve identificar linha n√£o coberta",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue identificar linha n√£o coberta. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve retornar false para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar false para arquivo inexistente. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve retornar false para linha inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar false para linha inexistente. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "calculateLineCoverage > deve calcular coverage exato para linhas espec√≠ficas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage exato para linhas espec√≠ficas. **Valida√ß√µes**: `result.total` = `4`, `result.covered` = `4`, `result.percentage` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "calculateLineCoverage > deve calcular coverage com linhas n√£o cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage com linhas n√£o cobertas. **Valida√ß√µes**: `result.total` = `3`, `result.covered` = `2`, `result.percentage` = `66.67`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 66.67,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "calculateLineCoverage > deve retornar 0 para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar 0 para arquivo inexistente. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "calculateLineCoverage > deve retornar 0 para lista de linhas vazia",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar 0 para lista de linhas vazia. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve calcular coverage exato para linhas espec√≠ficas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage exato para linhas espec√≠ficas. **Valida√ß√µes**: `result.total` = `4`, `result.covered` = `4`, `result.percentage` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve calcular coverage com linhas n√£o cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage com linhas n√£o cobertas. **Valida√ß√µes**: `result.total` = `3`, `result.covered` = `2`, `result.percentage` = `66.67`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 66.67,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve retornar 0 para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar 0 para arquivo inexistente. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve retornar 0 para lista de linhas vazia",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar 0 para lista de linhas vazia. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "normalizeFilePath > deve remover prefixo src/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue remover prefixo src/. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "normalizeFilePath > deve remover prefixo ./",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue remover prefixo ./. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "normalizeFilePath > deve converter backslash para slash",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue converter backslash para slash. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "normalizeFilePath > deve lidar com m√∫ltiplos prefixos",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue lidar com m√∫ltiplos prefixos. **Valida√ß√µes**: `normalizeFilePath()` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve remover prefixo src/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue remover prefixo src/. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve remover prefixo ./",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue remover prefixo ./. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve converter backslash para slash",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue converter backslash para slash. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve lidar com m√∫ltiplos prefixos",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue lidar com m√∫ltiplos prefixos. **Valida√ß√µes**: `normalizeFilePath()` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "findFileInReport > deve encontrar arquivo por match exato",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por match exato. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "findFileInReport > deve encontrar arquivo por match normalizado",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por match normalizado. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "findFileInReport > deve encontrar arquivo por basename",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por basename. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "findFileInReport > deve retornar null para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar null para arquivo inexistente. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve encontrar arquivo por match exato",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por match exato. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve encontrar arquivo por match normalizado",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por match normalizado. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve encontrar arquivo por basename",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por basename. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve retornar null para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar null para arquivo inexistente. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "Integra√ß√£o Diff Coverage > deve calcular coverage preciso para diff simulado",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage preciso para diff simulado. **Valida√ß√µes**: `result.total` = `3`, `result.covered` = `2`, `result.percentage` = `66.67`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 66.67,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "Integra√ß√£o Diff Coverage > deve calcular 0% para arquivo sem coverage",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular 0% para arquivo sem coverage. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "Integra√ß√£o Diff Coverage > deve calcular 100% para linhas totalmente cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular 100% para linhas totalmente cobertas. **Valida√ß√µes**: `result.total` = `2`, `result.covered` = `2`, `result.percentage` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve calcular coverage preciso para diff simulado",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage preciso para diff simulado. **Valida√ß√µes**: `result.total` = `3`, `result.covered` = `2`, `result.percentage` = `66.67`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 66.67,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve calcular 0% para arquivo sem coverage",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular 0% para arquivo sem coverage. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "LCOV Line Parser > deve calcular 100% para linhas totalmente cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular 100% para linhas totalmente cobertas. **Valida√ß√µes**: `result.total` = `2`, `result.covered` = `2`, `result.percentage` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve parsear relat√≥rio LCOV corretamente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue parsear relat√≥rio LCOV corretamente. **Valida√ß√µes**: `result.files.size` = `2`, `result.totalLines` = `8`, `result.coveredLines` = `6` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.files.size"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "result.coveredLines"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 75,
        "path": "result.coverage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve extrair linhas cobertas corretamente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue extrair linhas cobertas corretamente. **Valida√ß√µes**: `unknown.lines` = `5`, `unknown.totalLines` = `5`, `unknown.coveredLines` = `4`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "mathFile = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "mathFile"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "unknown.lines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "unknown.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "unknown.coveredLines"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve marcar linhas n√£o cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue marcar linhas n√£o cobertas. **Valida√ß√µes**: `unknown` = `false`, `unknown` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "mathFile = ...",
      "line3 = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve marcar linhas cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue marcar linhas cobertas. **Valida√ß√µes**: `unknown` = `true`, `unknown` = `10`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "mathFile = ...",
      "line1 = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 10,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "parseLCOV > deve lidar com LCOV vazio",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue lidar com LCOV vazio. **Valida√ß√µes**: `result.files.size` = `0`, `result.totalLines` = `0`, `result.coverage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.files.size"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.coverage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve parsear relat√≥rio LCOV corretamente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue parsear relat√≥rio LCOV corretamente. **Valida√ß√µes**: `result.files.size` = `2`, `result.totalLines` = `8`, `result.coveredLines` = `6` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe, toBeCloseTo. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.files.size"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 8,
        "path": "result.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "result.coveredLines"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 75,
        "path": "result.coverage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve extrair linhas cobertas corretamente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue extrair linhas cobertas corretamente. **Valida√ß√µes**: `unknown.lines` = `5`, `unknown.totalLines` = `5`, `unknown.coveredLines` = `4`",
    "whyItTests": "Valida 4 aspecto(s) usando: toBeDefined, toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "mathFile = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "mathFile"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "unknown.lines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "unknown.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "unknown.coveredLines"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve marcar linhas n√£o cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue marcar linhas n√£o cobertas. **Valida√ß√µes**: `unknown` = `false`, `unknown` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "mathFile = ...",
      "line3 = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve marcar linhas cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue marcar linhas cobertas. **Valida√ß√µes**: `unknown` = `true`, `unknown` = `10`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ...",
      "mathFile = ...",
      "line1 = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 10,
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve lidar com LCOV vazio",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue lidar com LCOV vazio. **Valida√ß√µes**: `result.files.size` = `0`, `result.totalLines` = `0`, `result.coverage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.files.size"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.totalLines"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.coverage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "isLineCovered > deve identificar linha coberta",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue identificar linha coberta. **Valida√ß√µes**: `isLineCovered()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "isLineCovered > deve identificar linha n√£o coberta",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue identificar linha n√£o coberta. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "isLineCovered > deve retornar false para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar false para arquivo inexistente. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "isLineCovered > deve retornar false para linha inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar false para linha inexistente. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve identificar linha coberta",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue identificar linha coberta. **Valida√ß√µes**: `isLineCovered()` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve identificar linha n√£o coberta",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue identificar linha n√£o coberta. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve retornar false para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar false para arquivo inexistente. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve retornar false para linha inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar false para linha inexistente. **Valida√ß√µes**: `isLineCovered()` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "isLineCovered()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "calculateLineCoverage > deve calcular coverage exato para linhas espec√≠ficas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage exato para linhas espec√≠ficas. **Valida√ß√µes**: `result.total` = `4`, `result.covered` = `4`, `result.percentage` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "calculateLineCoverage > deve calcular coverage com linhas n√£o cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage com linhas n√£o cobertas. **Valida√ß√µes**: `result.total` = `3`, `result.covered` = `2`, `result.percentage` = `66.67`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 66.67,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "calculateLineCoverage > deve retornar 0 para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar 0 para arquivo inexistente. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "calculateLineCoverage > deve retornar 0 para lista de linhas vazia",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar 0 para lista de linhas vazia. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve calcular coverage exato para linhas espec√≠ficas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage exato para linhas espec√≠ficas. **Valida√ß√µes**: `result.total` = `4`, `result.covered` = `4`, `result.percentage` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 4,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve calcular coverage com linhas n√£o cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage com linhas n√£o cobertas. **Valida√ß√µes**: `result.total` = `3`, `result.covered` = `2`, `result.percentage` = `66.67`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 66.67,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve retornar 0 para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar 0 para arquivo inexistente. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve retornar 0 para lista de linhas vazia",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar 0 para lista de linhas vazia. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "normalizeFilePath > deve remover prefixo src/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue remover prefixo src/. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "normalizeFilePath > deve remover prefixo ./",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue remover prefixo ./. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "normalizeFilePath > deve converter backslash para slash",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue converter backslash para slash. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "normalizeFilePath > deve lidar com m√∫ltiplos prefixos",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue lidar com m√∫ltiplos prefixos. **Valida√ß√µes**: `normalizeFilePath()` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve remover prefixo src/",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue remover prefixo src/. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve remover prefixo ./",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue remover prefixo ./. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve converter backslash para slash",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue converter backslash para slash. **Valida√ß√µes**: `normalizeFilePath()` = `\"utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve lidar com m√∫ltiplos prefixos",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue lidar com m√∫ltiplos prefixos. **Valida√ß√µes**: `normalizeFilePath()` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "normalizeFilePath()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "findFileInReport > deve encontrar arquivo por match exato",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por match exato. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "findFileInReport > deve encontrar arquivo por match normalizado",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por match normalizado. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "findFileInReport > deve encontrar arquivo por basename",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por basename. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "findFileInReport > deve retornar null para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar null para arquivo inexistente. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve encontrar arquivo por match exato",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por match exato. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve encontrar arquivo por match normalizado",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por match normalizado. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve encontrar arquivo por basename",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue encontrar arquivo por basename. **Valida√ß√µes**: `found` = `\"src/utils/math.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "src/utils/math.ts",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve retornar null para arquivo inexistente",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue retornar null para arquivo inexistente. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "report = ...",
      "found = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "found"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "Integra√ß√£o Diff Coverage > deve calcular coverage preciso para diff simulado",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage preciso para diff simulado. **Valida√ß√µes**: `result.total` = `3`, `result.covered` = `2`, `result.percentage` = `66.67`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 66.67,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "Integra√ß√£o Diff Coverage > deve calcular 0% para arquivo sem coverage",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular 0% para arquivo sem coverage. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "Integra√ß√£o Diff Coverage > deve calcular 100% para linhas totalmente cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular 100% para linhas totalmente cobertas. **Valida√ß√µes**: `result.total` = `2`, `result.covered` = `2`, `result.percentage` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve calcular coverage preciso para diff simulado",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular coverage preciso para diff simulado. **Valida√ß√µes**: `result.total` = `3`, `result.covered` = `2`, `result.percentage` = `66.67`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeCloseTo",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBeCloseTo",
        "value": 66.67,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve calcular 0% para arquivo sem coverage",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular 0% para arquivo sem coverage. **Valida√ß√µes**: `result.total` = `0`, `result.covered` = `0`, `result.percentage` = `0`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/parsers/__tests__/lcov-line-parser.test.ts",
    "name": "deve calcular 100% para linhas totalmente cobertas",
    "testType": "unit",
    "functionUnderTest": "parseLCOV",
    "whatItTests": "Valida que **`parseLCOV`** consegue calcular 100% para linhas totalmente cobertas. **Valida√ß√µes**: `result.total` = `2`, `result.covered` = `2`, `result.percentage` = `100`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "report = ...",
      "diffLines = ...",
      "result = ..."
    ],
    "when": "parseLCOV",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.total"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "result.covered"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 100,
        "path": "result.percentage"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "findExistingTests > deve detectar arquivos *.test.ts com vitest",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar arquivos *.test.ts com vitest. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.unit.?.framework` = `\"vitest\"`, `coverage.unit.?.testCount` = `2` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "coverage.unit.?.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.unit.?.testCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.summary.unitCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "findExistingTests > deve detectar arquivos *.spec.ts com jest",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar arquivos *.spec.ts com jest. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.unit.?.framework` = `\"jest\"`, `coverage.unit.?.testCount` = `2`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "coverage.unit.?.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.unit.?.testCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "findExistingTests > deve detectar arquivos *Test.ts com mocha",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar arquivos *Test.ts com mocha. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.unit.?.framework` = `\"mocha\"`, `coverage.unit.?.testCount` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mocha",
        "path": "coverage.unit.?.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "coverage.unit.?.testCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "findExistingTests > deve detectar testes Playwright em tests/",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar testes Playwright em tests/. **Valida√ß√µes**: `coverage.e2e` = `1`, `coverage.e2e.?.framework` = `\"playwright\"`, `coverage.e2e.?.testCount` = `2` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.e2e"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "playwright",
        "path": "coverage.e2e.?.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.e2e.?.testCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.summary.e2eCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "findExistingTests > deve separar testes por camada corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue separar testes por camada corretamente. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.integration` = `1`, `coverage.e2e` = `1` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.integration"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.e2e"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "coverage.summary.totalTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "findExistingTests > deve contar n√∫mero de test cases por arquivo",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue contar n√∫mero de test cases por arquivo. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.unit.?.testCount` = `5`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "coverage.unit.?.testCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "findExistingTests > deve retornar estrutura vazia se n√£o houver testes",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue retornar estrutura vazia se n√£o houver testes. **Valida√ß√µes**: `coverage.unit` = `\"[...]\"`, `coverage.integration` = `\"[...]\"`, `coverage.e2e` = `\"[...]\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toEqual, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "coverage.integration"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "coverage.e2e"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "coverage.summary.totalTests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "0:0:0",
        "path": "coverage.summary.ratio"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "findExistingTests > deve calcular ratio da pir√¢mide corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue calcular ratio da pir√¢mide corretamente. **Valida√ß√µes**: `coverage.summary.unitCount` = `7`, `coverage.summary.integrationCount` = `2`, `coverage.summary.e2eCount` = `1` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 7,
        "path": "coverage.summary.unitCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.summary.integrationCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "coverage.summary.e2eCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "70:20:10",
        "path": "coverage.summary.ratio"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve detectar arquivos *.test.ts com vitest",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar arquivos *.test.ts com vitest. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.unit.?.framework` = `\"vitest\"`, `coverage.unit.?.testCount` = `2` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "coverage.unit.?.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.unit.?.testCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.summary.unitCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve detectar arquivos *.spec.ts com jest",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar arquivos *.spec.ts com jest. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.unit.?.framework` = `\"jest\"`, `coverage.unit.?.testCount` = `2`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "coverage.unit.?.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.unit.?.testCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve detectar arquivos *Test.ts com mocha",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar arquivos *Test.ts com mocha. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.unit.?.framework` = `\"mocha\"`, `coverage.unit.?.testCount` = `1`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mocha",
        "path": "coverage.unit.?.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "coverage.unit.?.testCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve detectar testes Playwright em tests/",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar testes Playwright em tests/. **Valida√ß√µes**: `coverage.e2e` = `1`, `coverage.e2e.?.framework` = `\"playwright\"`, `coverage.e2e.?.testCount` = `2` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.e2e"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "playwright",
        "path": "coverage.e2e.?.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.e2e.?.testCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.summary.e2eCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve separar testes por camada corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue separar testes por camada corretamente. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.integration` = `1`, `coverage.e2e` = `1` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.integration"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.e2e"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "coverage.summary.totalTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve contar n√∫mero de test cases por arquivo",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue contar n√∫mero de test cases por arquivo. **Valida√ß√µes**: `coverage.unit` = `1`, `coverage.unit.?.testCount` = `5`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 5,
        "path": "coverage.unit.?.testCount"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve retornar estrutura vazia se n√£o houver testes",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue retornar estrutura vazia se n√£o houver testes. **Valida√ß√µes**: `coverage.unit` = `\"[...]\"`, `coverage.integration` = `\"[...]\"`, `coverage.e2e` = `\"[...]\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toEqual, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "coverage.unit"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "coverage.integration"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "coverage.e2e"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "coverage.summary.totalTests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "0:0:0",
        "path": "coverage.summary.ratio"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve calcular ratio da pir√¢mide corretamente",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue calcular ratio da pir√¢mide corretamente. **Valida√ß√µes**: `coverage.summary.unitCount` = `7`, `coverage.summary.integrationCount` = `2`, `coverage.summary.e2eCount` = `1` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 7,
        "path": "coverage.summary.unitCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 2,
        "path": "coverage.summary.integrationCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 1,
        "path": "coverage.summary.e2eCount"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "70:20:10",
        "path": "coverage.summary.ratio"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "isPyramidHealthy > deve marcar como saud√°vel se propor√ß√µes est√£o corretas",
    "testType": "unit",
    "functionUnderTest": "isPyramidHealthy",
    "whatItTests": "Valida que **`isPyramidHealthy`** consegue marcar como saud√°vel se propor√ß√µes est√£o corretas. **Valida√ß√µes**: `result.healthy` = `true`, `result.issues` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverage = ...",
      "result = ..."
    ],
    "when": "isPyramidHealthy",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.healthy"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result.issues"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "isPyramidHealthy > deve alertar se E2E > unit (pir√¢mide invertida)",
    "testType": "unit",
    "functionUnderTest": "isPyramidHealthy",
    "whatItTests": "Valida que **`isPyramidHealthy`** consegue alertar se E2E > unit (pir√¢mide invertida). **Valida√ß√µes**: `result.healthy` = `false`, `result.issues` = `\"‚ö†Ô∏è Pir√¢mide INVERTIDA: mais testes E2E que unit√°rios\"`, `result.recommendations` = `\"Priorize cria√ß√£o de testes unit√°rios para balancear a pir√¢mide\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "result = ..."
    ],
    "when": "isPyramidHealthy",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.healthy"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "‚ö†Ô∏è Pir√¢mide INVERTIDA: mais testes E2E que unit√°rios",
        "path": "result.issues"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Priorize cria√ß√£o de testes unit√°rios para balancear a pir√¢mide",
        "path": "result.recommendations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "isPyramidHealthy > deve alertar se unit < 50%",
    "testType": "unit",
    "functionUnderTest": "isPyramidHealthy",
    "whatItTests": "Valida que **`isPyramidHealthy`** consegue alertar se unit < 50%. **Valida√ß√µes**: `result.healthy` = `false`, `result.issues.some()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverage = ...",
      "result = ..."
    ],
    "when": "isPyramidHealthy",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.healthy"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.issues.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "isPyramidHealthy > deve alertar se n√£o houver testes",
    "testType": "unit",
    "functionUnderTest": "isPyramidHealthy",
    "whatItTests": "Valida que **`isPyramidHealthy`** consegue alertar se n√£o houver testes. **Valida√ß√µes**: `result.healthy` = `false`, `result.issues` = `\"Nenhum teste detectado no reposit√≥rio\"`, `result.recommendations` = `\"Comece criando testes unit√°rios para fun√ß√µes cr√≠ticas\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "result = ..."
    ],
    "when": "isPyramidHealthy",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.healthy"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Nenhum teste detectado no reposit√≥rio",
        "path": "result.issues"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Comece criando testes unit√°rios para fun√ß√µes cr√≠ticas",
        "path": "result.recommendations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve marcar como saud√°vel se propor√ß√µes est√£o corretas",
    "testType": "unit",
    "functionUnderTest": "isPyramidHealthy",
    "whatItTests": "Valida que **`isPyramidHealthy`** consegue marcar como saud√°vel se propor√ß√µes est√£o corretas. **Valida√ß√µes**: `result.healthy` = `true`, `result.issues` = `0`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverage = ...",
      "result = ..."
    ],
    "when": "isPyramidHealthy",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.healthy"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "result.issues"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve alertar se E2E > unit (pir√¢mide invertida)",
    "testType": "unit",
    "functionUnderTest": "isPyramidHealthy",
    "whatItTests": "Valida que **`isPyramidHealthy`** consegue alertar se E2E > unit (pir√¢mide invertida). **Valida√ß√µes**: `result.healthy` = `false`, `result.issues` = `\"‚ö†Ô∏è Pir√¢mide INVERTIDA: mais testes E2E que unit√°rios\"`, `result.recommendations` = `\"Priorize cria√ß√£o de testes unit√°rios para balancear a pir√¢mide\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "result = ..."
    ],
    "when": "isPyramidHealthy",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.healthy"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "‚ö†Ô∏è Pir√¢mide INVERTIDA: mais testes E2E que unit√°rios",
        "path": "result.issues"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Priorize cria√ß√£o de testes unit√°rios para balancear a pir√¢mide",
        "path": "result.recommendations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve alertar se unit < 50%",
    "testType": "unit",
    "functionUnderTest": "isPyramidHealthy",
    "whatItTests": "Valida que **`isPyramidHealthy`** consegue alertar se unit < 50%. **Valida√ß√µes**: `result.healthy` = `false`, `result.issues.some()` = `true`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "coverage = ...",
      "result = ..."
    ],
    "when": "isPyramidHealthy",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.healthy"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.issues.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/tests.test.ts",
    "name": "deve alertar se n√£o houver testes",
    "testType": "unit",
    "functionUnderTest": "isPyramidHealthy",
    "whatItTests": "Valida que **`isPyramidHealthy`** consegue alertar se n√£o houver testes. **Valida√ß√µes**: `result.healthy` = `false`, `result.issues` = `\"Nenhum teste detectado no reposit√≥rio\"`, `result.recommendations` = `\"Comece criando testes unit√°rios para fun√ß√µes cr√≠ticas\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "result = ..."
    ],
    "when": "isPyramidHealthy",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.healthy"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Nenhum teste detectado no reposit√≥rio",
        "path": "result.issues"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Comece criando testes unit√°rios para fun√ß√µes cr√≠ticas",
        "path": "result.recommendations"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve detectar rotas no formato app/page.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar rotas no formato app/page.tsx. **Valida√ß√µes**: `routes` = `\"/\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve detectar rotas no formato pages/index.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar rotas no formato pages/index.tsx. **Valida√ß√µes**: `routes` = `\"/\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve detectar rotas din√¢micas [id]/page.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar rotas din√¢micas [id]/page.tsx. **Valida√ß√µes**: `routes` = `\"/users/[id]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/users/[id]",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve detectar rotas catch-all [...slug]/page.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar rotas catch-all [...slug]/page.tsx. **Valida√ß√µes**: `routes` = `\"/docs/[...slug]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/docs/[...slug]",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve ignorar route groups (app)/page.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue ignorar route groups (app)/page.tsx. **Valida√ß√µes**: `routes` = `\"/(marketing)/about\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/(marketing)/about",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve detectar API routes em app/api/route.ts",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar API routes em app/api/route.ts. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('findNextRoutes > deve detectar API routes em app/a...', () => {\n  const result = fs.mkdir(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('findNextRoutes > deve detectar API routes em app/a...', () => {\n  const result = fs.mkdir(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve retornar array vazio se diret√≥rio n√£o existir",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar array vazio se diret√≥rio n√£o existir. **Valida√ß√µes**: `routes` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nonExistentDir = ...",
      "routes = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve retornar todas as rotas encontradas",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue retornar todas as rotas encontradas. **Valida√ß√µes**: `routes` = `3`, `routes` = `\"/\"`, `routes` = `\"/about\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toContain, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/",
        "path": "routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/about",
        "path": "routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/contact",
        "path": "routes"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve converter rotas din√¢micas pages/[id].tsx para :id",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue converter rotas din√¢micas pages/[id].tsx para :id. **Valida√ß√µes**: `routes` = `\"/users/:id\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/users/:id",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "findNextRoutes > deve remover rotas duplicadas",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue remover rotas duplicadas. **Valida√ß√µes**: `homeRoutes` = `1`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ...",
      "homeRoutes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "homeRoutes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve detectar rotas no formato app/page.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar rotas no formato app/page.tsx. **Valida√ß√µes**: `routes` = `\"/\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve detectar rotas no formato pages/index.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar rotas no formato pages/index.tsx. **Valida√ß√µes**: `routes` = `\"/\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve detectar rotas din√¢micas [id]/page.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar rotas din√¢micas [id]/page.tsx. **Valida√ß√µes**: `routes` = `\"/users/[id]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/users/[id]",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve detectar rotas catch-all [...slug]/page.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar rotas catch-all [...slug]/page.tsx. **Valida√ß√µes**: `routes` = `\"/docs/[...slug]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/docs/[...slug]",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve ignorar route groups (app)/page.tsx",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue ignorar route groups (app)/page.tsx. **Valida√ß√µes**: `routes` = `\"/(marketing)/about\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/(marketing)/about",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve detectar API routes em app/api/route.ts",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue detectar API routes em app/api/route.ts. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve detectar API routes em app/api/route.ts...', () => {\n  const result = fs.mkdir(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve detectar API routes em app/api/route.ts...', () => {\n  const result = fs.mkdir(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve retornar array vazio se diret√≥rio n√£o existir",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar array vazio se diret√≥rio n√£o existir. **Valida√ß√µes**: `routes` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "nonExistentDir = ...",
      "routes = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve retornar todas as rotas encontradas",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue retornar todas as rotas encontradas. **Valida√ß√µes**: `routes` = `3`, `routes` = `\"/\"`, `routes` = `\"/about\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toContain, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/",
        "path": "routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/about",
        "path": "routes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/contact",
        "path": "routes"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve converter rotas din√¢micas pages/[id].tsx para :id",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue converter rotas din√¢micas pages/[id].tsx para :id. **Valida√ß√µes**: `routes` = `\"/users/:id\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/users/:id",
        "path": "routes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/next.test.ts",
    "name": "deve remover rotas duplicadas",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue remover rotas duplicadas. **Valida√ß√µes**: `homeRoutes` = `1`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routes = ...",
      "homeRoutes = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "homeRoutes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "TypeScript/JavaScript Detection > deve detectar TypeScript com Vitest",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar TypeScript com Vitest. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`, `result.testCommand` = `\"npm test\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm run test:coverage",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "coverage/coverage-summary.json",
        "path": "result.coverageFile"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "TypeScript/JavaScript Detection > deve detectar TypeScript com Jest",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar TypeScript com Jest. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"jest\"`, `result.testCommand` = `\"npm test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test -- --coverage",
        "path": "result.coverageCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "TypeScript/JavaScript Detection > deve detectar JavaScript puro (sem TypeScript)",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar JavaScript puro (sem TypeScript). **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar TypeScript com Vitest",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar TypeScript com Vitest. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`, `result.testCommand` = `\"npm test\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm run test:coverage",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "coverage/coverage-summary.json",
        "path": "result.coverageFile"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar TypeScript com Jest",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar TypeScript com Jest. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"jest\"`, `result.testCommand` = `\"npm test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test -- --coverage",
        "path": "result.coverageCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar JavaScript puro (sem TypeScript)",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar JavaScript puro (sem TypeScript). **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Go Detection > deve detectar Go com go.mod",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Go com go.mod. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`, `result.testCommand` = `\"go test ./...\"` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test ./...",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "coverage.out",
        "path": "result.coverageFile"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.sourcePatterns"
      }
    ],
    "mocks": [
      "module example.com/myapp\n\ngo 1.21",
      "module example.com/myapp\n\ngo 1.21"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Go Detection > deve detectar Go com testify framework",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Go com testify framework. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar Go com go.mod",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Go com go.mod. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`, `result.testCommand` = `\"go test ./...\"` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test ./...",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "coverage.out",
        "path": "result.coverageFile"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.sourcePatterns"
      }
    ],
    "mocks": [
      "module example.com/myapp\n\ngo 1.21",
      "module example.com/myapp\n\ngo 1.21"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar Go com testify framework",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Go com testify framework. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Java Detection > deve detectar Java com Maven (pom.xml)",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Java com Maven (pom.xml). **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`, `result.testCommand` = `\"mvn test\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mvn test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mvn clean test jacoco:report",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Java Detection > deve detectar Java com Gradle (build.gradle)",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Java com Gradle (build.gradle). **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`, `result.testCommand` = `\"./gradlew test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "./gradlew test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "./gradlew test jacocoTestReport",
        "path": "result.coverageCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar Java com Maven (pom.xml)",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Java com Maven (pom.xml). **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`, `result.testCommand` = `\"mvn test\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mvn test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mvn clean test jacoco:report",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar Java com Gradle (build.gradle)",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Java com Gradle (build.gradle). **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`, `result.testCommand` = `\"./gradlew test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "./gradlew test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "./gradlew test jacocoTestReport",
        "path": "result.coverageCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Python Detection > deve detectar Python com requirements.txt e pytest",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Python com requirements.txt e pytest. **Valida√ß√µes**: `result.primary` = `\"python\"`, `result.framework` = `\"pytest\"`, `result.testCommand` = `\"pytest\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest --cov=. --cov-report=json",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Python Detection > deve detectar Python com pyproject.toml",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Python com pyproject.toml. **Valida√ß√µes**: `result.primary` = `\"python\"`, `result.framework` = `\"pytest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar Python com requirements.txt e pytest",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Python com requirements.txt e pytest. **Valida√ß√µes**: `result.primary` = `\"python\"`, `result.framework` = `\"pytest\"`, `result.testCommand` = `\"pytest\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest --cov=. --cov-report=json",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar Python com pyproject.toml",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Python com pyproject.toml. **Valida√ß√µes**: `result.primary` = `\"python\"`, `result.framework` = `\"pytest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Ruby Detection > deve detectar Ruby com Gemfile e RSpec",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Ruby com Gemfile e RSpec. **Valida√ß√µes**: `result.primary` = `\"ruby\"`, `result.framework` = `\"rspec\"`, `result.testCommand` = `\"bundle exec rspec\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "ruby",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "rspec",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "bundle exec rspec",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "bundle exec rspec",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar Ruby com Gemfile e RSpec",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Ruby com Gemfile e RSpec. **Valida√ß√µes**: `result.primary` = `\"ruby\"`, `result.framework` = `\"rspec\"`, `result.testCommand` = `\"bundle exec rspec\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "ruby",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "rspec",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "bundle exec rspec",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "bundle exec rspec",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "C# Detection > deve detectar C# com arquivo .csproj",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar C# com arquivo .csproj. **Valida√ß√µes**: `result.primary` = `\"csharp\"`, `result.framework` = `\"nunit\"`, `result.testCommand` = `\"dotnet test\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "csharp",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nunit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "dotnet test",
        "path": "result.testCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve detectar C# com arquivo .csproj",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar C# com arquivo .csproj. **Valida√ß√µes**: `result.primary` = `\"csharp\"`, `result.framework` = `\"nunit\"`, `result.testCommand` = `\"dotnet test\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "csharp",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nunit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "dotnet test",
        "path": "result.testCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Fallback e Edge Cases > deve usar fallback para TypeScript quando n√£o detecta linguagem",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue usar fallback para TypeScript quando n√£o detecta linguagem. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`, `console.warn` = `\"‚ö†Ô∏è  Linguagem n√£o detectada automaticamente.\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toHaveBeenCalledWith. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "‚ö†Ô∏è  Linguagem n√£o detectada automaticamente.",
        "path": "console.warn"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Fallback e Edge Cases > deve lidar com erro de leitura de diret√≥rio",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue lidar com erro de leitura de diret√≥rio. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Fallback e Edge Cases > deve lidar com package.json inv√°lido",
    "testType": "unit",
    "functionUnderTest": ".rejects.toThrow",
    "whatItTests": "Valida que **`.rejects.toThrow`** consegue lidar com package.json inv√°lido. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".rejects.toThrow",
    "then": [],
    "mocks": [
      "invalid json content",
      "invalid json content"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Fallback e Edge Cases > deve lidar com package.jso...', () => {\n  const result = .rejects.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Fallback e Edge Cases > deve lidar com package.jso...', () => {\n  const result = .rejects.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Fallback e Edge Cases > deve lidar com arquivos vazios",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue lidar com arquivos vazios. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [
      "{}",
      "{}"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve usar fallback para TypeScript quando n√£o detecta linguagem",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue usar fallback para TypeScript quando n√£o detecta linguagem. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`, `console.warn` = `\"‚ö†Ô∏è  Linguagem n√£o detectada automaticamente.\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toHaveBeenCalledWith. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "‚ö†Ô∏è  Linguagem n√£o detectada automaticamente.",
        "path": "console.warn"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve lidar com erro de leitura de diret√≥rio",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue lidar com erro de leitura de diret√≥rio. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve lidar com package.json inv√°lido",
    "testType": "unit",
    "functionUnderTest": ".rejects.toThrow",
    "whatItTests": "Valida que **`.rejects.toThrow`** consegue lidar com package.json inv√°lido. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".rejects.toThrow",
    "then": [],
    "mocks": [
      "invalid json content",
      "invalid json content"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('detectLanguage > deve lidar com package.json inv√°l...', () => {\n  const result = .rejects.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('detectLanguage > deve lidar com package.json inv√°l...', () => {\n  const result = .rejects.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve lidar com arquivos vazios",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue lidar com arquivos vazios. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [
      "{}",
      "{}"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Projetos Multi-linguagem > deve priorizar Go quando tem go.mod e package.json",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue priorizar Go quando tem go.mod e package.json. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Projetos Multi-linguagem > deve priorizar Java quando tem pom.xml e package.json",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue priorizar Java quando tem pom.xml e package.json. **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve priorizar Go quando tem go.mod e package.json",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue priorizar Go quando tem go.mod e package.json. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "detectLanguage > deve priorizar Java quando tem pom.xml e package.json",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue priorizar Java quando tem pom.xml e package.json. **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "TypeScript/JavaScript Detection > deve detectar TypeScript com Vitest",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar TypeScript com Vitest. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`, `result.testCommand` = `\"npm test\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm run test:coverage",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "coverage/coverage-summary.json",
        "path": "result.coverageFile"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "TypeScript/JavaScript Detection > deve detectar TypeScript com Jest",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar TypeScript com Jest. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"jest\"`, `result.testCommand` = `\"npm test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test -- --coverage",
        "path": "result.coverageCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "TypeScript/JavaScript Detection > deve detectar JavaScript puro (sem TypeScript)",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar JavaScript puro (sem TypeScript). **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar TypeScript com Vitest",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar TypeScript com Vitest. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`, `result.testCommand` = `\"npm test\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm run test:coverage",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "coverage/coverage-summary.json",
        "path": "result.coverageFile"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar TypeScript com Jest",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar TypeScript com Jest. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"jest\"`, `result.testCommand` = `\"npm test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test -- --coverage",
        "path": "result.coverageCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar JavaScript puro (sem TypeScript)",
    "testType": "unit",
    "functionUnderTest": "JSON.stringify",
    "whatItTests": "Valida que **`JSON.stringify`** consegue detectar JavaScript puro (sem TypeScript). **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "JSON.stringify",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Go Detection > deve detectar Go com go.mod",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Go com go.mod. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`, `result.testCommand` = `\"go test ./...\"` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test ./...",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "coverage.out",
        "path": "result.coverageFile"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.sourcePatterns"
      }
    ],
    "mocks": [
      "module example.com/myapp\n\ngo 1.21",
      "module example.com/myapp\n\ngo 1.21"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Go Detection > deve detectar Go com testify framework",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Go com testify framework. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar Go com go.mod",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Go com go.mod. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`, `result.testCommand` = `\"go test ./...\"` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test ./...",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "coverage.out",
        "path": "result.coverageFile"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.sourcePatterns"
      }
    ],
    "mocks": [
      "module example.com/myapp\n\ngo 1.21",
      "module example.com/myapp\n\ngo 1.21"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar Go com testify framework",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Go com testify framework. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Java Detection > deve detectar Java com Maven (pom.xml)",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Java com Maven (pom.xml). **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`, `result.testCommand` = `\"mvn test\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mvn test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mvn clean test jacoco:report",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Java Detection > deve detectar Java com Gradle (build.gradle)",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Java com Gradle (build.gradle). **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`, `result.testCommand` = `\"./gradlew test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "./gradlew test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "./gradlew test jacocoTestReport",
        "path": "result.coverageCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar Java com Maven (pom.xml)",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Java com Maven (pom.xml). **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`, `result.testCommand` = `\"mvn test\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mvn test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mvn clean test jacoco:report",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar Java com Gradle (build.gradle)",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Java com Gradle (build.gradle). **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`, `result.testCommand` = `\"./gradlew test\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "./gradlew test",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "./gradlew test jacocoTestReport",
        "path": "result.coverageCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Python Detection > deve detectar Python com requirements.txt e pytest",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Python com requirements.txt e pytest. **Valida√ß√µes**: `result.primary` = `\"python\"`, `result.framework` = `\"pytest\"`, `result.testCommand` = `\"pytest\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest --cov=. --cov-report=json",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Python Detection > deve detectar Python com pyproject.toml",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Python com pyproject.toml. **Valida√ß√µes**: `result.primary` = `\"python\"`, `result.framework` = `\"pytest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar Python com requirements.txt e pytest",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Python com requirements.txt e pytest. **Valida√ß√µes**: `result.primary` = `\"python\"`, `result.framework` = `\"pytest\"`, `result.testCommand` = `\"pytest\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest --cov=. --cov-report=json",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar Python com pyproject.toml",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Python com pyproject.toml. **Valida√ß√µes**: `result.primary` = `\"python\"`, `result.framework` = `\"pytest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Ruby Detection > deve detectar Ruby com Gemfile e RSpec",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Ruby com Gemfile e RSpec. **Valida√ß√µes**: `result.primary` = `\"ruby\"`, `result.framework` = `\"rspec\"`, `result.testCommand` = `\"bundle exec rspec\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "ruby",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "rspec",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "bundle exec rspec",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "bundle exec rspec",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar Ruby com Gemfile e RSpec",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar Ruby com Gemfile e RSpec. **Valida√ß√µes**: `result.primary` = `\"ruby\"`, `result.framework` = `\"rspec\"`, `result.testCommand` = `\"bundle exec rspec\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "ruby",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "rspec",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "bundle exec rspec",
        "path": "result.testCommand"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "bundle exec rspec",
        "path": "result.coverageCommand"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "result.testPatterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "C# Detection > deve detectar C# com arquivo .csproj",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar C# com arquivo .csproj. **Valida√ß√µes**: `result.primary` = `\"csharp\"`, `result.framework` = `\"nunit\"`, `result.testCommand` = `\"dotnet test\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "csharp",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nunit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "dotnet test",
        "path": "result.testCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve detectar C# com arquivo .csproj",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar C# com arquivo .csproj. **Valida√ß√µes**: `result.primary` = `\"csharp\"`, `result.framework` = `\"nunit\"`, `result.testCommand` = `\"dotnet test\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "csharp",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nunit",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "dotnet test",
        "path": "result.testCommand"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Fallback e Edge Cases > deve usar fallback para TypeScript quando n√£o detecta linguagem",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue usar fallback para TypeScript quando n√£o detecta linguagem. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`, `console.warn` = `\"‚ö†Ô∏è  Linguagem n√£o detectada automaticamente.\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toHaveBeenCalledWith. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "‚ö†Ô∏è  Linguagem n√£o detectada automaticamente.",
        "path": "console.warn"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Fallback e Edge Cases > deve lidar com erro de leitura de diret√≥rio",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue lidar com erro de leitura de diret√≥rio. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Fallback e Edge Cases > deve lidar com package.json inv√°lido",
    "testType": "unit",
    "functionUnderTest": ".rejects.toThrow",
    "whatItTests": "Valida que **`.rejects.toThrow`** consegue lidar com package.json inv√°lido. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".rejects.toThrow",
    "then": [],
    "mocks": [
      "invalid json content",
      "invalid json content"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('Fallback e Edge Cases > deve lidar com package.jso...', () => {\n  const result = .rejects.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('Fallback e Edge Cases > deve lidar com package.jso...', () => {\n  const result = .rejects.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Fallback e Edge Cases > deve lidar com arquivos vazios",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue lidar com arquivos vazios. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [
      "{}",
      "{}"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve usar fallback para TypeScript quando n√£o detecta linguagem",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue usar fallback para TypeScript quando n√£o detecta linguagem. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`, `console.warn` = `\"‚ö†Ô∏è  Linguagem n√£o detectada automaticamente.\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toHaveBeenCalledWith. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalledWith",
        "value": "‚ö†Ô∏è  Linguagem n√£o detectada automaticamente.",
        "path": "console.warn"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve lidar com erro de leitura de diret√≥rio",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue lidar com erro de leitura de diret√≥rio. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve lidar com package.json inv√°lido",
    "testType": "unit",
    "functionUnderTest": ".rejects.toThrow",
    "whatItTests": "Valida que **`.rejects.toThrow`** consegue lidar com package.json inv√°lido. **0 valida√ß√µes** usando: ",
    "whyItTests": "‚ö†Ô∏è **Sem valida√ß√µes** - teste pode n√£o detectar regress√µes",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚ö†Ô∏è **ALERTA**: Teste sem asserts N√ÉO contribui para redu√ß√£o de CFR/MTTR (falso positivo)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".rejects.toThrow",
    "then": [],
    "mocks": [
      "invalid json content",
      "invalid json content"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [
      {
        "type": "no-asserts",
        "description": "Teste sem assertions - n√£o valida nenhum comportamento",
        "severity": "critical",
        "impact": "Teste sempre passa (falso positivo). Bugs n√£o s√£o detectados. Coverage inflado artificialmente.",
        "howToFix": {
          "before": "// ‚ùå MAU - Teste sem valida√ß√£o\nit('deve lidar com package.json inv√°lido...', () => {\n  const result = .rejects.toThrow(input);\n  // N√£o valida nada! üö®\n});",
          "after": "// ‚úÖ BOM - Teste com valida√ß√µes espec√≠ficas\nit('deve lidar com package.json inv√°lido...', () => {\n  const result = .rejects.toThrow(input);\n  \n  // Validar retorno\n  expect(result).toBeDefined();\n  expect(result.status).toBe('success');\n  \n  // Validar dados processados\n  expect(result.data).toHaveLength(3);\n  expect(result.data[0]).toHaveProperty('id');\n  \n  // Validar efeitos colaterais\n  expect(result.timestamp).toBeGreaterThan(0);\n});",
          "explanation": "Adicione asserts espec√≠ficos que validam: (1) Valores de retorno, (2) Estrutura dos dados, (3) Estados esperados, (4) Efeitos colaterais. Use matchers espec√≠ficos ao inv√©s de gen√©ricos."
        }
      }
    ],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve lidar com arquivos vazios",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue lidar com arquivos vazios. **Valida√ß√µes**: `result.primary` = `\"typescript\"`, `result.framework` = `\"vitest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      }
    ],
    "mocks": [
      "{}",
      "{}"
    ],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Projetos Multi-linguagem > deve priorizar Go quando tem go.mod e package.json",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue priorizar Go quando tem go.mod e package.json. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "Projetos Multi-linguagem > deve priorizar Java quando tem pom.xml e package.json",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue priorizar Java quando tem pom.xml e package.json. **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve priorizar Go quando tem go.mod e package.json",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue priorizar Go quando tem go.mod e package.json. **Valida√ß√µes**: `result.primary` = `\"go\"`, `result.framework` = `\"go-test\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "go-test",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve priorizar Java quando tem pom.xml e package.json",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue priorizar Java quando tem pom.xml e package.json. **Valida√ß√µes**: `result.primary` = `\"java\"`, `result.framework` = `\"junit\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "java",
        "path": "result.primary"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "junit",
        "path": "result.framework"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "getTestFileExtension > deve retornar extens√£o correta para cada linguagem",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar extens√£o correta para cada linguagem. **Valida√ß√µes**: `getTestFileExtension()` = `\".test.ts\"`, `getTestFileExtension()` = `\"Test.java\"`, `getTestFileExtension()` = `\"_test.go\"` e mais 5",
    "whyItTests": "Valida 8 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~8) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".test.ts",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Test.java",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.go",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_spec.rb",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.py",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Tests.cs",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Test.php",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.rs",
        "path": "getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "getTestFileExtension > deve usar fallback .test.ts para linguagens desconhecidas",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar fallback .test.ts para linguagens desconhecidas. **Valida√ß√µes**: `getTestFileExtension()` = `\".test.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".test.ts",
        "path": "getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve retornar extens√£o correta para cada linguagem",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue retornar extens√£o correta para cada linguagem. **Valida√ß√µes**: `getTestFileExtension()` = `\".test.ts\"`, `getTestFileExtension()` = `\"Test.java\"`, `getTestFileExtension()` = `\"_test.go\"` e mais 5",
    "whyItTests": "Valida 8 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~8) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".test.ts",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Test.java",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.go",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_spec.rb",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.py",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Tests.cs",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "Test.php",
        "path": "getTestFileExtension()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.rs",
        "path": "getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve usar fallback .test.ts para linguagens desconhecidas",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue usar fallback .test.ts para linguagens desconhecidas. **Valida√ß√µes**: `getTestFileExtension()` = `\".test.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".test.ts",
        "path": "getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "getTestTemplate > deve gerar template TypeScript/JavaScript correto",
    "testType": "unit",
    "functionUnderTest": "getTestTemplate",
    "whatItTests": "Valida que **`getTestTemplate`** consegue gerar template TypeScript/JavaScript correto. **Valida√ß√µes**: `template` = `\"import { describe, it, expect } from 'vitest'\"`, `template` = `\"import { myFunction } from './myModule'\"`, `template` = `\"describe('myFunction', () => {\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "template = ..."
    ],
    "when": "getTestTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { describe, it, expect } from 'vitest'",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { myFunction } from './myModule'",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "describe('myFunction', () => {",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should work correctly",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle edge cases",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle errors",
        "path": "template"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "getTestTemplate > deve gerar template para diferentes linguagens",
    "testType": "unit",
    "functionUnderTest": "getTestTemplate",
    "whatItTests": "Valida que **`getTestTemplate`** consegue gerar template para diferentes linguagens. **Valida√ß√µes**: `tsTemplate` = `\"vitest\"`, `tsTemplate` = `\"parseData\"`, `tsTemplate` = `\"../parser\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "tsTemplate = ...",
      "jsTemplate = ..."
    ],
    "when": "getTestTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "vitest",
        "path": "tsTemplate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "parseData",
        "path": "tsTemplate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "../parser",
        "path": "tsTemplate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "vitest",
        "path": "jsTemplate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "helper",
        "path": "jsTemplate"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "getTestTemplate > deve funcionar com nomes de fun√ß√£o complexos",
    "testType": "unit",
    "functionUnderTest": "getTestTemplate",
    "whatItTests": "Valida que **`getTestTemplate`** consegue funcionar com nomes de fun√ß√£o complexos. **Valida√ß√µes**: `template` = `\"calculateTotalPrice\"`, `template` = `\"../business/pricing\"`, `template` = `\"describe('calculateTotalPrice'\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "template = ..."
    ],
    "when": "getTestTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "calculateTotalPrice",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "../business/pricing",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "describe('calculateTotalPrice'",
        "path": "template"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "getTestTemplate > deve funcionar com caminhos relativos diferentes",
    "testType": "unit",
    "functionUnderTest": "getTestTemplate",
    "whatItTests": "Valida que **`getTestTemplate`** consegue funcionar com caminhos relativos diferentes. **Valida√ß√µes**: `template` = `\"../../shared/validation\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "template = ..."
    ],
    "when": "getTestTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "../../shared/validation",
        "path": "template"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve gerar template TypeScript/JavaScript correto",
    "testType": "unit",
    "functionUnderTest": "getTestTemplate",
    "whatItTests": "Valida que **`getTestTemplate`** consegue gerar template TypeScript/JavaScript correto. **Valida√ß√µes**: `template` = `\"import { describe, it, expect } from 'vitest'\"`, `template` = `\"import { myFunction } from './myModule'\"`, `template` = `\"describe('myFunction', () => {\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "template = ..."
    ],
    "when": "getTestTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { describe, it, expect } from 'vitest'",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { myFunction } from './myModule'",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "describe('myFunction', () => {",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should work correctly",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle edge cases",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle errors",
        "path": "template"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve gerar template para diferentes linguagens",
    "testType": "unit",
    "functionUnderTest": "getTestTemplate",
    "whatItTests": "Valida que **`getTestTemplate`** consegue gerar template para diferentes linguagens. **Valida√ß√µes**: `tsTemplate` = `\"vitest\"`, `tsTemplate` = `\"parseData\"`, `tsTemplate` = `\"../parser\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "tsTemplate = ...",
      "jsTemplate = ..."
    ],
    "when": "getTestTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "vitest",
        "path": "tsTemplate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "parseData",
        "path": "tsTemplate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "../parser",
        "path": "tsTemplate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "vitest",
        "path": "jsTemplate"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "helper",
        "path": "jsTemplate"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve funcionar com nomes de fun√ß√£o complexos",
    "testType": "unit",
    "functionUnderTest": "getTestTemplate",
    "whatItTests": "Valida que **`getTestTemplate`** consegue funcionar com nomes de fun√ß√£o complexos. **Valida√ß√µes**: `template` = `\"calculateTotalPrice\"`, `template` = `\"../business/pricing\"`, `template` = `\"describe('calculateTotalPrice'\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "template = ..."
    ],
    "when": "getTestTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "calculateTotalPrice",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "../business/pricing",
        "path": "template"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "describe('calculateTotalPrice'",
        "path": "template"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/language.test.ts",
    "name": "deve funcionar com caminhos relativos diferentes",
    "testType": "unit",
    "functionUnderTest": "getTestTemplate",
    "whatItTests": "Valida que **`getTestTemplate`** consegue funcionar com caminhos relativos diferentes. **Valida√ß√µes**: `template` = `\"../../shared/validation\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "template = ..."
    ],
    "when": "getTestTemplate",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "../../shared/validation",
        "path": "template"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findExpressRoutes > deve detectar app.get(\"/path\", handler)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar app.get(\"/path\", handler). **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findExpressRoutes > deve detectar app.post(\"/path\", handler)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar app.post(\"/path\", handler). **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findExpressRoutes > deve detectar router.put, router.delete, router.patch",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar router.put, router.delete, router.patch. **Valida√ß√µes**: `endpoints` = `3`, `endpoints.map()` = `\"[...]\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "endpoints.map()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findExpressRoutes > deve detectar Router() com routes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar Router() com routes. **Valida√ß√µes**: `endpoints` = `2`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findExpressRoutes > deve detectar routes com middlewares",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar routes com middlewares. **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findExpressRoutes > deve detectar rotas com aspas simples, duplas e template literals",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar rotas com aspas simples, duplas e template literals. **Valida√ß√µes**: `endpoints` = `3`, `endpoints.map()` = `\"[...]\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "endpoints.map()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findExpressRoutes > deve detectar server.get (Fastify)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar server.get (Fastify). **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findExpressRoutes > deve detectar router.options",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar router.options. **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar app.get(\"/path\", handler)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar app.get(\"/path\", handler). **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar app.post(\"/path\", handler)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar app.post(\"/path\", handler). **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar router.put, router.delete, router.patch",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar router.put, router.delete, router.patch. **Valida√ß√µes**: `endpoints` = `3`, `endpoints.map()` = `\"[...]\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "endpoints.map()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar Router() com routes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar Router() com routes. **Valida√ß√µes**: `endpoints` = `2`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar routes com middlewares",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar routes com middlewares. **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar rotas com aspas simples, duplas e template literals",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar rotas com aspas simples, duplas e template literals. **Valida√ß√µes**: `endpoints` = `3`, `endpoints.map()` = `\"[...]\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "endpoints.map()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar server.get (Fastify)",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar server.get (Fastify). **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar router.options",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar router.options. **Valida√ß√µes**: `endpoints` = `1`, `endpoints.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "routeFile = ...",
      "endpoints = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "endpoints"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "endpoints.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findOpenAPI > deve parsear openapi.yml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue parsear openapi.yml. **Valida√ß√µes**: `specs` = `1`, `specs.?` = `\"openapi.yml\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "openapi.yml",
        "path": "specs.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findOpenAPI > deve parsear openapi.json",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue parsear openapi.json. **Valida√ß√µes**: `specs` = `1`, `specs.?` = `\"openapi.json\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "openapi.json",
        "path": "specs.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findOpenAPI > deve extrair todos os endpoints de paths",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue extrair todos os endpoints de paths. **Valida√ß√µes**: `specs` = `2`, `specs` = `\"openapi.yml\"`, `specs` = `\"docs/swagger.yml\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "specs = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "openapi.yml",
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "docs/swagger.yml",
        "path": "specs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findOpenAPI > deve retornar array vazio se spec n√£o existir",
    "testType": "unit",
    "functionUnderTest": "findOpenAPI",
    "whatItTests": "Valida que **`findOpenAPI`** consegue retornar array vazio se spec n√£o existir. **Valida√ß√µes**: `specs` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "findOpenAPI",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "specs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findOpenAPI > deve lidar com spec malformado",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com spec malformado. **Valida√ß√µes**: `specs` = `1`, `specs.?` = `\"openapi.yml\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "openapi.yml",
        "path": "specs.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findOpenAPI > deve detectar swagger.json e swagger.yml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar swagger.json e swagger.yml. **Valida√ß√µes**: `specs` = `2`, `specs` = `\"swagger.json\"`, `specs` = `\"swagger.yml\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "swagger.json",
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "swagger.yml",
        "path": "specs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findOpenAPI > deve remover specs duplicados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue remover specs duplicados. **1 valida√ß√µes** usando: toBe",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ...",
      "uniqueSpecs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "specs.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "findOpenAPI > deve detectar arquivos .yaml al√©m de .yml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar arquivos .yaml al√©m de .yml. **Valida√ß√µes**: `specs` = `1`, `specs.?` = `\"openapi.yaml\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "openapi.yaml",
        "path": "specs.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve parsear openapi.yml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue parsear openapi.yml. **Valida√ß√µes**: `specs` = `1`, `specs.?` = `\"openapi.yml\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "openapi.yml",
        "path": "specs.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve parsear openapi.json",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue parsear openapi.json. **Valida√ß√µes**: `specs` = `1`, `specs.?` = `\"openapi.json\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "openapi.json",
        "path": "specs.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve extrair todos os endpoints de paths",
    "testType": "unit",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue extrair todos os endpoints de paths. **Valida√ß√µes**: `specs` = `2`, `specs` = `\"openapi.yml\"`, `specs` = `\"docs/swagger.yml\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "specs = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "openapi.yml",
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "docs/swagger.yml",
        "path": "specs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve retornar array vazio se spec n√£o existir",
    "testType": "unit",
    "functionUnderTest": "findOpenAPI",
    "whatItTests": "Valida que **`findOpenAPI`** consegue retornar array vazio se spec n√£o existir. **Valida√ß√µes**: `specs` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "findOpenAPI",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "specs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve lidar com spec malformado",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue lidar com spec malformado. **Valida√ß√µes**: `specs` = `1`, `specs.?` = `\"openapi.yml\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "openapi.yml",
        "path": "specs.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar swagger.json e swagger.yml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar swagger.json e swagger.yml. **Valida√ß√µes**: `specs` = `2`, `specs` = `\"swagger.json\"`, `specs` = `\"swagger.yml\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "swagger.json",
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "swagger.yml",
        "path": "specs"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve remover specs duplicados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue remover specs duplicados. **1 valida√ß√µes** usando: toBe",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ...",
      "uniqueSpecs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "path": "specs.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/express.test.ts",
    "name": "deve detectar arquivos .yaml al√©m de .yml",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue detectar arquivos .yaml al√©m de .yml. **Valida√ß√µes**: `specs` = `1`, `specs.?` = `\"openapi.yaml\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "specs = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "specs"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "openapi.yaml",
        "path": "specs.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve detectar producer.send() com t√≥picos Kafka",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar producer.send() com t√≥picos Kafka. **Valida√ß√µes**: `events` = `\"kafka:user-created\"`, `events` = `\"kafka:order-placed\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "kafkaFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:user-created",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:order-placed",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve detectar consumer.subscribe() e consumer.run()",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar consumer.subscribe() e consumer.run(). **Valida√ß√µes**: `events` = `\"kafka:payment-processed\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "kafkaFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:payment-processed",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve detectar sqs.sendMessage() com queue URL",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar sqs.sendMessage() com queue URL. **Valida√ß√µes**: `events` = `\"aws:my-queue\"`, `events` = `\"aws:notifications\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "sqsFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "aws:my-queue",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "aws:notifications",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve detectar emit() com event names",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar emit() com event names. **Valida√ß√µes**: `events` = `\"event:user:login\"`, `events` = `\"event:user:logout\"`, `events` = `\"event:data:updated\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "emitterFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:user:login",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:user:logout",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:data:updated",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve retornar array vazio se n√£o houver eventos",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar array vazio se n√£o houver eventos. **Valida√ß√µes**: `events` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "emptyFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve consolidar todos os eventos encontrados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue consolidar todos os eventos encontrados. **Valida√ß√µes**: `events` = `3`, `events` = `\"kafka:topic-1\"`, `events` = `\"aws:queue-1\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toContain, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "events = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:topic-1",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "aws:queue-1",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:event-1",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve remover eventos duplicados",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue remover eventos duplicados. **Valida√ß√µes**: `events.filter()` = `1`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "events.filter()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve detectar SNS subscribe com TopicArn",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar SNS subscribe com TopicArn. **Valida√ß√µes**: `events` = `\"aws:my-topic\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "snsFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "aws:my-topic",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "findEvents > deve detectar eventos com aspas simples, duplas e template literals",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar eventos com aspas simples, duplas e template literals. **Valida√ß√µes**: `events` = `\"event:single-quote\"`, `events` = `\"event:double-quote\"`, `events` = `\"event:template-literal\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "file = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:single-quote",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:double-quote",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:template-literal",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve detectar producer.send() com t√≥picos Kafka",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar producer.send() com t√≥picos Kafka. **Valida√ß√µes**: `events` = `\"kafka:user-created\"`, `events` = `\"kafka:order-placed\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "kafkaFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:user-created",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:order-placed",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve detectar consumer.subscribe() e consumer.run()",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar consumer.subscribe() e consumer.run(). **Valida√ß√µes**: `events` = `\"kafka:payment-processed\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "kafkaFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:payment-processed",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve detectar sqs.sendMessage() com queue URL",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar sqs.sendMessage() com queue URL. **Valida√ß√µes**: `events` = `\"aws:my-queue\"`, `events` = `\"aws:notifications\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "sqsFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "aws:my-queue",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "aws:notifications",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve detectar emit() com event names",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar emit() com event names. **Valida√ß√µes**: `events` = `\"event:user:login\"`, `events` = `\"event:user:logout\"`, `events` = `\"event:data:updated\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "emitterFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:user:login",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:user:logout",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:data:updated",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve retornar array vazio se n√£o houver eventos",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue retornar array vazio se n√£o houver eventos. **Valida√ß√µes**: `events` = `\"[...]\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "emptyFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toEqual",
        "value": "[...]",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve consolidar todos os eventos encontrados",
    "testType": "unit",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue consolidar todos os eventos encontrados. **Valida√ß√µes**: `events` = `3`, `events` = `\"kafka:topic-1\"`, `events` = `\"aws:queue-1\"` e mais 1",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toContain, toEqual",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "events = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 3,
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "kafka:topic-1",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "aws:queue-1",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:event-1",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toEqual",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve remover eventos duplicados",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue remover eventos duplicados. **Valida√ß√µes**: `events.filter()` = `1`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "file = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "events.filter()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve detectar SNS subscribe com TopicArn",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar SNS subscribe com TopicArn. **Valida√ß√µes**: `events` = `\"aws:my-topic\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "snsFile = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "aws:my-topic",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/detectors/__tests__/events.test.ts",
    "name": "deve detectar eventos com aspas simples, duplas e template literals",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar eventos com aspas simples, duplas e template literals. **Valida√ß√µes**: `events` = `\"event:single-quote\"`, `events` = `\"event:double-quote\"`, `events` = `\"event:template-literal\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "file = ...",
      "events = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:single-quote",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:double-quote",
        "path": "events"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "event:template-literal",
        "path": "events"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "detectLanguage > deve detectar adapter baseado no m√©todo detect",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar adapter baseado no m√©todo detect. **Valida√ß√µes**: `result` = `\"mockAdapter2\"`, `unknown` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter1 = ...",
      "mockAdapter2 = ...",
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mockAdapter2",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "detectLanguage > deve retornar null se nenhum adapter detectar",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue retornar null se nenhum adapter detectar. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "Engine Modular > deve detectar adapter baseado no m√©todo detect",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar adapter baseado no m√©todo detect. **Valida√ß√µes**: `result` = `\"mockAdapter2\"`, `unknown` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter1 = ...",
      "mockAdapter2 = ...",
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mockAdapter2",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "Engine Modular > deve retornar null se nenhum adapter detectar",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue retornar null se nenhum adapter detectar. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve lan√ßar erro se linguagem n√£o detectada",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue lan√ßar erro se linguagem n√£o detectada. **Valida√ß√µes**: `result.ok` = `false`, `result.errors.length` = `0`, `result.errors.?` = `\"n√£o detectada\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThan, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.errors.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "n√£o detectada",
        "path": "result.errors.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve executar pipeline com adapter v√°lido (stub)",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue executar pipeline com adapter v√°lido (stub). **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"typescript\"`, `result.framework` = `\"vitest\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "functions",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cases",
        "path": "result.execution.stepsExecuted"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve pular mutation em perfil ci-fast",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue pular mutation em perfil ci-fast. **Valida√ß√µes**: `result.execution.stepsSkipped` = `\"mutation\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mutation",
        "path": "result.execution.stepsSkipped"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve executar mutation em perfil ci-strict",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue executar mutation em perfil ci-strict. **Valida√ß√µes**: `result.execution.stepsExecuted` = `\"mutation\"`, `result.report.metrics.mutationScore` = `75`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain, toHaveBeenCalled, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mutation",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "mockAdapter.capabilities.mutation"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.report.metrics.mutationScore"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve calcular quality score corretamente",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue calcular quality score corretamente. **Valida√ß√µes**: `result.report.metrics.qualityScore` = `0`, `result.report.metrics.grade` = `{}`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.report.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.report.metrics.grade"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "Engine Modular > deve lan√ßar erro se linguagem n√£o detectada",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue lan√ßar erro se linguagem n√£o detectada. **Valida√ß√µes**: `result.ok` = `false`, `result.errors.length` = `0`, `result.errors.?` = `\"n√£o detectada\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThan, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.errors.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "n√£o detectada",
        "path": "result.errors.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "Engine Modular > deve executar pipeline com adapter v√°lido (stub)",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue executar pipeline com adapter v√°lido (stub). **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"typescript\"`, `result.framework` = `\"vitest\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "functions",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cases",
        "path": "result.execution.stepsExecuted"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "Engine Modular > deve pular mutation em perfil ci-fast",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue pular mutation em perfil ci-fast. **Valida√ß√µes**: `result.execution.stepsSkipped` = `\"mutation\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mutation",
        "path": "result.execution.stepsSkipped"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "Engine Modular > deve executar mutation em perfil ci-strict",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue executar mutation em perfil ci-strict. **Valida√ß√µes**: `result.execution.stepsExecuted` = `\"mutation\"`, `result.report.metrics.mutationScore` = `75`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain, toHaveBeenCalled, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mutation",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "mockAdapter.capabilities.mutation"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.report.metrics.mutationScore"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "Engine Modular > deve calcular quality score corretamente",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue calcular quality score corretamente. **Valida√ß√µes**: `result.report.metrics.qualityScore` = `0`, `result.report.metrics.grade` = `{}`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.report.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.report.metrics.grade"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "detectLanguage > deve detectar adapter baseado no m√©todo detect",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar adapter baseado no m√©todo detect. **Valida√ß√µes**: `result` = `\"mockAdapter2\"`, `unknown` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter1 = ...",
      "mockAdapter2 = ...",
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mockAdapter2",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "detectLanguage > deve retornar null se nenhum adapter detectar",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue retornar null se nenhum adapter detectar. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "deve detectar adapter baseado no m√©todo detect",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue detectar adapter baseado no m√©todo detect. **Valida√ß√µes**: `result` = `\"mockAdapter2\"`, `unknown` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter1 = ...",
      "mockAdapter2 = ...",
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mockAdapter2",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "deve retornar null se nenhum adapter detectar",
    "testType": "unit",
    "functionUnderTest": "detectLanguage",
    "whatItTests": "Valida que **`detectLanguage`** consegue retornar null se nenhum adapter detectar. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "detectLanguage",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve lan√ßar erro se linguagem n√£o detectada",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue lan√ßar erro se linguagem n√£o detectada. **Valida√ß√µes**: `result.ok` = `false`, `result.errors.length` = `0`, `result.errors.?` = `\"n√£o detectada\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThan, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.errors.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "n√£o detectada",
        "path": "result.errors.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve executar pipeline com adapter v√°lido (stub)",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue executar pipeline com adapter v√°lido (stub). **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"typescript\"`, `result.framework` = `\"vitest\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "functions",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cases",
        "path": "result.execution.stepsExecuted"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve pular mutation em perfil ci-fast",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue pular mutation em perfil ci-fast. **Valida√ß√µes**: `result.execution.stepsSkipped` = `\"mutation\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mutation",
        "path": "result.execution.stepsSkipped"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve executar mutation em perfil ci-strict",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue executar mutation em perfil ci-strict. **Valida√ß√µes**: `result.execution.stepsExecuted` = `\"mutation\"`, `result.report.metrics.mutationScore` = `75`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain, toHaveBeenCalled, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mutation",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "mockAdapter.capabilities.mutation"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.report.metrics.mutationScore"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "runPipeline > deve calcular quality score corretamente",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue calcular quality score corretamente. **Valida√ß√µes**: `result.report.metrics.qualityScore` = `0`, `result.report.metrics.grade` = `{}`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.report.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.report.metrics.grade"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "deve lan√ßar erro se linguagem n√£o detectada",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue lan√ßar erro se linguagem n√£o detectada. **Valida√ß√µes**: `result.ok` = `false`, `result.errors.length` = `0`, `result.errors.?` = `\"n√£o detectada\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toBeGreaterThan, toContain. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.errors.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "n√£o detectada",
        "path": "result.errors.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "deve executar pipeline com adapter v√°lido (stub)",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue executar pipeline com adapter v√°lido (stub). **Valida√ß√µes**: `result.ok` = `true`, `result.language` = `\"typescript\"`, `result.framework` = `\"vitest\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "result.language"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result.framework"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "functions",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "tests",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cases",
        "path": "result.execution.stepsExecuted"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "deve pular mutation em perfil ci-fast",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue pular mutation em perfil ci-fast. **Valida√ß√µes**: `result.execution.stepsSkipped` = `\"mutation\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mutation",
        "path": "result.execution.stepsSkipped"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "deve executar mutation em perfil ci-strict",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue executar mutation em perfil ci-strict. **Valida√ß√µes**: `result.execution.stepsExecuted` = `\"mutation\"`, `result.report.metrics.mutationScore` = `75`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain, toHaveBeenCalled, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mutation",
        "path": "result.execution.stepsExecuted"
      },
      {
        "type": "called",
        "matcher": "toHaveBeenCalled",
        "path": "mockAdapter.capabilities.mutation"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 75,
        "path": "result.report.metrics.mutationScore"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/__tests__/engine.test.ts",
    "name": "deve calcular quality score corretamente",
    "testType": "unit",
    "functionUnderTest": "runPipeline",
    "whatItTests": "Valida que **`runPipeline`** consegue calcular quality score corretamente. **Valida√ß√µes**: `result.report.metrics.qualityScore` = `0`, `result.report.metrics.grade` = `{}`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeGreaterThan, toMatch",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "mockAdapter = ...",
      "result = ..."
    ],
    "when": "runPipeline",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.report.metrics.qualityScore"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "result.report.metrics.grade"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should generate valid unit test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateUnitTest",
    "whatItTests": "Valida que **`adapter.generateUnitTest`** consegue generate valid unit test template. **Valida√ß√µes**: `result` = `\"import { describe, it, expect } from 'vitest'\"`, `result` = `\"import { calculateTotal } from './utils/math.js'\"`, `result` = `\"describe('calculateTotal'\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateUnitTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { describe, it, expect } from 'vitest'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { calculateTotal } from './utils/math.js'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "describe('calculateTotal'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should work correctly with valid input",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle errors appropriately",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle edge cases",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should generate integration test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateIntegrationTest",
    "whatItTests": "Valida que **`adapter.generateIntegrationTest`** consegue generate integration test template. **Valida√ß√µes**: `result` = `\"supertest\"`, `result` = `\"UserService Integration Tests\"`, `result` = `\"beforeEach\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateIntegrationTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "supertest",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "UserService Integration Tests",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "beforeEach",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "afterEach",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should generate E2E test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateE2ETest",
    "whatItTests": "Valida que **`adapter.generateE2ETest`** consegue generate E2E test template. **Valida√ß√µes**: `result` = `\"@playwright/test\"`, `result` = `\"LoginFlow\"`, `result` = `\"should complete LoginFlow flow\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateE2ETest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@playwright/test",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "LoginFlow",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should complete LoginFlow flow",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should return correct test file extension",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test file extension. **Valida√ß√µes**: `adapter.getTestFileExtension()` = `\".test.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".test.ts",
        "path": "adapter.getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should return correct test patterns",
    "testType": "unit",
    "functionUnderTest": "adapter.getTestPatterns",
    "whatItTests": "Valida que **`adapter.getTestPatterns`** consegue return correct test patterns. **Valida√ß√µes**: `patterns` = `\"**/*.test.{ts,tsx,js,jsx}\"`, `patterns` = `\"**/__tests__/**/*.{ts,tsx,js,jsx}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "patterns = ..."
    ],
    "when": "adapter.getTestPatterns",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/*.test.{ts,tsx,js,jsx}",
        "path": "patterns"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/__tests__/**/*.{ts,tsx,js,jsx}",
        "path": "patterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should return correct test command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test command. **Valida√ß√µes**: `adapter.getTestCommand()` = `\"npm test\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "adapter.getTestCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should return correct coverage command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct coverage command. **Valida√ß√µes**: `adapter.getCoverageCommand()` = `\"npm run test:coverage\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm run test:coverage",
        "path": "adapter.getCoverageCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should generate valid unit test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateUnitTest",
    "whatItTests": "Valida que **`adapter.generateUnitTest`** consegue generate valid unit test template. **Valida√ß√µes**: `result` = `\"import { describe, it, expect } from 'vitest'\"`, `result` = `\"import { calculateTotal } from './utils/math.js'\"`, `result` = `\"describe('calculateTotal'\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateUnitTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { describe, it, expect } from 'vitest'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { calculateTotal } from './utils/math.js'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "describe('calculateTotal'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should work correctly with valid input",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle errors appropriately",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle edge cases",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should generate integration test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateIntegrationTest",
    "whatItTests": "Valida que **`adapter.generateIntegrationTest`** consegue generate integration test template. **Valida√ß√µes**: `result` = `\"supertest\"`, `result` = `\"UserService Integration Tests\"`, `result` = `\"beforeEach\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateIntegrationTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "supertest",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "UserService Integration Tests",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "beforeEach",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "afterEach",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should generate E2E test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateE2ETest",
    "whatItTests": "Valida que **`adapter.generateE2ETest`** consegue generate E2E test template. **Valida√ß√µes**: `result` = `\"@playwright/test\"`, `result` = `\"LoginFlow\"`, `result` = `\"should complete LoginFlow flow\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateE2ETest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@playwright/test",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "LoginFlow",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should complete LoginFlow flow",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return correct test file extension",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test file extension. **Valida√ß√µes**: `adapter.getTestFileExtension()` = `\".test.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".test.ts",
        "path": "adapter.getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return correct test patterns",
    "testType": "unit",
    "functionUnderTest": "adapter.getTestPatterns",
    "whatItTests": "Valida que **`adapter.getTestPatterns`** consegue return correct test patterns. **Valida√ß√µes**: `patterns` = `\"**/*.test.{ts,tsx,js,jsx}\"`, `patterns` = `\"**/__tests__/**/*.{ts,tsx,js,jsx}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "patterns = ..."
    ],
    "when": "adapter.getTestPatterns",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/*.test.{ts,tsx,js,jsx}",
        "path": "patterns"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/__tests__/**/*.{ts,tsx,js,jsx}",
        "path": "patterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return correct test command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test command. **Valida√ß√µes**: `adapter.getTestCommand()` = `\"npm test\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "adapter.getTestCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return correct coverage command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct coverage command. **Valida√ß√µes**: `adapter.getCoverageCommand()` = `\"npm run test:coverage\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm run test:coverage",
        "path": "adapter.getCoverageCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should generate valid unit test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateUnitTest",
    "whatItTests": "Valida que **`adapter.generateUnitTest`** consegue generate valid unit test template. **Valida√ß√µes**: `result` = `\"import pytest\"`, `result` = `\"from src.utils.math import calculate_total\"`, `result` = `\"class TestCalculateTotal:\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateUnitTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import pytest",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from src.utils.math import calculate_total",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestCalculateTotal:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_calculate_total_with_valid_input",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_calculate_total_handles_errors",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@pytest.mark.parametrize",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should generate integration test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateIntegrationTest",
    "whatItTests": "Valida que **`adapter.generateIntegrationTest`** consegue generate integration test template. **Valida√ß√µes**: `result` = `\"from fastapi.testclient import TestClient\"`, `result` = `\"class TestUserServiceIntegration:\"`, `result` = `\"@pytest.fixture(autouse=True)\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateIntegrationTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from fastapi.testclient import TestClient",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestUserServiceIntegration:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@pytest.fixture(autouse=True)",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def setup_teardown",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should generate E2E test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateE2ETest",
    "whatItTests": "Valida que **`adapter.generateE2ETest`** consegue generate E2E test template. **Valida√ß√µes**: `result` = `\"from playwright.sync_api import Page\"`, `result` = `\"class TestLoginFlowE2E:\"`, `result` = `\"def test_complete_flow\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateE2ETest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from playwright.sync_api import Page",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestLoginFlowE2E:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_complete_flow",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should return correct test file extension",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test file extension. **Valida√ß√µes**: `adapter.getTestFileExtension()` = `\"_test.py\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.py",
        "path": "adapter.getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should return correct test patterns",
    "testType": "unit",
    "functionUnderTest": "adapter.getTestPatterns",
    "whatItTests": "Valida que **`adapter.getTestPatterns`** consegue return correct test patterns. **Valida√ß√µes**: `patterns` = `\"**/test_*.py\"`, `patterns` = `\"**/*_test.py\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "patterns = ..."
    ],
    "when": "adapter.getTestPatterns",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/test_*.py",
        "path": "patterns"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/*_test.py",
        "path": "patterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should return correct test command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test command. **Valida√ß√µes**: `adapter.getTestCommand()` = `\"pytest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "adapter.getTestCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should return correct coverage command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct coverage command. **Valida√ß√µes**: `adapter.getCoverageCommand()` = `\"pytest --cov=. --cov-report=json\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest --cov=. --cov-report=json",
        "path": "adapter.getCoverageCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should generate valid unit test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateUnitTest",
    "whatItTests": "Valida que **`adapter.generateUnitTest`** consegue generate valid unit test template. **Valida√ß√µes**: `result` = `\"import pytest\"`, `result` = `\"from src.utils.math import calculate_total\"`, `result` = `\"class TestCalculateTotal:\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateUnitTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import pytest",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from src.utils.math import calculate_total",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestCalculateTotal:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_calculate_total_with_valid_input",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_calculate_total_handles_errors",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@pytest.mark.parametrize",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should generate integration test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateIntegrationTest",
    "whatItTests": "Valida que **`adapter.generateIntegrationTest`** consegue generate integration test template. **Valida√ß√µes**: `result` = `\"from fastapi.testclient import TestClient\"`, `result` = `\"class TestUserServiceIntegration:\"`, `result` = `\"@pytest.fixture(autouse=True)\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateIntegrationTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from fastapi.testclient import TestClient",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestUserServiceIntegration:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@pytest.fixture(autouse=True)",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def setup_teardown",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should generate E2E test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateE2ETest",
    "whatItTests": "Valida que **`adapter.generateE2ETest`** consegue generate E2E test template. **Valida√ß√µes**: `result` = `\"from playwright.sync_api import Page\"`, `result` = `\"class TestLoginFlowE2E:\"`, `result` = `\"def test_complete_flow\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateE2ETest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from playwright.sync_api import Page",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestLoginFlowE2E:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_complete_flow",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return correct test file extension",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test file extension. **Valida√ß√µes**: `adapter.getTestFileExtension()` = `\"_test.py\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.py",
        "path": "adapter.getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return correct test patterns",
    "testType": "unit",
    "functionUnderTest": "adapter.getTestPatterns",
    "whatItTests": "Valida que **`adapter.getTestPatterns`** consegue return correct test patterns. **Valida√ß√µes**: `patterns` = `\"**/test_*.py\"`, `patterns` = `\"**/*_test.py\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "patterns = ..."
    ],
    "when": "adapter.getTestPatterns",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/test_*.py",
        "path": "patterns"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/*_test.py",
        "path": "patterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return correct test command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test command. **Valida√ß√µes**: `adapter.getTestCommand()` = `\"pytest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "adapter.getTestCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return correct coverage command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct coverage command. **Valida√ß√µes**: `adapter.getCoverageCommand()` = `\"pytest --cov=. --cov-report=json\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest --cov=. --cov-report=json",
        "path": "adapter.getCoverageCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "getLanguageAdapter > should return PythonAdapter for Python project",
    "testType": "unit",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue return PythonAdapter for Python project. **Valida√ß√µes**: `adapter.language` = `\"python\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "adapter.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "getLanguageAdapter > should return TypeScriptAdapter for TypeScript project",
    "testType": "unit",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue return TypeScriptAdapter for TypeScript project. **Valida√ß√µes**: `adapter.language` = `\"typescript\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "adapter.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return PythonAdapter for Python project",
    "testType": "unit",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue return PythonAdapter for Python project. **Valida√ß√µes**: `adapter.language` = `\"python\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "adapter.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should return TypeScriptAdapter for TypeScript project",
    "testType": "unit",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue return TypeScriptAdapter for TypeScript project. **Valida√ß√µes**: `adapter.language` = `\"typescript\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "adapter.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "createAdapter > should create TypeScriptAdapter",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue create TypeScriptAdapter. **Valida√ß√µes**: `adapter.language` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "adapter.language"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "createAdapter > should create PythonAdapter",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue create PythonAdapter. **Valida√ß√µes**: `adapter.language` = `\"python\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "adapter.language"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "createAdapter > should throw for unknown language",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue throw for unknown language. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should create TypeScriptAdapter",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue create TypeScriptAdapter. **Valida√ß√µes**: `adapter.language` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "adapter.language"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should create PythonAdapter",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue create PythonAdapter. **Valida√ß√µes**: `adapter.language` = `\"python\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "adapter.language"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "Language Adapters > should throw for unknown language",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue throw for unknown language. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should generate valid unit test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateUnitTest",
    "whatItTests": "Valida que **`adapter.generateUnitTest`** consegue generate valid unit test template. **Valida√ß√µes**: `result` = `\"import { describe, it, expect } from 'vitest'\"`, `result` = `\"import { calculateTotal } from './utils/math.js'\"`, `result` = `\"describe('calculateTotal'\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateUnitTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { describe, it, expect } from 'vitest'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { calculateTotal } from './utils/math.js'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "describe('calculateTotal'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should work correctly with valid input",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle errors appropriately",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle edge cases",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should generate integration test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateIntegrationTest",
    "whatItTests": "Valida que **`adapter.generateIntegrationTest`** consegue generate integration test template. **Valida√ß√µes**: `result` = `\"supertest\"`, `result` = `\"UserService Integration Tests\"`, `result` = `\"beforeEach\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateIntegrationTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "supertest",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "UserService Integration Tests",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "beforeEach",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "afterEach",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should generate E2E test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateE2ETest",
    "whatItTests": "Valida que **`adapter.generateE2ETest`** consegue generate E2E test template. **Valida√ß√µes**: `result` = `\"@playwright/test\"`, `result` = `\"LoginFlow\"`, `result` = `\"should complete LoginFlow flow\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateE2ETest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@playwright/test",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "LoginFlow",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should complete LoginFlow flow",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should return correct test file extension",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test file extension. **Valida√ß√µes**: `adapter.getTestFileExtension()` = `\".test.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".test.ts",
        "path": "adapter.getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should return correct test patterns",
    "testType": "unit",
    "functionUnderTest": "adapter.getTestPatterns",
    "whatItTests": "Valida que **`adapter.getTestPatterns`** consegue return correct test patterns. **Valida√ß√µes**: `patterns` = `\"**/*.test.{ts,tsx,js,jsx}\"`, `patterns` = `\"**/__tests__/**/*.{ts,tsx,js,jsx}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "patterns = ..."
    ],
    "when": "adapter.getTestPatterns",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/*.test.{ts,tsx,js,jsx}",
        "path": "patterns"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/__tests__/**/*.{ts,tsx,js,jsx}",
        "path": "patterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should return correct test command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test command. **Valida√ß√µes**: `adapter.getTestCommand()` = `\"npm test\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "adapter.getTestCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "TypeScriptAdapter > should return correct coverage command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct coverage command. **Valida√ß√µes**: `adapter.getCoverageCommand()` = `\"npm run test:coverage\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm run test:coverage",
        "path": "adapter.getCoverageCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should generate valid unit test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateUnitTest",
    "whatItTests": "Valida que **`adapter.generateUnitTest`** consegue generate valid unit test template. **Valida√ß√µes**: `result` = `\"import { describe, it, expect } from 'vitest'\"`, `result` = `\"import { calculateTotal } from './utils/math.js'\"`, `result` = `\"describe('calculateTotal'\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateUnitTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { describe, it, expect } from 'vitest'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import { calculateTotal } from './utils/math.js'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "describe('calculateTotal'",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should work correctly with valid input",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle errors appropriately",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should handle edge cases",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should generate integration test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateIntegrationTest",
    "whatItTests": "Valida que **`adapter.generateIntegrationTest`** consegue generate integration test template. **Valida√ß√µes**: `result` = `\"supertest\"`, `result` = `\"UserService Integration Tests\"`, `result` = `\"beforeEach\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateIntegrationTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "supertest",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "UserService Integration Tests",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "beforeEach",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "afterEach",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should generate E2E test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateE2ETest",
    "whatItTests": "Valida que **`adapter.generateE2ETest`** consegue generate E2E test template. **Valida√ß√µes**: `result` = `\"@playwright/test\"`, `result` = `\"LoginFlow\"`, `result` = `\"should complete LoginFlow flow\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateE2ETest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@playwright/test",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "LoginFlow",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "should complete LoginFlow flow",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return correct test file extension",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test file extension. **Valida√ß√µes**: `adapter.getTestFileExtension()` = `\".test.ts\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": ".test.ts",
        "path": "adapter.getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return correct test patterns",
    "testType": "unit",
    "functionUnderTest": "adapter.getTestPatterns",
    "whatItTests": "Valida que **`adapter.getTestPatterns`** consegue return correct test patterns. **Valida√ß√µes**: `patterns` = `\"**/*.test.{ts,tsx,js,jsx}\"`, `patterns` = `\"**/__tests__/**/*.{ts,tsx,js,jsx}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "patterns = ..."
    ],
    "when": "adapter.getTestPatterns",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/*.test.{ts,tsx,js,jsx}",
        "path": "patterns"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/__tests__/**/*.{ts,tsx,js,jsx}",
        "path": "patterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return correct test command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test command. **Valida√ß√µes**: `adapter.getTestCommand()` = `\"npm test\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm test",
        "path": "adapter.getTestCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return correct coverage command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct coverage command. **Valida√ß√µes**: `adapter.getCoverageCommand()` = `\"npm run test:coverage\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "npm run test:coverage",
        "path": "adapter.getCoverageCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should generate valid unit test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateUnitTest",
    "whatItTests": "Valida que **`adapter.generateUnitTest`** consegue generate valid unit test template. **Valida√ß√µes**: `result` = `\"import pytest\"`, `result` = `\"from src.utils.math import calculate_total\"`, `result` = `\"class TestCalculateTotal:\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateUnitTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import pytest",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from src.utils.math import calculate_total",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestCalculateTotal:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_calculate_total_with_valid_input",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_calculate_total_handles_errors",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@pytest.mark.parametrize",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should generate integration test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateIntegrationTest",
    "whatItTests": "Valida que **`adapter.generateIntegrationTest`** consegue generate integration test template. **Valida√ß√µes**: `result` = `\"from fastapi.testclient import TestClient\"`, `result` = `\"class TestUserServiceIntegration:\"`, `result` = `\"@pytest.fixture(autouse=True)\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateIntegrationTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from fastapi.testclient import TestClient",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestUserServiceIntegration:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@pytest.fixture(autouse=True)",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def setup_teardown",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should generate E2E test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateE2ETest",
    "whatItTests": "Valida que **`adapter.generateE2ETest`** consegue generate E2E test template. **Valida√ß√µes**: `result` = `\"from playwright.sync_api import Page\"`, `result` = `\"class TestLoginFlowE2E:\"`, `result` = `\"def test_complete_flow\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateE2ETest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from playwright.sync_api import Page",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestLoginFlowE2E:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_complete_flow",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should return correct test file extension",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test file extension. **Valida√ß√µes**: `adapter.getTestFileExtension()` = `\"_test.py\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.py",
        "path": "adapter.getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should return correct test patterns",
    "testType": "unit",
    "functionUnderTest": "adapter.getTestPatterns",
    "whatItTests": "Valida que **`adapter.getTestPatterns`** consegue return correct test patterns. **Valida√ß√µes**: `patterns` = `\"**/test_*.py\"`, `patterns` = `\"**/*_test.py\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "patterns = ..."
    ],
    "when": "adapter.getTestPatterns",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/test_*.py",
        "path": "patterns"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/*_test.py",
        "path": "patterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should return correct test command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test command. **Valida√ß√µes**: `adapter.getTestCommand()` = `\"pytest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "adapter.getTestCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "PythonAdapter > should return correct coverage command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct coverage command. **Valida√ß√µes**: `adapter.getCoverageCommand()` = `\"pytest --cov=. --cov-report=json\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest --cov=. --cov-report=json",
        "path": "adapter.getCoverageCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should generate valid unit test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateUnitTest",
    "whatItTests": "Valida que **`adapter.generateUnitTest`** consegue generate valid unit test template. **Valida√ß√µes**: `result` = `\"import pytest\"`, `result` = `\"from src.utils.math import calculate_total\"`, `result` = `\"class TestCalculateTotal:\"` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateUnitTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "import pytest",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from src.utils.math import calculate_total",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestCalculateTotal:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_calculate_total_with_valid_input",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_calculate_total_handles_errors",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@pytest.mark.parametrize",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should generate integration test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateIntegrationTest",
    "whatItTests": "Valida que **`adapter.generateIntegrationTest`** consegue generate integration test template. **Valida√ß√µes**: `result` = `\"from fastapi.testclient import TestClient\"`, `result` = `\"class TestUserServiceIntegration:\"`, `result` = `\"@pytest.fixture(autouse=True)\"` e mais 1",
    "whyItTests": "Valida 4 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~4) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateIntegrationTest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from fastapi.testclient import TestClient",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestUserServiceIntegration:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "@pytest.fixture(autouse=True)",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def setup_teardown",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should generate E2E test template",
    "testType": "unit",
    "functionUnderTest": "adapter.generateE2ETest",
    "whatItTests": "Valida que **`adapter.generateE2ETest`** consegue generate E2E test template. **Valida√ß√µes**: `result` = `\"from playwright.sync_api import Page\"`, `result` = `\"class TestLoginFlowE2E:\"`, `result` = `\"def test_complete_flow\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ..."
    ],
    "when": "adapter.generateE2ETest",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "from playwright.sync_api import Page",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "class TestLoginFlowE2E:",
        "path": "result"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "def test_complete_flow",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return correct test file extension",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test file extension. **Valida√ß√µes**: `adapter.getTestFileExtension()` = `\"_test.py\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "_test.py",
        "path": "adapter.getTestFileExtension()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return correct test patterns",
    "testType": "unit",
    "functionUnderTest": "adapter.getTestPatterns",
    "whatItTests": "Valida que **`adapter.getTestPatterns`** consegue return correct test patterns. **Valida√ß√µes**: `patterns` = `\"**/test_*.py\"`, `patterns` = `\"**/*_test.py\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "patterns = ..."
    ],
    "when": "adapter.getTestPatterns",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/test_*.py",
        "path": "patterns"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "**/*_test.py",
        "path": "patterns"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return correct test command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct test command. **Valida√ß√µes**: `adapter.getTestCommand()` = `\"pytest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest",
        "path": "adapter.getTestCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return correct coverage command",
    "testType": "unit",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue return correct coverage command. **Valida√ß√µes**: `adapter.getCoverageCommand()` = `\"pytest --cov=. --cov-report=json\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "pytest --cov=. --cov-report=json",
        "path": "adapter.getCoverageCommand()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "getLanguageAdapter > should return PythonAdapter for Python project",
    "testType": "unit",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue return PythonAdapter for Python project. **Valida√ß√µes**: `adapter.language` = `\"python\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "adapter.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "getLanguageAdapter > should return TypeScriptAdapter for TypeScript project",
    "testType": "unit",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue return TypeScriptAdapter for TypeScript project. **Valida√ß√µes**: `adapter.language` = `\"typescript\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "adapter.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return PythonAdapter for Python project",
    "testType": "unit",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue return PythonAdapter for Python project. **Valida√ß√µes**: `adapter.language` = `\"python\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "adapter.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should return TypeScriptAdapter for TypeScript project",
    "testType": "unit",
    "functionUnderTest": "writeFile",
    "whatItTests": "Valida que **`writeFile`** consegue return TypeScriptAdapter for TypeScript project. **Valida√ß√µes**: `adapter.language` = `\"typescript\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "adapter.language"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "createAdapter > should create TypeScriptAdapter",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue create TypeScriptAdapter. **Valida√ß√µes**: `adapter.language` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "adapter.language"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "createAdapter > should create PythonAdapter",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue create PythonAdapter. **Valida√ß√µes**: `adapter.language` = `\"python\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "adapter.language"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "createAdapter > should throw for unknown language",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue throw for unknown language. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should create TypeScriptAdapter",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue create TypeScriptAdapter. **Valida√ß√µes**: `adapter.language` = `\"typescript\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "adapter.language"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should create PythonAdapter",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue create PythonAdapter. **Valida√ß√µes**: `adapter.language` = `\"python\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "python",
        "path": "adapter.language"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/adapters/__tests__/adapters.test.ts",
    "name": "should throw for unknown language",
    "testType": "unit",
    "functionUnderTest": "createAdapter",
    "whatItTests": "Valida que **`createAdapter`** consegue throw for unknown language. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "adapter = ..."
    ],
    "when": "createAdapter",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "adapter"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
    "name": "Fluxo: Recommend ‚Üí Scaffold > deve recomendar quais arquivos testar primeiro",
    "testType": "integration",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue recomendar quais arquivos testar primeiro. **Valida√ß√µes**: `recommendation.ok` = `true`, `unknown` = `0`, `parserFile.priority` = `\"HIGH\"` e mais 1",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "recommendation = ...",
      "priorities = ...",
      "parserFile = ...",
      "configFile = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "recommendation.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "recommendation.recommendation"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "parserFile.priority"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "configFile.priority"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
    "name": "Fluxo: Recommend ‚Üí Scaffold > deve criar testes para arquivos de alta prioridade",
    "testType": "integration",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue criar testes para arquivos de alta prioridade. **Valida√ß√µes**: `scaffoldResult.ok` = `true`, `Array.isArray()` = `true`, `scaffoldResult.framework` = `\"vitest\"` e mais 4",
    "whyItTests": "Valida 9 aspecto(s) usando: toBe, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~9) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldResult = ...",
      "firstTestPath = ...",
      "testExists = ...",
      "firstTestPath = ...",
      "testContent = ...",
      "packageJsonPath = ...",
      "packageJsonExists = ...",
      "packageJson = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "scaffoldResult.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "scaffoldResult.generated"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "scaffoldResult.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "testExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "expect",
        "path": "testContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "vitest",
        "path": "testContent"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "vitest",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
    "name": "Fluxo: Recommend ‚Üí Scaffold > deve criar testes com framework recomendado",
    "testType": "integration",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue criar testes com framework recomendado. **Valida√ß√µes**: `result.ok` = `true`, `packageJson.scripts.test` = `\"jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ...",
      "testPath = ...",
      "testExists = ...",
      "testContent = ...",
      "packageJson = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "jest",
        "path": "packageJson.scripts.test"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
    "name": "deve recomendar quais arquivos testar primeiro",
    "testType": "integration",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue recomendar quais arquivos testar primeiro. **Valida√ß√µes**: `recommendation.ok` = `true`, `unknown` = `0`, `parserFile.priority` = `\"HIGH\"` e mais 1",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toBeDefined, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "recommendation = ...",
      "priorities = ...",
      "parserFile = ...",
      "configFile = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "recommendation.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "recommendation.recommendation"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "parserFile.priority"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "LOW",
        "path": "configFile.priority"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
    "name": "deve criar testes para arquivos de alta prioridade",
    "testType": "integration",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue criar testes para arquivos de alta prioridade. **Valida√ß√µes**: `scaffoldResult.ok` = `true`, `Array.isArray()` = `true`, `scaffoldResult.framework` = `\"vitest\"` e mais 4",
    "whyItTests": "Valida 9 aspecto(s) usando: toBe, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~9) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldResult = ...",
      "firstTestPath = ...",
      "testExists = ...",
      "firstTestPath = ...",
      "testContent = ...",
      "packageJsonPath = ...",
      "packageJsonExists = ...",
      "packageJson = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "scaffoldResult.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "scaffoldResult.generated"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "scaffoldResult.framework"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "testExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "expect",
        "path": "testContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "vitest",
        "path": "testContent"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "vitest",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
    "name": "deve criar testes com framework recomendado",
    "testType": "integration",
    "functionUnderTest": "fs.writeFile",
    "whatItTests": "Valida que **`fs.writeFile`** consegue criar testes com framework recomendado. **Valida√ß√µes**: `result.ok` = `true`, `packageJson.scripts.test` = `\"jest\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "result = ...",
      "testPath = ...",
      "testExists = ...",
      "testContent = ...",
      "packageJson = ..."
    ],
    "when": "fs.writeFile",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "jest",
        "path": "packageJson.scripts.test"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "ListTools > should have nl_command tool available",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have nl_command tool available. **Valida√ß√µes**: `toolName` = `\"nl_command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "toolName = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nl_command",
        "path": "toolName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "ListTools > should have auto tool available",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have auto tool available. **Valida√ß√µes**: `toolName` = `\"auto\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "toolName = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auto",
        "path": "toolName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "ListTools > should have nl_command as high priority tool",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have nl_command as high priority tool. **Valida√ß√µes**: `priorityTools.?` = `\"nl_command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "priorityTools = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nl_command",
        "path": "priorityTools.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "ListTools > should have auto as second priority tool",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have auto as second priority tool. **Valida√ß√µes**: `priorityTools.?` = `\"auto\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "priorityTools = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auto",
        "path": "priorityTools.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should have nl_command tool available",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have nl_command tool available. **Valida√ß√µes**: `toolName` = `\"nl_command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "toolName = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nl_command",
        "path": "toolName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should have auto tool available",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have auto tool available. **Valida√ß√µes**: `toolName` = `\"auto\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "toolName = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auto",
        "path": "toolName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should have nl_command as high priority tool",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have nl_command as high priority tool. **Valida√ß√µes**: `priorityTools.?` = `\"nl_command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "priorityTools = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nl_command",
        "path": "priorityTools.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should have auto as second priority tool",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have auto as second priority tool. **Valida√ß√µes**: `priorityTools.?` = `\"auto\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "priorityTools = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auto",
        "path": "priorityTools.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "nl_command tool > should accept valid natural language query",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept valid natural language query. **Valida√ß√µes**: `validParams.query` = `\"analise meu reposit√≥rio\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analise meu reposit√≥rio",
        "path": "validParams.query"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "nl_command tool > should accept query with defaults",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept query with defaults. **Valida√ß√µes**: `unknown` = `\"run\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "nl_command tool > should reject empty query",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue reject empty query. **Valida√ß√µes**: `unknown` = `\"Query cannot be empty\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Query cannot be empty",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should accept valid natural language query",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept valid natural language query. **Valida√ß√µes**: `validParams.query` = `\"analise meu reposit√≥rio\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analise meu reposit√≥rio",
        "path": "validParams.query"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should accept query with defaults",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept query with defaults. **Valida√ß√µes**: `unknown` = `\"run\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should reject empty query",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue reject empty query. **Valida√ß√µes**: `unknown` = `\"Query cannot be empty\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Query cannot be empty",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "auto tool > should accept valid mode",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept valid mode. **Valida√ß√µes**: `validParams.mode` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "validParams.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "auto tool > should accept all modes",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept all modes. **Valida√ß√µes**: `params.mode` = `\"mode\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "modes = ...",
      "params = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mode",
        "path": "params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "auto tool > should accept skip flags",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept skip flags. **Valida√ß√µes**: `params.skipScaffold` = `true`, `params.skipRun` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "params = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "params.skipScaffold"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "params.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "auto tool > should work with minimal params (auto-detection)",
    "testType": "integration",
    "functionUnderTest": ".toBeDefined",
    "whatItTests": "Valida que **`.toBeDefined`** consegue work with minimal params (auto-detection). **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "params = ..."
    ],
    "when": ".toBeDefined",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "params"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should accept valid mode",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept valid mode. **Valida√ß√µes**: `validParams.mode` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "validParams.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should accept all modes",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept all modes. **Valida√ß√µes**: `params.mode` = `\"mode\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "modes = ...",
      "params = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mode",
        "path": "params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should accept skip flags",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept skip flags. **Valida√ß√µes**: `params.skipScaffold` = `true`, `params.skipRun` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "params = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "params.skipScaffold"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "params.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should work with minimal params (auto-detection)",
    "testType": "integration",
    "functionUnderTest": ".toBeDefined",
    "whatItTests": "Valida que **`.toBeDefined`** consegue work with minimal params (auto-detection). **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "params = ..."
    ],
    "when": ".toBeDefined",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "params"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Schema Validation > should validate nl_command schema structure",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue validate nl_command schema structure. **Valida√ß√µes**: `expectedProperties` = `\"query\"`, `expectedProperties` = `\"defaults\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "expectedProperties = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "query",
        "path": "expectedProperties"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "defaults",
        "path": "expectedProperties"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Schema Validation > should validate auto schema structure",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue validate auto schema structure. **Valida√ß√µes**: `expectedProperties` = `\"mode\"`, `expectedProperties` = `\"repo\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "expectedProperties = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mode",
        "path": "expectedProperties"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "expectedProperties"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Schema Validation > should have correct mode enum values",
    "testType": "integration",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue have correct mode enum values. **Valida√ß√µes**: `validModes` = `5`, `validModes` = `\"full\"`, `validModes` = `\"analyze\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validModes = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "validModes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "full",
        "path": "validModes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "validModes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should validate nl_command schema structure",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue validate nl_command schema structure. **Valida√ß√µes**: `expectedProperties` = `\"query\"`, `expectedProperties` = `\"defaults\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "expectedProperties = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "query",
        "path": "expectedProperties"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "defaults",
        "path": "expectedProperties"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should validate auto schema structure",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue validate auto schema structure. **Valida√ß√µes**: `expectedProperties` = `\"mode\"`, `expectedProperties` = `\"repo\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "expectedProperties = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mode",
        "path": "expectedProperties"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "expectedProperties"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should have correct mode enum values",
    "testType": "integration",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue have correct mode enum values. **Valida√ß√µes**: `validModes` = `5`, `validModes` = `\"full\"`, `validModes` = `\"analyze\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validModes = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "validModes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "full",
        "path": "validModes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "validModes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Integration Flow > should support nl_command ‚Üí auto flow",
    "testType": "integration",
    "functionUnderTest": ".toBeTruthy",
    "whatItTests": "Valida que **`.toBeTruthy`** consegue support nl_command ‚Üí auto flow. **Valida√ß√µes**: `unknown` = `\"tempDir\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeTruthy, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "nlParams = ..."
    ],
    "when": ".toBeTruthy",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeTruthy",
        "path": "nlParams.query"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Integration Flow > should support direct auto invocation",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue support direct auto invocation. **Valida√ß√µes**: `autoParams.mode` = `\"analyze\"`, `autoParams.repo` = `\"tempDir\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "autoParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "autoParams.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "autoParams.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Integration Flow > should support defaults override in nl_command",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue support defaults override in nl_command. **Valida√ß√µes**: `unknown` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "nlParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should support nl_command ‚Üí auto flow",
    "testType": "integration",
    "functionUnderTest": ".toBeTruthy",
    "whatItTests": "Valida que **`.toBeTruthy`** consegue support nl_command ‚Üí auto flow. **Valida√ß√µes**: `unknown` = `\"tempDir\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeTruthy, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "nlParams = ..."
    ],
    "when": ".toBeTruthy",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeTruthy",
        "path": "nlParams.query"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should support direct auto invocation",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue support direct auto invocation. **Valida√ß√µes**: `autoParams.mode` = `\"analyze\"`, `autoParams.repo` = `\"tempDir\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "autoParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "autoParams.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "autoParams.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should support defaults override in nl_command",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue support defaults override in nl_command. **Valida√ß√µes**: `unknown` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "nlParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Error Handling > should handle invalid mode gracefully",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue handle invalid mode gracefully. **Valida√ß√µes**: `unknown` = `\"Invalid mode\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Invalid mode",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Error Handling > should handle missing required params",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue handle missing required params. **Valida√ß√µes**: `unknown` = `\"Query is required\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Query is required",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should handle invalid mode gracefully",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue handle invalid mode gracefully. **Valida√ß√µes**: `unknown` = `\"Invalid mode\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Invalid mode",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should handle missing required params",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue handle missing required params. **Valida√ß√µes**: `unknown` = `\"Query is required\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Query is required",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Tool Descriptions > should have descriptive nl_command description",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue have descriptive nl_command description. **Valida√ß√µes**: `description` = `\"linguagem natural\"`, `description` = `\"PT/EN\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "description = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "linguagem natural",
        "path": "description"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "PT/EN",
        "path": "description"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Tool Descriptions > should have descriptive auto description",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue have descriptive auto description. **Valida√ß√µes**: `description` = `\"Orquestrador\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "description = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Orquestrador",
        "path": "description"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Tool Descriptions > should mention supported languages in nl_command",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue mention supported languages in nl_command. **Valida√ß√µes**: `examples` = `\"analise meu reposit√≥rio\"`, `examples` = `\"criar plano\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "examples = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analise meu reposit√≥rio",
        "path": "examples"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "criar plano",
        "path": "examples"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Tool Descriptions > should mention available modes in auto",
    "testType": "integration",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue mention available modes in auto. **Valida√ß√µes**: `modes` = `5`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "modes = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "modes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should have descriptive nl_command description",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue have descriptive nl_command description. **Valida√ß√µes**: `description` = `\"linguagem natural\"`, `description` = `\"PT/EN\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "description = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "linguagem natural",
        "path": "description"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "PT/EN",
        "path": "description"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should have descriptive auto description",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue have descriptive auto description. **Valida√ß√µes**: `description` = `\"Orquestrador\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "description = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Orquestrador",
        "path": "description"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should mention supported languages in nl_command",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue mention supported languages in nl_command. **Valida√ß√µes**: `examples` = `\"analise meu reposit√≥rio\"`, `examples` = `\"criar plano\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "examples = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analise meu reposit√≥rio",
        "path": "examples"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "criar plano",
        "path": "examples"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "MCP Server Integration > should mention available modes in auto",
    "testType": "integration",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue mention available modes in auto. **Valida√ß√µes**: `modes` = `5`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "modes = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "modes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "ListTools > should have nl_command tool available",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have nl_command tool available. **Valida√ß√µes**: `toolName` = `\"nl_command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "toolName = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nl_command",
        "path": "toolName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "ListTools > should have auto tool available",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have auto tool available. **Valida√ß√µes**: `toolName` = `\"auto\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "toolName = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auto",
        "path": "toolName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "ListTools > should have nl_command as high priority tool",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have nl_command as high priority tool. **Valida√ß√µes**: `priorityTools.?` = `\"nl_command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "priorityTools = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nl_command",
        "path": "priorityTools.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "ListTools > should have auto as second priority tool",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have auto as second priority tool. **Valida√ß√µes**: `priorityTools.?` = `\"auto\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "priorityTools = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auto",
        "path": "priorityTools.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should have nl_command tool available",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have nl_command tool available. **Valida√ß√µes**: `toolName` = `\"nl_command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "toolName = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nl_command",
        "path": "toolName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should have auto tool available",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have auto tool available. **Valida√ß√µes**: `toolName` = `\"auto\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "toolName = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auto",
        "path": "toolName"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should have nl_command as high priority tool",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have nl_command as high priority tool. **Valida√ß√µes**: `priorityTools.?` = `\"nl_command\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "priorityTools = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "nl_command",
        "path": "priorityTools.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should have auto as second priority tool",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue have auto as second priority tool. **Valida√ß√µes**: `priorityTools.?` = `\"auto\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "priorityTools = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "auto",
        "path": "priorityTools.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "nl_command tool > should accept valid natural language query",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept valid natural language query. **Valida√ß√µes**: `validParams.query` = `\"analise meu reposit√≥rio\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analise meu reposit√≥rio",
        "path": "validParams.query"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "nl_command tool > should accept query with defaults",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept query with defaults. **Valida√ß√µes**: `unknown` = `\"run\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "nl_command tool > should reject empty query",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue reject empty query. **Valida√ß√µes**: `unknown` = `\"Query cannot be empty\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Query cannot be empty",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should accept valid natural language query",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept valid natural language query. **Valida√ß√µes**: `validParams.query` = `\"analise meu reposit√≥rio\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analise meu reposit√≥rio",
        "path": "validParams.query"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should accept query with defaults",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept query with defaults. **Valida√ß√µes**: `unknown` = `\"run\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "run",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should reject empty query",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue reject empty query. **Valida√ß√µes**: `unknown` = `\"Query cannot be empty\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Query cannot be empty",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "auto tool > should accept valid mode",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept valid mode. **Valida√ß√µes**: `validParams.mode` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "validParams.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "auto tool > should accept all modes",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept all modes. **Valida√ß√µes**: `params.mode` = `\"mode\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "modes = ...",
      "params = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mode",
        "path": "params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "auto tool > should accept skip flags",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept skip flags. **Valida√ß√µes**: `params.skipScaffold` = `true`, `params.skipRun` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "params = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "params.skipScaffold"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "params.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "auto tool > should work with minimal params (auto-detection)",
    "testType": "integration",
    "functionUnderTest": ".toBeDefined",
    "whatItTests": "Valida que **`.toBeDefined`** consegue work with minimal params (auto-detection). **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "params = ..."
    ],
    "when": ".toBeDefined",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "params"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should accept valid mode",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept valid mode. **Valida√ß√µes**: `validParams.mode` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "validParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "validParams.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should accept all modes",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept all modes. **Valida√ß√µes**: `params.mode` = `\"mode\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "modes = ...",
      "params = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "mode",
        "path": "params.mode"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should accept skip flags",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue accept skip flags. **Valida√ß√µes**: `params.skipScaffold` = `true`, `params.skipRun` = `false`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "params = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "params.skipScaffold"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "params.skipRun"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should work with minimal params (auto-detection)",
    "testType": "integration",
    "functionUnderTest": ".toBeDefined",
    "whatItTests": "Valida que **`.toBeDefined`** consegue work with minimal params (auto-detection). **1 valida√ß√µes** usando: toBeDefined",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "params = ..."
    ],
    "when": ".toBeDefined",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "params"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "fraco",
    "smells": [],
    "suggestions": [
      "Trocar toBeTruthy/toBeFalsy por matchers espec√≠ficos",
      "Validar status + corpo + headers em vez de s√≥ chamadas",
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Schema Validation > should validate nl_command schema structure",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue validate nl_command schema structure. **Valida√ß√µes**: `expectedProperties` = `\"query\"`, `expectedProperties` = `\"defaults\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "expectedProperties = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "query",
        "path": "expectedProperties"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "defaults",
        "path": "expectedProperties"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Schema Validation > should validate auto schema structure",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue validate auto schema structure. **Valida√ß√µes**: `expectedProperties` = `\"mode\"`, `expectedProperties` = `\"repo\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "expectedProperties = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mode",
        "path": "expectedProperties"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "expectedProperties"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Schema Validation > should have correct mode enum values",
    "testType": "integration",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue have correct mode enum values. **Valida√ß√µes**: `validModes` = `5`, `validModes` = `\"full\"`, `validModes` = `\"analyze\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validModes = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "validModes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "full",
        "path": "validModes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "validModes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should validate nl_command schema structure",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue validate nl_command schema structure. **Valida√ß√µes**: `expectedProperties` = `\"query\"`, `expectedProperties` = `\"defaults\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "expectedProperties = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "query",
        "path": "expectedProperties"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "defaults",
        "path": "expectedProperties"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should validate auto schema structure",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue validate auto schema structure. **Valida√ß√µes**: `expectedProperties` = `\"mode\"`, `expectedProperties` = `\"repo\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "expectedProperties = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "mode",
        "path": "expectedProperties"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "repo",
        "path": "expectedProperties"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should have correct mode enum values",
    "testType": "integration",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue have correct mode enum values. **Valida√ß√µes**: `validModes` = `5`, `validModes` = `\"full\"`, `validModes` = `\"analyze\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "validModes = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "validModes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "full",
        "path": "validModes"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analyze",
        "path": "validModes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Integration Flow > should support nl_command ‚Üí auto flow",
    "testType": "integration",
    "functionUnderTest": ".toBeTruthy",
    "whatItTests": "Valida que **`.toBeTruthy`** consegue support nl_command ‚Üí auto flow. **Valida√ß√µes**: `unknown` = `\"tempDir\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeTruthy, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "nlParams = ..."
    ],
    "when": ".toBeTruthy",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeTruthy",
        "path": "nlParams.query"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Integration Flow > should support direct auto invocation",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue support direct auto invocation. **Valida√ß√µes**: `autoParams.mode` = `\"analyze\"`, `autoParams.repo` = `\"tempDir\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "autoParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "autoParams.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "autoParams.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Integration Flow > should support defaults override in nl_command",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue support defaults override in nl_command. **Valida√ß√µes**: `unknown` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "nlParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should support nl_command ‚Üí auto flow",
    "testType": "integration",
    "functionUnderTest": ".toBeTruthy",
    "whatItTests": "Valida que **`.toBeTruthy`** consegue support nl_command ‚Üí auto flow. **Valida√ß√µes**: `unknown` = `\"tempDir\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBeTruthy, toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "nlParams = ..."
    ],
    "when": ".toBeTruthy",
    "then": [
      {
        "type": "generic",
        "matcher": "toBeTruthy",
        "path": "nlParams.query"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should support direct auto invocation",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue support direct auto invocation. **Valida√ß√µes**: `autoParams.mode` = `\"analyze\"`, `autoParams.repo` = `\"tempDir\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "autoParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "analyze",
        "path": "autoParams.mode"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "tempDir",
        "path": "autoParams.repo"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should support defaults override in nl_command",
    "testType": "integration",
    "functionUnderTest": ".toBe",
    "whatItTests": "Valida que **`.toBe`** consegue support defaults override in nl_command. **Valida√ß√µes**: `unknown` = `\"full\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "nlParams = ..."
    ],
    "when": ".toBe",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "full",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Error Handling > should handle invalid mode gracefully",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue handle invalid mode gracefully. **Valida√ß√µes**: `unknown` = `\"Invalid mode\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Invalid mode",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Error Handling > should handle missing required params",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue handle missing required params. **Valida√ß√µes**: `unknown` = `\"Query is required\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Query is required",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should handle invalid mode gracefully",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue handle invalid mode gracefully. **Valida√ß√µes**: `unknown` = `\"Invalid mode\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Invalid mode",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should handle missing required params",
    "testType": "integration",
    "functionUnderTest": ".toThrow",
    "whatItTests": "Valida que **`.toThrow`** consegue handle missing required params. **Valida√ß√µes**: `unknown` = `\"Query is required\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toThrow",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "N√ÉO DETERMINADO (sem evid√™ncia)"
    ],
    "when": ".toThrow",
    "then": [
      {
        "type": "value",
        "matcher": "toThrow",
        "value": "Query is required",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Tool Descriptions > should have descriptive nl_command description",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue have descriptive nl_command description. **Valida√ß√µes**: `description` = `\"linguagem natural\"`, `description` = `\"PT/EN\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "description = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "linguagem natural",
        "path": "description"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "PT/EN",
        "path": "description"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Tool Descriptions > should have descriptive auto description",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue have descriptive auto description. **Valida√ß√µes**: `description` = `\"Orquestrador\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "description = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Orquestrador",
        "path": "description"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Tool Descriptions > should mention supported languages in nl_command",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue mention supported languages in nl_command. **Valida√ß√µes**: `examples` = `\"analise meu reposit√≥rio\"`, `examples` = `\"criar plano\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "examples = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analise meu reposit√≥rio",
        "path": "examples"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "criar plano",
        "path": "examples"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "Tool Descriptions > should mention available modes in auto",
    "testType": "integration",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue mention available modes in auto. **Valida√ß√µes**: `modes` = `5`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "modes = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "modes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should have descriptive nl_command description",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue have descriptive nl_command description. **Valida√ß√µes**: `description` = `\"linguagem natural\"`, `description` = `\"PT/EN\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "description = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "linguagem natural",
        "path": "description"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "PT/EN",
        "path": "description"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should have descriptive auto description",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue have descriptive auto description. **Valida√ß√µes**: `description` = `\"Orquestrador\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "description = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Orquestrador",
        "path": "description"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should mention supported languages in nl_command",
    "testType": "integration",
    "functionUnderTest": ".toContain",
    "whatItTests": "Valida que **`.toContain`** consegue mention supported languages in nl_command. **Valida√ß√µes**: `examples` = `\"analise meu reposit√≥rio\"`, `examples` = `\"criar plano\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "examples = ..."
    ],
    "when": ".toContain",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "analise meu reposit√≥rio",
        "path": "examples"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "criar plano",
        "path": "examples"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
    "name": "should mention available modes in auto",
    "testType": "integration",
    "functionUnderTest": ".toHaveLength",
    "whatItTests": "Valida que **`.toHaveLength`** consegue mention available modes in auto. **Valida√ß√µes**: `modes` = `5`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "modes = ..."
    ],
    "when": ".toHaveLength",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 5,
        "path": "modes"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
    "name": "Fluxo: Coverage ‚Üí Recommendations > deve gerar recomenda√ß√µes baseadas na cobertura atual",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar recomenda√ß√µes baseadas na cobertura atual. **Valida√ß√µes**: `coverage.summary` = `\"Status:\"`, `coverage.summary` = `\"Pir√¢mide\"`, `coverage.pyramid.unit.files_found` = `0` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toContain, toBeGreaterThanOrEqual, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "hasUnitRecommendation = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Status:",
        "path": "coverage.summary"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Pir√¢mide",
        "path": "coverage.summary"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "coverage.pyramid.unit.files_found"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "coverage.pyramid.e2e.files_found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "inverted",
        "path": "coverage.health"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "coverage.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasUnitRecommendation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
    "name": "Fluxo: Coverage ‚Üí Recommendations > deve usar coverage analysis para gerar relat√≥rio visual",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue usar coverage analysis para gerar relat√≥rio visual. **Valida√ß√µes**: `coverage.health` = `\"healthy\"`, `pyramidReport.ok` = `true`, `pyramidReport.report_path` = `{}` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toMatch, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "pyramidReport = ...",
      "htmlPath = ...",
      "htmlExists = ...",
      "htmlContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "healthy",
        "path": "coverage.health"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "pyramidReport.ok"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "pyramidReport.report_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "htmlExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 500,
        "path": "htmlContent.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
    "name": "Fluxo: Coverage ‚Üí Recommendations > deve gerar recomenda√ß√µes espec√≠ficas baseadas em gaps",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar recomenda√ß√µes espec√≠ficas baseadas em gaps. **Valida√ß√µes**: `coverage.pyramid.unit.files_found` = `0`, `coverage.pyramid.unit.missing_tests.length` = `0`, `coverage.recommendations.length` = `0` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "report = ...",
      "mdPath = ...",
      "mdExists = ...",
      "mdContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "coverage.pyramid.unit.files_found"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "coverage.pyramid.unit.missing_tests.length"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "coverage.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "report.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 100,
        "path": "mdContent.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
    "name": "deve gerar recomenda√ß√µes baseadas na cobertura atual",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar recomenda√ß√µes baseadas na cobertura atual. **Valida√ß√µes**: `coverage.summary` = `\"Status:\"`, `coverage.summary` = `\"Pir√¢mide\"`, `coverage.pyramid.unit.files_found` = `0` e mais 4",
    "whyItTests": "Valida 7 aspecto(s) usando: toContain, toBeGreaterThanOrEqual, toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~7) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "hasUnitRecommendation = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Status:",
        "path": "coverage.summary"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Pir√¢mide",
        "path": "coverage.summary"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "coverage.pyramid.unit.files_found"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "coverage.pyramid.e2e.files_found"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "inverted",
        "path": "coverage.health"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "coverage.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "hasUnitRecommendation"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
    "name": "deve usar coverage analysis para gerar relat√≥rio visual",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue usar coverage analysis para gerar relat√≥rio visual. **Valida√ß√µes**: `coverage.health` = `\"healthy\"`, `pyramidReport.ok` = `true`, `pyramidReport.report_path` = `{}` e mais 3",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe, toMatch, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "pyramidReport = ...",
      "htmlPath = ...",
      "htmlExists = ...",
      "htmlContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "healthy",
        "path": "coverage.health"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "pyramidReport.ok"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "pyramidReport.report_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "htmlExists"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 500,
        "path": "htmlContent.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
    "name": "deve gerar recomenda√ß√µes espec√≠ficas baseadas em gaps",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar recomenda√ß√µes espec√≠ficas baseadas em gaps. **Valida√ß√µes**: `coverage.pyramid.unit.files_found` = `0`, `coverage.pyramid.unit.missing_tests.length` = `0`, `coverage.recommendations.length` = `0` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "coverage = ...",
      "report = ...",
      "mdPath = ...",
      "mdExists = ...",
      "mdContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": 0,
        "path": "coverage.pyramid.unit.files_found"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "coverage.pyramid.unit.missing_tests.length"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "coverage.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "report.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 100,
        "path": "mdContent.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
    "name": "Fluxo: An√°lise ‚Üí Plano > deve gerar plano baseado nos findings da an√°lise",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar plano baseado nos findings da an√°lise. **Valida√ß√µes**: `analysis.findings.routes` = `\"/login\"`, `analysis.findings.endpoints.length` = `0`, `plan.ok` = `true` e mais 4",
    "whyItTests": "Valida 8 aspecto(s) usando: toContain, toBeGreaterThan, toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~8) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analysis = ...",
      "plan = ...",
      "planPath = ...",
      "planExists = ...",
      "planContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/login",
        "path": "analysis.findings.routes"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "analysis.findings.endpoints.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "plan.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "plan.plan"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "planExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Test App",
        "path": "planContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Playwright",
        "path": "planContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "playwright.config.ts",
        "path": "planContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
    "name": "Fluxo: An√°lise ‚Üí Plano > deve incluir recomenda√ß√µes da an√°lise no plano",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue incluir recomenda√ß√µes da an√°lise no plano. **Valida√ß√µes**: `analysis.recommendations.length` = `0`, `plan.ok` = `true`, `planContent` = `\"Cen√°rios\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBeGreaterThan, toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analysis = ...",
      "plan = ...",
      "planPath = ...",
      "planContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "analysis.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "plan.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Cen√°rios",
        "path": "planContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Risco",
        "path": "planContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Playwright",
        "path": "planContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
    "name": "Fluxo: An√°lise ‚Üí Plano > deve organizar plano por dom√≠nios quando especificados",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue organizar plano por dom√≠nios quando especificados. **Valida√ß√µes**: `plan.ok` = `true`, `planContent.length` = `100`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analysis = ...",
      "plan = ...",
      "planContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "plan.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 100,
        "path": "planContent.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
    "name": "deve gerar plano baseado nos findings da an√°lise",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue gerar plano baseado nos findings da an√°lise. **Valida√ß√µes**: `analysis.findings.routes` = `\"/login\"`, `analysis.findings.endpoints.length` = `0`, `plan.ok` = `true` e mais 4",
    "whyItTests": "Valida 8 aspecto(s) usando: toContain, toBeGreaterThan, toBe, toBeDefined",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~8) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analysis = ...",
      "plan = ...",
      "planPath = ...",
      "planExists = ...",
      "planContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "/login",
        "path": "analysis.findings.routes"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "analysis.findings.endpoints.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "plan.ok"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "plan.plan"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "planExists"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Test App",
        "path": "planContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Playwright",
        "path": "planContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "playwright.config.ts",
        "path": "planContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
    "name": "deve incluir recomenda√ß√µes da an√°lise no plano",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue incluir recomenda√ß√µes da an√°lise no plano. **Valida√ß√µes**: `analysis.recommendations.length` = `0`, `plan.ok` = `true`, `planContent` = `\"Cen√°rios\"` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toBeGreaterThan, toBe, toContain",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analysis = ...",
      "plan = ...",
      "planPath = ...",
      "planContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "analysis.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "plan.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Cen√°rios",
        "path": "planContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Risco",
        "path": "planContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Playwright",
        "path": "planContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
    "name": "deve organizar plano por dom√≠nios quando especificados",
    "testType": "integration",
    "functionUnderTest": "fs.mkdir",
    "whatItTests": "Valida que **`fs.mkdir`** consegue organizar plano por dom√≠nios quando especificados. **Valida√ß√µes**: `plan.ok` = `true`, `planContent.length` = `100`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe, toBeGreaterThan",
    "purposeForWhat": "üìâ **CFR**: Prevenir breaking changes em APIs/contratos (compatibility checks)\n- ‚è±Ô∏è **MTTR**: Identificar exatamente qual servi√ßo/m√≥dulo causou a falha",
    "given": [
      "analysis = ...",
      "plan = ...",
      "planContent = ..."
    ],
    "when": "fs.mkdir",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "plan.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 100,
        "path": "planContent.length"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
    "name": "FASE 3: CDC/Pact E2E Tests > [1/4] scaffold_contracts_pact - deve detectar servi√ßos e gerar contratos",
    "testType": "e2e",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue detectar servi√ßos e gerar contratos. **Valida√ß√µes**: `result.ok` = `true`, `result.message` = `\"Generated\"`, `result.total_contracts` = `0` e mais 17",
    "whyItTests": "Valida 29 aspecto(s) usando: toBe, toContain, toBeGreaterThan, toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~29) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalog = ...",
      "configContent = ...",
      "testContent = ...",
      "testContent = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Generated",
        "path": "result.message"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_contracts"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_interactions"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.catalog_path"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.config_path"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.consumer_tests"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.provider_tests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "catalog.timestamp"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "test-cdc-app",
        "path": "catalog.product"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "catalog.services"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "catalog.services.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "catalog.potential_contracts"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "catalog.coverage"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "catalog.coverage.total_integrations"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "pactConfig",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test-cdc-app",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "consumer",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "provider",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "consumer",
        "path": "testContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "provider",
        "path": "testContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "interaction",
        "path": "testContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "verify",
        "path": "testContent"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.recommendations.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
    "name": "FASE 3: CDC/Pact E2E Tests > [2/4] scaffold_contracts_pact - deve detectar m√∫ltiplas APIs corretamente",
    "testType": "e2e",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue detectar m√∫ltiplas APIs corretamente. **Valida√ß√µes**: `serviceNames.some()` = `true`, `Array.isArray()` = `true`, `service.endpoints.?` = `\"method\"` e mais 5",
    "whyItTests": "Valida 10 aspecto(s) usando: toBe, toBeDefined, toHaveProperty, toContain, toBeGreaterThanOrEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~10) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalog = ...",
      "serviceNames = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "serviceNames.some()"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "service.endpoints"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "method",
        "path": "service.endpoints.?"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "path",
        "path": "service.endpoints.?"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "consumer",
        "path": "contract"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "provider",
        "path": "contract"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "priority",
        "path": "contract"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "contract.estimated_interactions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
    "name": "FASE 3: CDC/Pact E2E Tests > [3/4] run_contracts_verify - deve verificar contratos gerados",
    "testType": "e2e",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue verificar contratos gerados. **Valida√ß√µes**: `result.ok` = `true`, `result.verification_rate` = `0`, `result.verification_rate` = `1` e mais 15",
    "whyItTests": "Valida 23 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual, toBeGreaterThan, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~23) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "pactsDir = ...",
      "mockPactContent = ...",
      "result = ...",
      "report = ...",
      "mdPath = ...",
      "mdContent = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.verified"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.failed"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "report.timestamp"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "testProduct",
        "path": "report.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "report.language"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "report.total_contracts"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "report.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "report.verification_rate"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "report.results"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "report.duration_total_ms"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Contract Verification Report",
        "path": "mdContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Summary",
        "path": "mdContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Verification Rate",
        "path": "mdContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "mdContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
    "name": "FASE 3: CDC/Pact E2E Tests > [4/4] FULL PIPELINE - scaffold + verify funcionam em sequ√™ncia",
    "testType": "e2e",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue FASE 3: CDC/Pact E2E Tests > [4/4] FULL PIPELINE - scaffold + verify funcionam em sequ√™ncia. **Valida√ß√µes**: `scaffoldResult.ok` = `true`, `scaffoldResult.total_contracts` = `0`, `configContent` = `\"pact-broker.example.com\"` e mais 9",
    "whyItTests": "Valida 12 aspecto(s) usando: toBe, toBeGreaterThan, toContain, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~12) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldResult = ...",
      "configContent = ...",
      "pactsDir = ...",
      "services = ...",
      "pactContent = ...",
      "verifyResult = ...",
      "report = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "scaffoldResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "scaffoldResult.total_contracts"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "pact-broker.example.com",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "verifyResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "verifyResult.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "verifyResult.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "report.total_contracts"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "report.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "report.verified"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "report.failed"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
    "name": "[1/4] scaffold_contracts_pact - deve detectar servi√ßos e gerar contratos",
    "testType": "e2e",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue detectar servi√ßos e gerar contratos. **Valida√ß√µes**: `result.ok` = `true`, `result.message` = `\"Generated\"`, `result.total_contracts` = `0` e mais 17",
    "whyItTests": "Valida 29 aspecto(s) usando: toBe, toContain, toBeGreaterThan, toBeDefined. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~29) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalog = ...",
      "configContent = ...",
      "testContent = ...",
      "testContent = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Generated",
        "path": "result.message"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_contracts"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_interactions"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.catalog_path"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.config_path"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.consumer_tests"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.provider_tests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "catalog.timestamp"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "test-cdc-app",
        "path": "catalog.product"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "catalog.services"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "catalog.services.length"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "catalog.potential_contracts"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "catalog.coverage"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "catalog.coverage.total_integrations"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "pactConfig",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test-cdc-app",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "consumer",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "provider",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "unknown.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "consumer",
        "path": "testContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "provider",
        "path": "testContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "interaction",
        "path": "testContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "verify",
        "path": "testContent"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.recommendations.some()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
    "name": "[2/4] scaffold_contracts_pact - deve detectar m√∫ltiplas APIs corretamente",
    "testType": "e2e",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue detectar m√∫ltiplas APIs corretamente. **Valida√ß√µes**: `serviceNames.some()` = `true`, `Array.isArray()` = `true`, `service.endpoints.?` = `\"method\"` e mais 5",
    "whyItTests": "Valida 10 aspecto(s) usando: toBe, toBeDefined, toHaveProperty, toContain, toBeGreaterThanOrEqual. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~10) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalog = ...",
      "serviceNames = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "serviceNames.some()"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "service.endpoints"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "method",
        "path": "service.endpoints.?"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "path",
        "path": "service.endpoints.?"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "consumer",
        "path": "contract"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "provider",
        "path": "contract"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "priority",
        "path": "contract"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "contract.estimated_interactions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
    "name": "[3/4] run_contracts_verify - deve verificar contratos gerados",
    "testType": "e2e",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue verificar contratos gerados. **Valida√ß√µes**: `result.ok` = `true`, `result.verification_rate` = `0`, `result.verification_rate` = `1` e mais 15",
    "whyItTests": "Valida 23 aspecto(s) usando: toBe, toBeGreaterThanOrEqual, toBeLessThanOrEqual, toBeGreaterThan, toBeDefined, toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~23) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "pactsDir = ...",
      "mockPactContent = ...",
      "result = ...",
      "report = ...",
      "mdPath = ...",
      "mdContent = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "result.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.verified"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "result.failed"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.report_path"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "report.timestamp"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "testProduct",
        "path": "report.product"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "typescript",
        "path": "report.language"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "report.total_contracts"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "report.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "report.verification_rate"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "report.results"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "report.duration_total_ms"
      },
      {
        "type": "generic",
        "matcher": "toBeDefined",
        "path": "result.recommendations"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.recommendations.length"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Contract Verification Report",
        "path": "mdContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Summary",
        "path": "mdContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Verification Rate",
        "path": "mdContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "mdContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
    "name": "[4/4] FULL PIPELINE - scaffold + verify funcionam em sequ√™ncia",
    "testType": "e2e",
    "functionUnderTest": "scaffoldContractsPact",
    "whatItTests": "Valida que **`scaffoldContractsPact`** consegue [4/4] FULL PIPELINE - scaffold + verify funcionam em sequ√™ncia. **Valida√ß√µes**: `scaffoldResult.ok` = `true`, `scaffoldResult.total_contracts` = `0`, `configContent` = `\"pact-broker.example.com\"` e mais 9",
    "whyItTests": "Valida 12 aspecto(s) usando: toBe, toBeGreaterThan, toContain, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~12) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "scaffoldResult = ...",
      "configContent = ...",
      "pactsDir = ...",
      "services = ...",
      "pactContent = ...",
      "verifyResult = ...",
      "report = ..."
    ],
    "when": "scaffoldContractsPact",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "scaffoldResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "scaffoldResult.total_contracts"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "pact-broker.example.com",
        "path": "configContent"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "verifyResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "verifyResult.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "verifyResult.verification_rate"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 3,
        "path": "report.total_contracts"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "report.total_interactions"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "report.verified"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "report.failed"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": 6,
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
    "name": "FASE 2 E2E: Portfolio Planning > [FULL PIPELINE] FASE 1 + FASE 2 completa",
    "testType": "e2e",
    "functionUnderTest": "console.log",
    "whatItTests": "Valida que **`console.log`** consegue FASE 2 E2E: Portfolio Planning > [FULL PIPELINE] FASE 1 + FASE 2 completa. **Valida√ß√µes**: `cujResult.ok` = `true`, `slosResult.ok` = `true`, `riskResult.ok` = `true` e mais 17",
    "whyItTests": "Valida 20 aspecto(s) usando: toBe, toContain, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~20) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "cujResult = ...",
      "slosResult = ...",
      "riskResult = ...",
      "portfolioResult = ...",
      "reportContent = ..."
    ],
    "when": "console.log",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "cujResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "slosResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "riskResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "portfolioResult.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "PORTFOLIO-PLAN.md",
        "path": "portfolioResult.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "portfolioResult.recommendations_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "# Test Portfolio Plan",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "## üìä Current State",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "## üéØ Target Distribution",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "## üéØ Module Recommendations",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "## ‚úÖ Action Items",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Fowler",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "70%",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "20%",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "10%",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "| Test Type | Count | Percentage | Target | Gap |",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Unit",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Integration",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "E2E",
        "path": "reportContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
    "name": "FASE 2 E2E: Portfolio Planning > [VALIDATION] Portfolio plan deve ter estrutura correta",
    "testType": "e2e",
    "functionUnderTest": "resolve",
    "whatItTests": "Valida que **`resolve`** consegue ter estrutura correta. **Valida√ß√µes**: `existsSync()` = `true`, `content` = `\"section\"`, `content` = `{}`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain, toMatch",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyses = ...",
      "reports = ...",
      "portfolioPath = ...",
      "content = ...",
      "sections = ..."
    ],
    "when": "resolve",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "section",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
    "name": "FASE 2 E2E: Portfolio Planning > [INTEGRATION] Recommendations devem estar baseadas em riscos",
    "testType": "e2e",
    "functionUnderTest": "resolve",
    "whatItTests": "Valida que **`resolve`** consegue FASE 2 E2E: Portfolio Planning > [INTEGRATION] Recommendations devem estar baseadas em riscos. **Valida√ß√µes**: `portfolioContent` = `\"üö® Top 5 Critical Risks\"`, `portfolioContent` = `\"Module Recommendations\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "riskPath = ...",
      "portfolioPath = ...",
      "riskData = ...",
      "portfolioContent = ...",
      "criticalRisks = ...",
      "module = ..."
    ],
    "when": "resolve",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "üö® Top 5 Critical Risks",
        "path": "portfolioContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Module Recommendations",
        "path": "portfolioContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
    "name": "FASE 2 E2E: Portfolio Planning > [METRICS] Distribui√ß√£o deve somar 100%",
    "testType": "e2e",
    "functionUnderTest": "resolve",
    "whatItTests": "Valida que **`resolve`** consegue somar 100%. **Valida√ß√µes**: `total` = `99.9`, `total` = `100.1`, `content` = `\"Current State\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual, toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "portfolioPath = ...",
      "content = ...",
      "tableMatch = ...",
      "unitPercent = ...",
      "integrationPercent = ...",
      "e2ePercent = ...",
      "total = ..."
    ],
    "when": "resolve",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 99.9,
        "path": "total"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 100.1,
        "path": "total"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Current State",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
    "name": "[FULL PIPELINE] FASE 1 + FASE 2 completa",
    "testType": "e2e",
    "functionUnderTest": "console.log",
    "whatItTests": "Valida que **`console.log`** consegue [FULL PIPELINE] FASE 1 + FASE 2 completa. **Valida√ß√µes**: `cujResult.ok` = `true`, `slosResult.ok` = `true`, `riskResult.ok` = `true` e mais 17",
    "whyItTests": "Valida 20 aspecto(s) usando: toBe, toContain, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~20) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "cujResult = ...",
      "slosResult = ...",
      "riskResult = ...",
      "portfolioResult = ...",
      "reportContent = ..."
    ],
    "when": "console.log",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "cujResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "slosResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "riskResult.ok"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "portfolioResult.ok"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "PORTFOLIO-PLAN.md",
        "path": "portfolioResult.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "portfolioResult.recommendations_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "# Test Portfolio Plan",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "## üìä Current State",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "## üéØ Target Distribution",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "## üéØ Module Recommendations",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "## ‚úÖ Action Items",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Fowler",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "70%",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "20%",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "10%",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "| Test Type | Count | Percentage | Target | Gap |",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Unit",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Integration",
        "path": "reportContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "E2E",
        "path": "reportContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
    "name": "[VALIDATION] Portfolio plan deve ter estrutura correta",
    "testType": "e2e",
    "functionUnderTest": "resolve",
    "whatItTests": "Valida que **`resolve`** consegue ter estrutura correta. **Valida√ß√µes**: `existsSync()` = `true`, `content` = `\"section\"`, `content` = `{}`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBe, toContain, toMatch",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyses = ...",
      "reports = ...",
      "portfolioPath = ...",
      "content = ...",
      "sections = ..."
    ],
    "when": "resolve",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "section",
        "path": "content"
      },
      {
        "type": "value",
        "matcher": "toMatch",
        "value": {},
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
    "name": "[INTEGRATION] Recommendations devem estar baseadas em riscos",
    "testType": "e2e",
    "functionUnderTest": "resolve",
    "whatItTests": "Valida que **`resolve`** consegue [INTEGRATION] Recommendations devem estar baseadas em riscos. **Valida√ß√µes**: `portfolioContent` = `\"üö® Top 5 Critical Risks\"`, `portfolioContent` = `\"Module Recommendations\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico",
    "given": [
      "riskPath = ...",
      "portfolioPath = ...",
      "riskData = ...",
      "portfolioContent = ...",
      "criticalRisks = ...",
      "module = ..."
    ],
    "when": "resolve",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "üö® Top 5 Critical Risks",
        "path": "portfolioContent"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Module Recommendations",
        "path": "portfolioContent"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
    "name": "[METRICS] Distribui√ß√£o deve somar 100%",
    "testType": "e2e",
    "functionUnderTest": "resolve",
    "whatItTests": "Valida que **`resolve`** consegue somar 100%. **Valida√ß√µes**: `total` = `99.9`, `total` = `100.1`, `content` = `\"Current State\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toBeGreaterThanOrEqual, toBeLessThanOrEqual, toContain",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "portfolioPath = ...",
      "content = ...",
      "tableMatch = ...",
      "unitPercent = ...",
      "integrationPercent = ...",
      "e2ePercent = ...",
      "total = ..."
    ],
    "when": "resolve",
    "then": [
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 99.9,
        "path": "total"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 100.1,
        "path": "total"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Current State",
        "path": "content"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
    "name": "FASE 1 E2E: CUJ ‚Üí SLO ‚Üí Risk Pipeline > [1/3] catalog_cujs deve gerar cuj-catalog.json",
    "testType": "e2e",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue gerar cuj-catalog.json. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`, `result.output` = `\"cuj-catalog.json\"` e mais 10",
    "whyItTests": "Valida 14 aspecto(s) usando: toBe, toBeGreaterThan, toContain, toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~14) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalogRaw = ...",
      "catalog = ...",
      "firstCUJ = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.cujs_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cuj-catalog.json",
        "path": "result.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "timestamp",
        "path": "catalog"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "repo",
        "path": "catalog"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "product",
        "path": "catalog"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "cujs",
        "path": "catalog"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "catalog.cujs.length"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "id",
        "path": "firstCUJ"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "firstCUJ"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "criticality",
        "path": "firstCUJ"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
    "name": "FASE 1 E2E: CUJ ‚Üí SLO ‚Üí Risk Pipeline > [2/3] define_slos deve gerar slos.json baseado em CUJs",
    "testType": "e2e",
    "functionUnderTest": "defineSLOs",
    "whatItTests": "Valida que **`defineSLOs`** consegue gerar slos.json baseado em CUJs. **Valida√ß√µes**: `result.ok` = `true`, `result.slos_count` = `0`, `result.output` = `\"slos.json\"` e mais 14",
    "whyItTests": "Valida 17 aspecto(s) usando: toBe, toBeGreaterThan, toContain, toHaveProperty, toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~17) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "slosRaw = ...",
      "slos = ...",
      "firstSLO = ..."
    ],
    "when": "defineSLOs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.slos_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "slos.json",
        "path": "result.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "timestamp",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "repo",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "product",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "slos",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "defaults_applied",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "cuj_id",
        "path": "firstSLO"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "error_rate_max",
        "path": "firstSLO"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "availability_min",
        "path": "firstSLO"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "firstSLO.error_rate_max"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "firstSLO.error_rate_max"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "firstSLO.availability_min"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "firstSLO.availability_min"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
    "name": "FASE 1 E2E: CUJ ‚Üí SLO ‚Üí Risk Pipeline > [3/3] risk_register deve gerar risk-register.json cruzando CUJs + SLOs",
    "testType": "e2e",
    "functionUnderTest": "riskRegister",
    "whatItTests": "Valida que **`riskRegister`** consegue gerar risk-register.json cruzando CUJs + SLOs. **Valida√ß√µes**: `result.ok` = `true`, `result.total_risks` = `0`, `result.output` = `\"risk-register.json\"` e mais 24",
    "whyItTests": "Valida 28 aspecto(s) usando: toBe, toBeGreaterThan, toContain, toHaveProperty, toBeLessThanOrEqual, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~28) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "riskRaw = ...",
      "riskReg = ...",
      "firstRisk = ...",
      "validTests = ..."
    ],
    "when": "riskRegister",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_risks"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "risk-register.json",
        "path": "result.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "timestamp",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "repo",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "product",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "risks",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "top_5_critical",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "total_risk_score",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "coverage_gaps",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 5,
        "path": "riskReg.top_5_critical.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "id",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "cuj_id",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "title",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "impact",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "probability",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "risk_score",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "affected_modules",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "mitigation_strategies",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "recommended_tests",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "firstRisk.risk_score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 100,
        "path": "firstRisk.risk_score"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test",
        "path": "validTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
    "name": "FASE 1 E2E: CUJ ‚Üí SLO ‚Üí Risk Pipeline > [FULL] Pipeline completo deve criar 3 arquivos consistentes",
    "testType": "e2e",
    "functionUnderTest": "resolve",
    "whatItTests": "Valida que **`resolve`** consegue criar 3 arquivos consistentes. **Valida√ß√µes**: `existsSync()` = `true`, `sloIds.has()` = `true`, `cujIds.has()` = `true` e mais 1",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyses = ...",
      "cujFile = ...",
      "slosFile = ...",
      "riskFile = ...",
      "catalog = ...",
      "slos = ...",
      "risks = ...",
      "cujIds = ...",
      "sloIds = ...",
      "riskIds = ..."
    ],
    "when": "resolve",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "path": "catalog.cujs.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "sloIds.has()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "path": "r.id"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "cujIds.has()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "riskIds.has()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
    "name": "[1/3] catalog_cujs deve gerar cuj-catalog.json",
    "testType": "e2e",
    "functionUnderTest": "catalogCUJs",
    "whatItTests": "Valida que **`catalogCUJs`** consegue gerar cuj-catalog.json. **Valida√ß√µes**: `result.ok` = `true`, `result.cujs_count` = `0`, `result.output` = `\"cuj-catalog.json\"` e mais 10",
    "whyItTests": "Valida 14 aspecto(s) usando: toBe, toBeGreaterThan, toContain, toHaveProperty",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~14) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "catalogRaw = ...",
      "catalog = ...",
      "firstCUJ = ..."
    ],
    "when": "catalogCUJs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.cujs_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "cuj-catalog.json",
        "path": "result.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "timestamp",
        "path": "catalog"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "repo",
        "path": "catalog"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "product",
        "path": "catalog"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "cujs",
        "path": "catalog"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "catalog.cujs.length"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "id",
        "path": "firstCUJ"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "name",
        "path": "firstCUJ"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "criticality",
        "path": "firstCUJ"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
    "name": "[2/3] define_slos deve gerar slos.json baseado em CUJs",
    "testType": "e2e",
    "functionUnderTest": "defineSLOs",
    "whatItTests": "Valida que **`defineSLOs`** consegue gerar slos.json baseado em CUJs. **Valida√ß√µes**: `result.ok` = `true`, `result.slos_count` = `0`, `result.output` = `\"slos.json\"` e mais 14",
    "whyItTests": "Valida 17 aspecto(s) usando: toBe, toBeGreaterThan, toContain, toHaveProperty, toBeGreaterThanOrEqual, toBeLessThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~17) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "slosRaw = ...",
      "slos = ...",
      "firstSLO = ..."
    ],
    "when": "defineSLOs",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.slos_count"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "slos.json",
        "path": "result.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "timestamp",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "repo",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "product",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "slos",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "defaults_applied",
        "path": "slos"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "boolean",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "cuj_id",
        "path": "firstSLO"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "error_rate_max",
        "path": "firstSLO"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "availability_min",
        "path": "firstSLO"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "firstSLO.error_rate_max"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "firstSLO.error_rate_max"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "firstSLO.availability_min"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 1,
        "path": "firstSLO.availability_min"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
    "name": "[3/3] risk_register deve gerar risk-register.json cruzando CUJs + SLOs",
    "testType": "e2e",
    "functionUnderTest": "riskRegister",
    "whatItTests": "Valida que **`riskRegister`** consegue gerar risk-register.json cruzando CUJs + SLOs. **Valida√ß√µes**: `result.ok` = `true`, `result.total_risks` = `0`, `result.output` = `\"risk-register.json\"` e mais 24",
    "whyItTests": "Valida 28 aspecto(s) usando: toBe, toBeGreaterThan, toContain, toHaveProperty, toBeLessThanOrEqual, toBeGreaterThanOrEqual",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~28) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "result = ...",
      "riskRaw = ...",
      "riskReg = ...",
      "firstRisk = ...",
      "validTests = ..."
    ],
    "when": "riskRegister",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result.ok"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThan",
        "value": 0,
        "path": "result.total_risks"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "risk-register.json",
        "path": "result.output"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "timestamp",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "repo",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "product",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "risks",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "top_5_critical",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "total_risk_score",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "coverage_gaps",
        "path": "riskReg"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "Array.isArray()"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 5,
        "path": "riskReg.top_5_critical.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "string",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "id",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "cuj_id",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "title",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "description",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "impact",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "probability",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "risk_score",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "affected_modules",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "mitigation_strategies",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toHaveProperty",
        "value": "recommended_tests",
        "path": "firstRisk"
      },
      {
        "type": "value",
        "matcher": "toBeGreaterThanOrEqual",
        "value": 0,
        "path": "firstRisk.risk_score"
      },
      {
        "type": "value",
        "matcher": "toBeLessThanOrEqual",
        "value": 100,
        "path": "firstRisk.risk_score"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "path": "unknown"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "test",
        "path": "validTests"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
    "name": "[FULL] Pipeline completo deve criar 3 arquivos consistentes",
    "testType": "e2e",
    "functionUnderTest": "resolve",
    "whatItTests": "Valida que **`resolve`** consegue criar 3 arquivos consistentes. **Valida√ß√µes**: `existsSync()` = `true`, `sloIds.has()` = `true`, `cujIds.has()` = `true` e mais 1",
    "whyItTests": "Valida 6 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Garantir que usu√°rios finais n√£o encontrem bugs (smoke tests cr√≠ticos)\n- ‚è±Ô∏è **MTTR**: Reproduzir cen√°rios reais de produ√ß√£o para diagn√≥stico\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~6) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "analyses = ...",
      "cujFile = ...",
      "slosFile = ...",
      "riskFile = ...",
      "catalog = ...",
      "slos = ...",
      "risks = ...",
      "cujIds = ...",
      "sloIds = ...",
      "riskIds = ..."
    ],
    "when": "resolve",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "existsSync()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "path": "catalog.cujs.length"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "sloIds.has()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "path": "r.id"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "cujIds.has()"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "riskIds.has()"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detect() > deve detectar projeto TypeScript com package.json",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar projeto TypeScript com package.json. **Valida√ß√µes**: `result` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detect() > deve detectar projeto TypeScript com tsconfig.json",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar projeto TypeScript com tsconfig.json. **Valida√ß√µes**: `result` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detect() > deve retornar false para diret√≥rio sem arquivos TypeScript",
    "testType": "unit",
    "functionUnderTest": "adapter.detect",
    "whatItTests": "Valida que **`adapter.detect`** consegue retornar false para diret√≥rio sem arquivos TypeScript. **Valida√ß√µes**: `result` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "adapter.detect",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar projeto TypeScript com package.json",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar projeto TypeScript com package.json. **Valida√ß√µes**: `result` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar projeto TypeScript com tsconfig.json",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar projeto TypeScript com tsconfig.json. **Valida√ß√µes**: `result` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve retornar false para diret√≥rio sem arquivos TypeScript",
    "testType": "unit",
    "functionUnderTest": "adapter.detect",
    "whatItTests": "Valida que **`adapter.detect`** consegue retornar false para diret√≥rio sem arquivos TypeScript. **Valida√ß√µes**: `result` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "adapter.detect",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detectFramework() > deve detectar vitest via vitest.config.ts",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar vitest via vitest.config.ts. **Valida√ß√µes**: `result` = `\"vitest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detectFramework() > deve detectar jest via jest.config.js",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar jest via jest.config.js. **Valida√ß√µes**: `result` = `\"jest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detectFramework() > deve retornar null se n√£o detectar framework",
    "testType": "unit",
    "functionUnderTest": "adapter.detectFramework",
    "whatItTests": "Valida que **`adapter.detectFramework`** consegue retornar null se n√£o detectar framework. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "adapter.detectFramework",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar vitest via vitest.config.ts",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar vitest via vitest.config.ts. **Valida√ß√µes**: `result` = `\"vitest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar jest via jest.config.js",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar jest via jest.config.js. **Valida√ß√µes**: `result` = `\"jest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve retornar null se n√£o detectar framework",
    "testType": "unit",
    "functionUnderTest": "adapter.detectFramework",
    "whatItTests": "Valida que **`adapter.detectFramework`** consegue retornar null se n√£o detectar framework. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "adapter.detectFramework",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve descobrir fun√ß√£o exportada simples",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir fun√ß√£o exportada simples. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`, `functions.?.criticality` = `\"CRITICAL\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve descobrir fun√ß√£o async",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir fun√ß√£o async. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve descobrir arrow function exportada",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir arrow function exportada. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve determinar criticality CRITICAL para validadores",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue determinar criticality CRITICAL para validadores. **Valida√ß√µes**: `functions.?.criticality` = `\"CRITICAL\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve determinar criticality HIGH para fun√ß√µes de escrita",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue determinar criticality HIGH para fun√ß√µes de escrita. **Valida√ß√µes**: `functions.?.criticality` = `\"HIGH\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve ignorar arquivos de teste",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ignorar arquivos de teste. **Valida√ß√µes**: `functions` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "functions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve descobrir fun√ß√£o exportada simples",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir fun√ß√£o exportada simples. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`, `functions.?.criticality` = `\"CRITICAL\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve descobrir fun√ß√£o async",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir fun√ß√£o async. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve descobrir arrow function exportada",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir arrow function exportada. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve determinar criticality CRITICAL para validadores",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue determinar criticality CRITICAL para validadores. **Valida√ß√µes**: `functions.?.criticality` = `\"CRITICAL\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve determinar criticality HIGH para fun√ß√µes de escrita",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue determinar criticality HIGH para fun√ß√µes de escrita. **Valida√ß√µes**: `functions.?.criticality` = `\"HIGH\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve ignorar arquivos de teste",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ignorar arquivos de teste. **Valida√ß√µes**: `functions` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "functions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve descobrir testes com it()",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue descobrir testes com it(). **Valida√ß√µes**: `tests` = `1`, `tests.?` = `\"{...}\"`, `tests.?.assertions` = `1` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "functions = ...",
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "tests.?"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests.?.assertions"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "toEqual",
        "path": "tests.?.assertions.?.type"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "tests.?.assertions.?.isWeak"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve descobrir testes com test()",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue descobrir testes com test(). **Valida√ß√µes**: `tests` = `1`, `tests.?.name` = `\"adds two numbers\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "adds two numbers",
        "path": "tests.?.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve detectar spies",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar spies. **Valida√ß√µes**: `tests.?.hasSpies` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.hasSpies"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve detectar mocks",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar mocks. **Valida√ß√µes**: `tests.?.hasMocks` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.hasMocks"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve detectar asser√ß√µes fracas",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar asser√ß√µes fracas. **Valida√ß√µes**: `tests.?.assertions.?.isWeak` = `true`, `tests.?.assertions.?.type` = `\"toBeTruthy\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.assertions.?.isWeak"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "toBeTruthy",
        "path": "tests.?.assertions.?.type"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve detectar m√∫ltiplas asser√ß√µes",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar m√∫ltiplas asser√ß√µes. **Valida√ß√µes**: `tests.?.assertions` = `2`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "tests.?.assertions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve descobrir testes com it()",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue descobrir testes com it(). **Valida√ß√µes**: `tests` = `1`, `tests.?` = `\"{...}\"`, `tests.?.assertions` = `1` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "functions = ...",
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "tests.?"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests.?.assertions"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "toEqual",
        "path": "tests.?.assertions.?.type"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "tests.?.assertions.?.isWeak"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve descobrir testes com test()",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue descobrir testes com test(). **Valida√ß√µes**: `tests` = `1`, `tests.?.name` = `\"adds two numbers\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "adds two numbers",
        "path": "tests.?.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar spies",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar spies. **Valida√ß√µes**: `tests.?.hasSpies` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.hasSpies"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar mocks",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar mocks. **Valida√ß√µes**: `tests.?.hasMocks` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.hasMocks"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar asser√ß√µes fracas",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar asser√ß√µes fracas. **Valida√ß√µes**: `tests.?.assertions.?.isWeak` = `true`, `tests.?.assertions.?.type` = `\"toBeTruthy\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.assertions.?.isWeak"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "toBeTruthy",
        "path": "tests.?.assertions.?.type"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar m√∫ltiplas asser√ß√µes",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar m√∫ltiplas asser√ß√µes. **Valida√ß√µes**: `tests.?.assertions` = `2`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "tests.?.assertions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve detectar happy path com asser√ß√µes fortes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar happy path com asser√ß√µes fortes. **Valida√ß√µes**: `matrix` = `1`, `matrix.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "matrix"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "matrix.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve detectar error handling",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar error handling. **Valida√ß√µes**: `matrix.?.error` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve detectar edge cases por nome do teste",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar edge cases por nome do teste. **Valida√ß√µes**: `matrix.?.edge` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.edge"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve detectar side effects com spies",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar side effects com spies. **Valida√ß√µes**: `matrix.?.sideEffects` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.sideEffects"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve identificar gaps de cen√°rios faltantes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue identificar gaps de cen√°rios faltantes. **Valida√ß√µes**: `matrix.?.gaps` = `\"Falta cen√°rio: Error Handling\"`, `matrix.?.gaps` = `\"Falta cen√°rio: Edge Cases\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Error Handling",
        "path": "matrix.?.gaps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Edge Cases",
        "path": "matrix.?.gaps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve sugerir side effects para fun√ß√µes com verbos de a√ß√£o",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sugerir side effects para fun√ß√µes com verbos de a√ß√£o. **Valida√ß√µes**: `matrix.?.gaps` = `\"Falta cen√°rio: Side Effects (fun√ß√£o tem efeitos colaterais)\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Side Effects (fun√ß√£o tem efeitos colaterais)",
        "path": "matrix.?.gaps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar happy path com asser√ß√µes fortes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar happy path com asser√ß√µes fortes. **Valida√ß√µes**: `matrix` = `1`, `matrix.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "matrix"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "matrix.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar error handling",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar error handling. **Valida√ß√µes**: `matrix.?.error` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar edge cases por nome do teste",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar edge cases por nome do teste. **Valida√ß√µes**: `matrix.?.edge` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.edge"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve detectar side effects com spies",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar side effects com spies. **Valida√ß√µes**: `matrix.?.sideEffects` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.sideEffects"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve identificar gaps de cen√°rios faltantes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue identificar gaps de cen√°rios faltantes. **Valida√ß√µes**: `matrix.?.gaps` = `\"Falta cen√°rio: Error Handling\"`, `matrix.?.gaps` = `\"Falta cen√°rio: Edge Cases\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Error Handling",
        "path": "matrix.?.gaps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Edge Cases",
        "path": "matrix.?.gaps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "TypeScriptAdapter > deve sugerir side effects para fun√ß√µes com verbos de a√ß√£o",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sugerir side effects para fun√ß√µes com verbos de a√ß√£o. **Valida√ß√µes**: `matrix.?.gaps` = `\"Falta cen√°rio: Side Effects (fun√ß√£o tem efeitos colaterais)\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Side Effects (fun√ß√£o tem efeitos colaterais)",
        "path": "matrix.?.gaps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detect() > deve detectar projeto TypeScript com package.json",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar projeto TypeScript com package.json. **Valida√ß√µes**: `result` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detect() > deve detectar projeto TypeScript com tsconfig.json",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar projeto TypeScript com tsconfig.json. **Valida√ß√µes**: `result` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detect() > deve retornar false para diret√≥rio sem arquivos TypeScript",
    "testType": "unit",
    "functionUnderTest": "adapter.detect",
    "whatItTests": "Valida que **`adapter.detect`** consegue retornar false para diret√≥rio sem arquivos TypeScript. **Valida√ß√µes**: `result` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "adapter.detect",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar projeto TypeScript com package.json",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar projeto TypeScript com package.json. **Valida√ß√µes**: `result` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar projeto TypeScript com tsconfig.json",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar projeto TypeScript com tsconfig.json. **Valida√ß√µes**: `result` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve retornar false para diret√≥rio sem arquivos TypeScript",
    "testType": "unit",
    "functionUnderTest": "adapter.detect",
    "whatItTests": "Valida que **`adapter.detect`** consegue retornar false para diret√≥rio sem arquivos TypeScript. **Valida√ß√µes**: `result` = `false`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "adapter.detect",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detectFramework() > deve detectar vitest via vitest.config.ts",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar vitest via vitest.config.ts. **Valida√ß√µes**: `result` = `\"vitest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detectFramework() > deve detectar jest via jest.config.js",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar jest via jest.config.js. **Valida√ß√µes**: `result` = `\"jest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "detectFramework() > deve retornar null se n√£o detectar framework",
    "testType": "unit",
    "functionUnderTest": "adapter.detectFramework",
    "whatItTests": "Valida que **`adapter.detectFramework`** consegue retornar null se n√£o detectar framework. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "adapter.detectFramework",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar vitest via vitest.config.ts",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar vitest via vitest.config.ts. **Valida√ß√µes**: `result` = `\"vitest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "vitest",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar jest via jest.config.js",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar jest via jest.config.js. **Valida√ß√µes**: `result` = `\"jest\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "jest",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve retornar null se n√£o detectar framework",
    "testType": "unit",
    "functionUnderTest": "adapter.detectFramework",
    "whatItTests": "Valida que **`adapter.detectFramework`** consegue retornar null se n√£o detectar framework. **1 valida√ß√µes** usando: toBeNull",
    "whyItTests": "Valida 1 aspecto(s) usando: toBeNull. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "result = ..."
    ],
    "when": "adapter.detectFramework",
    "then": [
      {
        "type": "value",
        "matcher": "toBeNull",
        "path": "result"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve descobrir fun√ß√£o exportada simples",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir fun√ß√£o exportada simples. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`, `functions.?.criticality` = `\"CRITICAL\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve descobrir fun√ß√£o async",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir fun√ß√£o async. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve descobrir arrow function exportada",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir arrow function exportada. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve determinar criticality CRITICAL para validadores",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue determinar criticality CRITICAL para validadores. **Valida√ß√µes**: `functions.?.criticality` = `\"CRITICAL\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve determinar criticality HIGH para fun√ß√µes de escrita",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue determinar criticality HIGH para fun√ß√µes de escrita. **Valida√ß√µes**: `functions.?.criticality` = `\"HIGH\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverFunctions() > deve ignorar arquivos de teste",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ignorar arquivos de teste. **Valida√ß√µes**: `functions` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "functions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve descobrir fun√ß√£o exportada simples",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir fun√ß√£o exportada simples. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`, `functions.?.criticality` = `\"CRITICAL\"`",
    "whyItTests": "Valida 3 aspecto(s) usando: toHaveLength, toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~3) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve descobrir fun√ß√£o async",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir fun√ß√£o async. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve descobrir arrow function exportada",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue descobrir arrow function exportada. **Valida√ß√µes**: `functions` = `1`, `functions.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "functions"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "functions.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve determinar criticality CRITICAL para validadores",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue determinar criticality CRITICAL para validadores. **Valida√ß√µes**: `functions.?.criticality` = `\"CRITICAL\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "CRITICAL",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve determinar criticality HIGH para fun√ß√µes de escrita",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue determinar criticality HIGH para fun√ß√µes de escrita. **Valida√ß√µes**: `functions.?.criticality` = `\"HIGH\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": "HIGH",
        "path": "functions.?.criticality"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve ignorar arquivos de teste",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue ignorar arquivos de teste. **Valida√ß√µes**: `functions` = `0`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 0,
        "path": "functions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve descobrir testes com it()",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue descobrir testes com it(). **Valida√ß√µes**: `tests` = `1`, `tests.?` = `\"{...}\"`, `tests.?.assertions` = `1` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "functions = ...",
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "tests.?"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests.?.assertions"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "toEqual",
        "path": "tests.?.assertions.?.type"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "tests.?.assertions.?.isWeak"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve descobrir testes com test()",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue descobrir testes com test(). **Valida√ß√µes**: `tests` = `1`, `tests.?.name` = `\"adds two numbers\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "adds two numbers",
        "path": "tests.?.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve detectar spies",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar spies. **Valida√ß√µes**: `tests.?.hasSpies` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.hasSpies"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve detectar mocks",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar mocks. **Valida√ß√µes**: `tests.?.hasMocks` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.hasMocks"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve detectar asser√ß√µes fracas",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar asser√ß√µes fracas. **Valida√ß√µes**: `tests.?.assertions.?.isWeak` = `true`, `tests.?.assertions.?.type` = `\"toBeTruthy\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.assertions.?.isWeak"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "toBeTruthy",
        "path": "tests.?.assertions.?.type"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "discoverTests() > deve detectar m√∫ltiplas asser√ß√µes",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar m√∫ltiplas asser√ß√µes. **Valida√ß√µes**: `tests.?.assertions` = `2`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "tests.?.assertions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve descobrir testes com it()",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue descobrir testes com it(). **Valida√ß√µes**: `tests` = `1`, `tests.?` = `\"{...}\"`, `tests.?.assertions` = `1` e mais 2",
    "whyItTests": "Valida 5 aspecto(s) usando: toHaveLength, toMatchObject, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo\n- ‚úÖ **Valor**: M√∫ltiplos asserts (~5) aumentam diagn√≥stico (sabe EXATAMENTE o que falhou)",
    "given": [
      "functions = ...",
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "tests.?"
      },
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests.?.assertions"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "toEqual",
        "path": "tests.?.assertions.?.type"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": false,
        "path": "tests.?.assertions.?.isWeak"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve descobrir testes com test()",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue descobrir testes com test(). **Valida√ß√µes**: `tests` = `1`, `tests.?.name` = `\"adds two numbers\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toBe",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "tests"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "adds two numbers",
        "path": "tests.?.name"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar spies",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar spies. **Valida√ß√µes**: `tests.?.hasSpies` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.hasSpies"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar mocks",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar mocks. **Valida√ß√µes**: `tests.?.hasMocks` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.hasMocks"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar asser√ß√µes fracas",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar asser√ß√µes fracas. **Valida√ß√µes**: `tests.?.assertions.?.isWeak` = `true`, `tests.?.assertions.?.type` = `\"toBeTruthy\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "tests.?.assertions.?.isWeak"
      },
      {
        "type": "value",
        "matcher": "toBe",
        "value": "toBeTruthy",
        "path": "tests.?.assertions.?.type"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar m√∫ltiplas asser√ß√µes",
    "testType": "unit",
    "functionUnderTest": "writeFileSync",
    "whatItTests": "Valida que **`writeFileSync`** consegue detectar m√∫ltiplas asser√ß√µes. **Valida√ß√µes**: `tests.?.assertions` = `2`",
    "whyItTests": "Valida 1 aspecto(s) usando: toHaveLength. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "tests = ..."
    ],
    "when": "writeFileSync",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 2,
        "path": "tests.?.assertions"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve detectar happy path com asser√ß√µes fortes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar happy path com asser√ß√µes fortes. **Valida√ß√µes**: `matrix` = `1`, `matrix.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "matrix"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "matrix.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve detectar error handling",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar error handling. **Valida√ß√µes**: `matrix.?.error` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve detectar edge cases por nome do teste",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar edge cases por nome do teste. **Valida√ß√µes**: `matrix.?.edge` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.edge"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve detectar side effects com spies",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar side effects com spies. **Valida√ß√µes**: `matrix.?.sideEffects` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.sideEffects"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve identificar gaps de cen√°rios faltantes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue identificar gaps de cen√°rios faltantes. **Valida√ß√µes**: `matrix.?.gaps` = `\"Falta cen√°rio: Error Handling\"`, `matrix.?.gaps` = `\"Falta cen√°rio: Edge Cases\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Error Handling",
        "path": "matrix.?.gaps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Edge Cases",
        "path": "matrix.?.gaps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "validateCases() > deve sugerir side effects para fun√ß√µes com verbos de a√ß√£o",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sugerir side effects para fun√ß√µes com verbos de a√ß√£o. **Valida√ß√µes**: `matrix.?.gaps` = `\"Falta cen√°rio: Side Effects (fun√ß√£o tem efeitos colaterais)\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Side Effects (fun√ß√£o tem efeitos colaterais)",
        "path": "matrix.?.gaps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar happy path com asser√ß√µes fortes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar happy path com asser√ß√µes fortes. **Valida√ß√µes**: `matrix` = `1`, `matrix.?` = `\"{...}\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toHaveLength, toMatchObject. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toHaveLength",
        "value": 1,
        "path": "matrix"
      },
      {
        "type": "value",
        "matcher": "toMatchObject",
        "value": "{...}",
        "path": "matrix.?"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar error handling",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar error handling. **Valida√ß√µes**: `matrix.?.error` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de erro** - garante robustez em casos de falha",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.error"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar edge cases por nome do teste",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar edge cases por nome do teste. **Valida√ß√µes**: `matrix.?.edge` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Edge case** - protege contra inputs extremos/inesperados",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.edge"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve detectar side effects com spies",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue detectar side effects com spies. **Valida√ß√µes**: `matrix.?.sideEffects` = `true`",
    "whyItTests": "Valida 1 aspecto(s) usando: toBe. **Cen√°rio de parsing** - valida interpreta√ß√£o correta de entrada",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toBe",
        "value": true,
        "path": "matrix.?.sideEffects"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve identificar gaps de cen√°rios faltantes",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue identificar gaps de cen√°rios faltantes. **Valida√ß√µes**: `matrix.?.gaps` = `\"Falta cen√°rio: Error Handling\"`, `matrix.?.gaps` = `\"Falta cen√°rio: Edge Cases\"`",
    "whyItTests": "Valida 2 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Error Handling",
        "path": "matrix.?.gaps"
      },
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Edge Cases",
        "path": "matrix.?.gaps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  },
  {
    "file": "/home/jorgesouza/Documents/dev/mcp-Quality-CLI/src/engine/adapters/__tests__/typescript.test.ts",
    "name": "deve sugerir side effects para fun√ß√µes com verbos de a√ß√£o",
    "testType": "unit",
    "functionUnderTest": "join",
    "whatItTests": "Valida que **`join`** consegue sugerir side effects para fun√ß√µes com verbos de a√ß√£o. **Valida√ß√µes**: `matrix.?.gaps` = `\"Falta cen√°rio: Side Effects (fun√ß√£o tem efeitos colaterais)\"`",
    "whyItTests": "Valida 1 aspecto(s) usando: toContain",
    "purposeForWhat": "üìâ **CFR**: Detectar bugs em segundos (feedback imediato durante desenvolvimento)\n- ‚ö° **Deploy Frequency**: Testes r√°pidos (~0.01s) permitem mais commits/dia sem medo",
    "given": [
      "srcDir = ...",
      "functions = ...",
      "tests = ...",
      "matrix = ..."
    ],
    "when": "join",
    "then": [
      {
        "type": "value",
        "matcher": "toContain",
        "value": "Falta cen√°rio: Side Effects (fun√ß√£o tem efeitos colaterais)",
        "path": "matrix.?.gaps"
      }
    ],
    "mocks": [],
    "coverage": {
      "files": [],
      "linesCovered": 0,
      "linesTotal": 0,
      "coveredInDiffPct": 0
    },
    "contracts": {
      "pact": false,
      "failed": 0,
      "interactions": 0
    },
    "assertStrength": "m√©dio",
    "smells": [],
    "suggestions": [
      "Adicionar cen√°rio de erro (try-catch)"
    ]
  }
]