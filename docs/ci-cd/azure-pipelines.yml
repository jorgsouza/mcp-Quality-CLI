# Azure Pipelines with Quality Gates
# Copy this file to azure-pipelines.yml in your project root

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - docs/*
      - '*.md'

pr:
  branches:
    include:
      - main
      - develop

pool:
  vmImage: 'ubuntu-latest'

variables:
  PRODUCT_NAME: '$(Build.Repository.Name)'
  NODE_VERSION: '20.x'

stages:
  - stage: Quality
    displayName: 'Quality Analysis & Gates'
    jobs:
      - job: QualityAnalysis
        displayName: 'Run Quality Analysis'
        timeoutInMinutes: 30
        steps:
          - task: NodeTool@0
            displayName: 'Setup Node.js'
            inputs:
              versionSpec: '$(NODE_VERSION)'
          
          - script: |
              npm ci
              npm install -g @quality/mcp-cli || echo "Using local version"
            displayName: 'Install dependencies'
          
          - script: |
              npx quality-cli analyze \
                --repo $(Build.SourcesDirectory) \
                --product $(PRODUCT_NAME) \
                --mode full
            displayName: 'Run quality analysis'
            continueOnError: true
          
          - script: |
              npx quality-cli run-mutation-tests \
                --repo $(Build.SourcesDirectory) \
                --product $(PRODUCT_NAME)
            displayName: 'Run mutation testing'
            continueOnError: true
          
          - script: |
              if [ "$(Build.SourceBranchName)" == "main" ]; then
                npx quality-cli prod-metrics-ingest \
                  --repo $(Build.SourcesDirectory) \
                  --product $(PRODUCT_NAME)
              fi
            displayName: 'Collect production metrics'
            condition: eq(variables['Build.SourceBranchName'], 'main')
            continueOnError: true
            env:
              SENTRY_DSN: $(SENTRY_DSN)
              DD_API_KEY: $(DD_API_KEY)
          
          - script: |
              if [ "$(Build.SourceBranchName)" == "main" ]; then
                npx quality-cli slo-canary-check \
                  --repo $(Build.SourcesDirectory) \
                  --product $(PRODUCT_NAME)
              fi
            displayName: 'SLO canary check'
            condition: eq(variables['Build.SourceBranchName'], 'main')
            continueOnError: true
          
          - script: |
              set +e
              npx quality-cli release-quality-gate \
                --repo $(Build.SourcesDirectory) \
                --product $(PRODUCT_NAME)
              EXIT_CODE=$?
              
              echo "Quality Gates exit code: ${EXIT_CODE}"
              echo "##vso[task.setvariable variable=GATE_EXIT_CODE]${EXIT_CODE}"
              
              if [ ${EXIT_CODE} -eq 0 ]; then
                echo "‚úÖ Quality Gates: PASSED"
                exit 0
              elif [ ${EXIT_CODE} -eq 1 ]; then
                echo "##vso[task.logissue type=error]‚ùå Quality Gates: BLOCKED"
                exit 1
              elif [ ${EXIT_CODE} -eq 2 ]; then
                echo "##vso[task.logissue type=warning]‚ö†Ô∏è Quality Gates: WARNINGS"
                exit 0
              fi
            displayName: 'Apply quality gates'
            name: QualityGates
          
          - task: PublishBuildArtifacts@1
            displayName: 'Publish quality reports'
            condition: always()
            inputs:
              PathtoPublish: 'qa/$(PRODUCT_NAME)/tests/reports'
              ArtifactName: 'quality-reports'
          
          - task: PublishTestResults@2
            displayName: 'Publish test results'
            condition: always()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/junit.xml'
              searchFolder: 'qa/$(PRODUCT_NAME)/tests/reports'
              failTaskOnFailedTests: false
  
  - stage: Deploy
    displayName: 'Deploy to Production'
    dependsOn: Quality
    condition: and(succeeded(), eq(variables['Build.SourceBranchName'], 'main'))
    jobs:
      - deployment: DeployProduction
        displayName: 'Deploy to production'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - script: |
                    echo "üöÄ Deploying to production..."
                    npm run deploy
                  displayName: 'Deploy'

