{
  "ok": true,
  "language": "typescript",
  "framework": "Vitest",
  "product": "mcp-Quality-CLI",
  "metrics": {
    "qualityScore": 70.37037037037037,
    "grade": "C",
    "scenarioCoverage": {
      "happy": 51.66666666666667,
      "edge": 35,
      "error": 33.88888888888889,
      "sideEffects": 23.88888888888889
    }
  },
  "functions": [
    {
      "name": "findTool",
      "filePath": "src/mcp-tools.manifest.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates)",
          "asserts": [
            "expect(MCP_TOOLS).toHaveLength(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tools devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(tool).toHaveProperty(name)",
            "expect(tool).toHaveProperty(description)",
            "expect(tool).toHaveProperty(inputSchema)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(tool.inputSchema.type).toBe(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve conter todos os 5 tools esperados",
          "asserts": [
            "expect(names).toContain(name)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve encontrar tool por nome",
          "asserts": [
            "expect(tool).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(tool).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve retornar undefined para tool inexistente",
          "asserts": [
            "expect(tool).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool analyze deve ter campos repo e product obrigat칩rios",
          "asserts": [
            "expect(tool.inputSchema.required).toContain(repo)",
            "expect(tool.inputSchema.required).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool validate deve ter campos de threshold",
          "asserts": [
            "expect(props).toHaveProperty(minBranch)",
            "expect(props).toHaveProperty(minMutation)",
            "expect(props).toHaveProperty(minDiffCoverage)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool scaffold deve ter campo type com enum",
          "asserts": [
            "expect(typeField.enum).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "todos os tools devem ter description com emoji",
          "asserts": [
            "expect(tool.description.length).toBeGreaterThan(10)",
            "expect(tool.description.charCodeAt()).toBeGreaterThan(255)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  1 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "findCommand",
      "filePath": "src/commands.manifest.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  17 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "validateRequiredFlags",
      "filePath": "src/commands.manifest.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  17 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "generateCommandHelp",
      "filePath": "src/commands.manifest.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "calculateRiskScore",
      "filePath": "src/utils/risk-calculator.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "estimateChangeFrequency",
      "filePath": "src/utils/risk-calculator.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "estimateComplexity",
      "filePath": "src/utils/risk-calculator.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "estimateRecentBugs",
      "filePath": "src/utils/risk-calculator.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "isUserFacing",
      "filePath": "src/utils/risk-calculator.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "calculateRiskScores",
      "filePath": "src/utils/risk-calculator.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "groupByRiskLevel",
      "filePath": "src/utils/risk-calculator.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "getPaths",
      "filePath": "src/utils/paths.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve gerar paths padr칚o para qa/<product>",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)",
            "expect(paths.analyses).toBe(/repo/qa/my-app/tests/analyses)",
            "expect(paths.reports).toBe(/repo/qa/my-app/tests/reports)",
            "expect(paths.playwrightReports).toBe(/repo/qa/my-app/tests/reports/playwright)",
            "expect(paths.unit).toBe(/repo/qa/my-app/tests/unit)",
            "expect(paths.integration).toBe(/repo/qa/my-app/tests/integration)",
            "expect(paths.e2e).toBe(/repo/qa/my-app/tests/e2e)",
            "expect(paths.fixtures).toBe(/repo/qa/my-app/fixtures)",
            "expect(paths.fixturesAuth).toBe(/repo/qa/my-app/fixtures/auth)",
            "expect(paths.dashboards).toBe(/repo/qa/my-app/dashboards)",
            "expect(paths.patches).toBe(/repo/qa/my-app/patches)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve respeitar output_root customizado via settings",
          "asserts": [
            "expect(paths.root).toBe(/repo/custom/qa-output)",
            "expect(paths.analyses).toBe(/repo/custom/qa-output/tests/analyses)",
            "expect(paths.reports).toBe(/repo/custom/qa-output/tests/reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com paths absolutos Windows-style",
          "asserts": [
            "expect(paths.root).toContain(my-app)",
            "expect(paths.analyses).toContain(tests)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve sanitizar corretamente nomes de produto com caracteres especiais",
          "asserts": [
            "expect(paths1.root).toBe(/repo/qa/@scope/package)",
            "expect(paths2.root).toBe(/repo/qa/my_app-v2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar todos os diret칩rios da estrutura",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser idempotente (n칚o falhar se diret칩rios j치 existem)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar estrutura mesmo se diret칩rio pai n칚o existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar true para paths dentro de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar false para paths fora de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path (Windows vs Unix)",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear JSON para analyses/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/analyze.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/coverage-analysis.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear MD e HTML para reports/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PLAN.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/QUALITY-REPORT.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PYRAMID.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear dashboard.html para dashboards/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/dashboard.html)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/Dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear .patch para patches/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/patches/fix-weak-assertions.patch)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve usar root como fallback para tipos desconhecidos",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/unknown.txt)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/package.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser case-insensitive para extens칫es",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/REPORT.MD)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/Data.JSON)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path relativo ao root do QA",
          "asserts": [
            "expect(getRelativePath()).toBe(tests/reports/PLAN.md)",
            "expect(getRelativePath()).toBe(tests/analyses/analyze.json)",
            "expect(getRelativePath()).toBe(dashboards/dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path original se n칚o estiver dentro do root",
          "asserts": [
            "expect(getRelativePath()).toBe(outsidePath)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path",
          "asserts": [
            "expect(relative).toBe(tests/unit/foo.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter todas as propriedades necess치rias",
          "asserts": [
            "expect(paths).toHaveProperty(prop)",
            "expect(unknown).toBe(string)",
            "expect(paths.prop.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter paths 칰nicos (sem duplicatas)",
          "asserts": [
            "expect(uniquePaths.size).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com product name vazio ou inv치lido",
          "asserts": [
            "expect(paths1.root).toContain(/repo/qa)",
            "expect(paths2.root).toContain(/repo/qa)",
            "expect(paths1.analyses).toContain(tests/analyses)",
            "expect(paths2.analyses).toContain(tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com repo path com espa칞os",
          "asserts": [
            "expect(paths.root).toBe(/Users/my folder/repo/qa/my-app)",
            "expect(paths.analyses).toContain(/Users/my folder/repo/qa/my-app/tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve preservar case do product name",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/MyApp-V2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings.paths undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve retornar ok=true quando todos os SLOs s칚o atendidos",
          "asserts": [
            "expect(result.ok).toBeDefined",
            "expect(result.summary).toBeDefined",
            "expect(result.summary.total_cujs).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico",
            "expect(result.summary).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve detectar viola칞칫es de SLOs",
          "asserts": [
            "expect(result.violations).toBeDefined",
            "expect(result.recommendations).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.violations).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve gerar recomenda칞칫es quando h치 viola칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/release-quality-gate.test.ts",
          "title": "deve retornar exit_code=0 quando todos os gates passam",
          "asserts": [
            "expect(result.exit_code).toBe(0)",
            "expect(result.summary.blocking_violations).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve gerar relat칩rio HTML da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.report_path).toContain(.html)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve gerar relat칩rio Markdown da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.report_path).toContain(.md)",
            "expect(content).toContain(Pir칙mide de Testes)",
            "expect(content).toContain(Unit)",
            "expect(content).toContain(Integration)",
            "expect(content).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve incluir visualiza칞칚o gr치fica no HTML",
          "asserts": [
            "expect(isHTML).toBe(true)",
            "expect(content).toContain(TestProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve incluir status de sa칰de no relat칩rio",
          "asserts": [
            "expect(hasHealth).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve lidar com aus칡ncia de coverage-analysis.json",
          "asserts": [
            "expect(error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve coletar m칠tricas e calcular DORA",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.dora_metrics).toBeDefined",
            "expect(result.dora_metrics.deployment_frequency).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.change_failure_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.mttr_minutes).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.dora_tier).toMatch(/Elite|High|Medium|Low/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.dora_metrics).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve calcular DORA tier corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve usar mock data quando credenciais n칚o fornecidas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.releases.length).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.dora_metrics).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve coletar m칠tricas de testes",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard HTML",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(<!DOCTYPE html>)",
            "expect(content).toContain(TestApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve incluir gr치ficos de cobertura",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(50:30:20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard com visualiza칞칚o da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Visualiza칞칚o da Pir칙mide)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve lidar com aus칡ncia de m칠tricas",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve exibir status de sa칰de dos testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(85/100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve gerar plano baseado nos findings da an치lise",
          "asserts": [
            "expect(analysis.findings.routes).toContain(/login)",
            "expect(analysis.findings.endpoints.length).toBeGreaterThan(0)",
            "expect(plan.ok).toBe(true)",
            "expect(plan.plan).toBeDefined",
            "expect(planExists).toBe(true)",
            "expect(planContent).toContain(Test App)",
            "expect(planContent).toContain(Playwright)",
            "expect(planContent).toContain(playwright.config.ts)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(plan.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve incluir recomenda칞칫es da an치lise no plano",
          "asserts": [
            "expect(analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(plan.ok).toBe(true)",
            "expect(planContent).toContain(Cen치rios)",
            "expect(planContent).toContain(Risco)",
            "expect(planContent).toContain(Playwright)",
            "expect(planContent).toContain(Exemplo)",
            "expect(planContent).toContain(example)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve organizar plano por dom칤nios quando especificados",
          "asserts": [
            "expect(plan.ok).toBe(true)",
            "expect(planContent.length).toBeGreaterThan(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  37 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "ensurePaths",
      "filePath": "src/utils/paths.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve gerar paths padr칚o para qa/<product>",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)",
            "expect(paths.analyses).toBe(/repo/qa/my-app/tests/analyses)",
            "expect(paths.reports).toBe(/repo/qa/my-app/tests/reports)",
            "expect(paths.playwrightReports).toBe(/repo/qa/my-app/tests/reports/playwright)",
            "expect(paths.unit).toBe(/repo/qa/my-app/tests/unit)",
            "expect(paths.integration).toBe(/repo/qa/my-app/tests/integration)",
            "expect(paths.e2e).toBe(/repo/qa/my-app/tests/e2e)",
            "expect(paths.fixtures).toBe(/repo/qa/my-app/fixtures)",
            "expect(paths.fixturesAuth).toBe(/repo/qa/my-app/fixtures/auth)",
            "expect(paths.dashboards).toBe(/repo/qa/my-app/dashboards)",
            "expect(paths.patches).toBe(/repo/qa/my-app/patches)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve respeitar output_root customizado via settings",
          "asserts": [
            "expect(paths.root).toBe(/repo/custom/qa-output)",
            "expect(paths.analyses).toBe(/repo/custom/qa-output/tests/analyses)",
            "expect(paths.reports).toBe(/repo/custom/qa-output/tests/reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com paths absolutos Windows-style",
          "asserts": [
            "expect(paths.root).toContain(my-app)",
            "expect(paths.analyses).toContain(tests)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve sanitizar corretamente nomes de produto com caracteres especiais",
          "asserts": [
            "expect(paths1.root).toBe(/repo/qa/@scope/package)",
            "expect(paths2.root).toBe(/repo/qa/my_app-v2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar todos os diret칩rios da estrutura",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser idempotente (n칚o falhar se diret칩rios j치 existem)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar estrutura mesmo se diret칩rio pai n칚o existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar true para paths dentro de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar false para paths fora de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path (Windows vs Unix)",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear JSON para analyses/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/analyze.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/coverage-analysis.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear MD e HTML para reports/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PLAN.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/QUALITY-REPORT.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PYRAMID.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear dashboard.html para dashboards/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/dashboard.html)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/Dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear .patch para patches/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/patches/fix-weak-assertions.patch)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve usar root como fallback para tipos desconhecidos",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/unknown.txt)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/package.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser case-insensitive para extens칫es",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/REPORT.MD)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/Data.JSON)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path relativo ao root do QA",
          "asserts": [
            "expect(getRelativePath()).toBe(tests/reports/PLAN.md)",
            "expect(getRelativePath()).toBe(tests/analyses/analyze.json)",
            "expect(getRelativePath()).toBe(dashboards/dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path original se n칚o estiver dentro do root",
          "asserts": [
            "expect(getRelativePath()).toBe(outsidePath)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path",
          "asserts": [
            "expect(relative).toBe(tests/unit/foo.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter todas as propriedades necess치rias",
          "asserts": [
            "expect(paths).toHaveProperty(prop)",
            "expect(unknown).toBe(string)",
            "expect(paths.prop.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter paths 칰nicos (sem duplicatas)",
          "asserts": [
            "expect(uniquePaths.size).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com product name vazio ou inv치lido",
          "asserts": [
            "expect(paths1.root).toContain(/repo/qa)",
            "expect(paths2.root).toContain(/repo/qa)",
            "expect(paths1.analyses).toContain(tests/analyses)",
            "expect(paths2.analyses).toContain(tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com repo path com espa칞os",
          "asserts": [
            "expect(paths.root).toBe(/Users/my folder/repo/qa/my-app)",
            "expect(paths.analyses).toContain(/Users/my folder/repo/qa/my-app/tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve preservar case do product name",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/MyApp-V2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings.paths undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve retornar 100% quando n칚o h치 mudan칞as",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.diffCoverage).toBe(100)",
            "expect(result.linesAdded).toBe(0)",
            "expect(result.files).toHaveLength(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve usar configura칞칚o do mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  13 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "isWithinQARoot",
      "filePath": "src/utils/paths.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve gerar paths padr칚o para qa/<product>",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)",
            "expect(paths.analyses).toBe(/repo/qa/my-app/tests/analyses)",
            "expect(paths.reports).toBe(/repo/qa/my-app/tests/reports)",
            "expect(paths.playwrightReports).toBe(/repo/qa/my-app/tests/reports/playwright)",
            "expect(paths.unit).toBe(/repo/qa/my-app/tests/unit)",
            "expect(paths.integration).toBe(/repo/qa/my-app/tests/integration)",
            "expect(paths.e2e).toBe(/repo/qa/my-app/tests/e2e)",
            "expect(paths.fixtures).toBe(/repo/qa/my-app/fixtures)",
            "expect(paths.fixturesAuth).toBe(/repo/qa/my-app/fixtures/auth)",
            "expect(paths.dashboards).toBe(/repo/qa/my-app/dashboards)",
            "expect(paths.patches).toBe(/repo/qa/my-app/patches)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve respeitar output_root customizado via settings",
          "asserts": [
            "expect(paths.root).toBe(/repo/custom/qa-output)",
            "expect(paths.analyses).toBe(/repo/custom/qa-output/tests/analyses)",
            "expect(paths.reports).toBe(/repo/custom/qa-output/tests/reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com paths absolutos Windows-style",
          "asserts": [
            "expect(paths.root).toContain(my-app)",
            "expect(paths.analyses).toContain(tests)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve sanitizar corretamente nomes de produto com caracteres especiais",
          "asserts": [
            "expect(paths1.root).toBe(/repo/qa/@scope/package)",
            "expect(paths2.root).toBe(/repo/qa/my_app-v2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar todos os diret칩rios da estrutura",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser idempotente (n칚o falhar se diret칩rios j치 existem)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar estrutura mesmo se diret칩rio pai n칚o existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar true para paths dentro de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar false para paths fora de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path (Windows vs Unix)",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear JSON para analyses/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/analyze.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/coverage-analysis.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear MD e HTML para reports/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PLAN.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/QUALITY-REPORT.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PYRAMID.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear dashboard.html para dashboards/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/dashboard.html)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/Dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear .patch para patches/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/patches/fix-weak-assertions.patch)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve usar root como fallback para tipos desconhecidos",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/unknown.txt)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/package.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser case-insensitive para extens칫es",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/REPORT.MD)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/Data.JSON)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path relativo ao root do QA",
          "asserts": [
            "expect(getRelativePath()).toBe(tests/reports/PLAN.md)",
            "expect(getRelativePath()).toBe(tests/analyses/analyze.json)",
            "expect(getRelativePath()).toBe(dashboards/dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path original se n칚o estiver dentro do root",
          "asserts": [
            "expect(getRelativePath()).toBe(outsidePath)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path",
          "asserts": [
            "expect(relative).toBe(tests/unit/foo.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter todas as propriedades necess치rias",
          "asserts": [
            "expect(paths).toHaveProperty(prop)",
            "expect(unknown).toBe(string)",
            "expect(paths.prop.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter paths 칰nicos (sem duplicatas)",
          "asserts": [
            "expect(uniquePaths.size).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com product name vazio ou inv치lido",
          "asserts": [
            "expect(paths1.root).toContain(/repo/qa)",
            "expect(paths2.root).toContain(/repo/qa)",
            "expect(paths1.analyses).toContain(tests/analyses)",
            "expect(paths2.analyses).toContain(tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com repo path com espa칞os",
          "asserts": [
            "expect(paths.root).toBe(/Users/my folder/repo/qa/my-app)",
            "expect(paths.analyses).toContain(/Users/my folder/repo/qa/my-app/tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve preservar case do product name",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/MyApp-V2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings.paths undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "getOutputPath",
      "filePath": "src/utils/paths.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve gerar paths padr칚o para qa/<product>",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)",
            "expect(paths.analyses).toBe(/repo/qa/my-app/tests/analyses)",
            "expect(paths.reports).toBe(/repo/qa/my-app/tests/reports)",
            "expect(paths.playwrightReports).toBe(/repo/qa/my-app/tests/reports/playwright)",
            "expect(paths.unit).toBe(/repo/qa/my-app/tests/unit)",
            "expect(paths.integration).toBe(/repo/qa/my-app/tests/integration)",
            "expect(paths.e2e).toBe(/repo/qa/my-app/tests/e2e)",
            "expect(paths.fixtures).toBe(/repo/qa/my-app/fixtures)",
            "expect(paths.fixturesAuth).toBe(/repo/qa/my-app/fixtures/auth)",
            "expect(paths.dashboards).toBe(/repo/qa/my-app/dashboards)",
            "expect(paths.patches).toBe(/repo/qa/my-app/patches)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve respeitar output_root customizado via settings",
          "asserts": [
            "expect(paths.root).toBe(/repo/custom/qa-output)",
            "expect(paths.analyses).toBe(/repo/custom/qa-output/tests/analyses)",
            "expect(paths.reports).toBe(/repo/custom/qa-output/tests/reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com paths absolutos Windows-style",
          "asserts": [
            "expect(paths.root).toContain(my-app)",
            "expect(paths.analyses).toContain(tests)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve sanitizar corretamente nomes de produto com caracteres especiais",
          "asserts": [
            "expect(paths1.root).toBe(/repo/qa/@scope/package)",
            "expect(paths2.root).toBe(/repo/qa/my_app-v2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar todos os diret칩rios da estrutura",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser idempotente (n칚o falhar se diret칩rios j치 existem)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar estrutura mesmo se diret칩rio pai n칚o existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar true para paths dentro de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar false para paths fora de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path (Windows vs Unix)",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear JSON para analyses/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/analyze.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/coverage-analysis.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear MD e HTML para reports/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PLAN.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/QUALITY-REPORT.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PYRAMID.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear dashboard.html para dashboards/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/dashboard.html)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/Dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear .patch para patches/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/patches/fix-weak-assertions.patch)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve usar root como fallback para tipos desconhecidos",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/unknown.txt)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/package.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser case-insensitive para extens칫es",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/REPORT.MD)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/Data.JSON)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path relativo ao root do QA",
          "asserts": [
            "expect(getRelativePath()).toBe(tests/reports/PLAN.md)",
            "expect(getRelativePath()).toBe(tests/analyses/analyze.json)",
            "expect(getRelativePath()).toBe(dashboards/dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path original se n칚o estiver dentro do root",
          "asserts": [
            "expect(getRelativePath()).toBe(outsidePath)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path",
          "asserts": [
            "expect(relative).toBe(tests/unit/foo.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter todas as propriedades necess치rias",
          "asserts": [
            "expect(paths).toHaveProperty(prop)",
            "expect(unknown).toBe(string)",
            "expect(paths.prop.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter paths 칰nicos (sem duplicatas)",
          "asserts": [
            "expect(uniquePaths.size).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com product name vazio ou inv치lido",
          "asserts": [
            "expect(paths1.root).toContain(/repo/qa)",
            "expect(paths2.root).toContain(/repo/qa)",
            "expect(paths1.analyses).toContain(tests/analyses)",
            "expect(paths2.analyses).toContain(tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com repo path com espa칞os",
          "asserts": [
            "expect(paths.root).toBe(/Users/my folder/repo/qa/my-app)",
            "expect(paths.analyses).toContain(/Users/my folder/repo/qa/my-app/tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve preservar case do product name",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/MyApp-V2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings.paths undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "getRelativePath",
      "filePath": "src/utils/paths.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve gerar paths padr칚o para qa/<product>",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)",
            "expect(paths.analyses).toBe(/repo/qa/my-app/tests/analyses)",
            "expect(paths.reports).toBe(/repo/qa/my-app/tests/reports)",
            "expect(paths.playwrightReports).toBe(/repo/qa/my-app/tests/reports/playwright)",
            "expect(paths.unit).toBe(/repo/qa/my-app/tests/unit)",
            "expect(paths.integration).toBe(/repo/qa/my-app/tests/integration)",
            "expect(paths.e2e).toBe(/repo/qa/my-app/tests/e2e)",
            "expect(paths.fixtures).toBe(/repo/qa/my-app/fixtures)",
            "expect(paths.fixturesAuth).toBe(/repo/qa/my-app/fixtures/auth)",
            "expect(paths.dashboards).toBe(/repo/qa/my-app/dashboards)",
            "expect(paths.patches).toBe(/repo/qa/my-app/patches)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve respeitar output_root customizado via settings",
          "asserts": [
            "expect(paths.root).toBe(/repo/custom/qa-output)",
            "expect(paths.analyses).toBe(/repo/custom/qa-output/tests/analyses)",
            "expect(paths.reports).toBe(/repo/custom/qa-output/tests/reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com paths absolutos Windows-style",
          "asserts": [
            "expect(paths.root).toContain(my-app)",
            "expect(paths.analyses).toContain(tests)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve sanitizar corretamente nomes de produto com caracteres especiais",
          "asserts": [
            "expect(paths1.root).toBe(/repo/qa/@scope/package)",
            "expect(paths2.root).toBe(/repo/qa/my_app-v2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar todos os diret칩rios da estrutura",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser idempotente (n칚o falhar se diret칩rios j치 existem)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar estrutura mesmo se diret칩rio pai n칚o existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar true para paths dentro de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar false para paths fora de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path (Windows vs Unix)",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear JSON para analyses/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/analyze.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/coverage-analysis.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear MD e HTML para reports/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PLAN.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/QUALITY-REPORT.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PYRAMID.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear dashboard.html para dashboards/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/dashboard.html)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/Dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear .patch para patches/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/patches/fix-weak-assertions.patch)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve usar root como fallback para tipos desconhecidos",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/unknown.txt)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/package.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser case-insensitive para extens칫es",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/REPORT.MD)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/Data.JSON)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path relativo ao root do QA",
          "asserts": [
            "expect(getRelativePath()).toBe(tests/reports/PLAN.md)",
            "expect(getRelativePath()).toBe(tests/analyses/analyze.json)",
            "expect(getRelativePath()).toBe(dashboards/dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path original se n칚o estiver dentro do root",
          "asserts": [
            "expect(getRelativePath()).toBe(outsidePath)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path",
          "asserts": [
            "expect(relative).toBe(tests/unit/foo.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter todas as propriedades necess치rias",
          "asserts": [
            "expect(paths).toHaveProperty(prop)",
            "expect(unknown).toBe(string)",
            "expect(paths.prop.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter paths 칰nicos (sem duplicatas)",
          "asserts": [
            "expect(uniquePaths.size).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com product name vazio ou inv치lido",
          "asserts": [
            "expect(paths1.root).toContain(/repo/qa)",
            "expect(paths2.root).toContain(/repo/qa)",
            "expect(paths1.analyses).toContain(tests/analyses)",
            "expect(paths2.analyses).toContain(tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com repo path com espa칞os",
          "asserts": [
            "expect(paths.root).toBe(/Users/my folder/repo/qa/my-app)",
            "expect(paths.analyses).toContain(/Users/my folder/repo/qa/my-app/tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve preservar case do product name",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/MyApp-V2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings.paths undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "ensureDir",
      "filePath": "src/utils/fs.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio recursivamente",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar se diret칩rio j치 existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio pai e escrever arquivo",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve sobrescrever arquivo existente",
          "asserts": [
            "expect(readContent).toBe(New content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro se arquivo n칚o existir",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler conte칰do de arquivo existente",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.mkdir com op칞칚o recursive:true",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(nestedDir)",
            "expect(mkdirSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar quando diret칩rio j치 existe (EEXIST)",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar ensureDir antes de escrever arquivo",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalled",
            "expect(mkdirSpy.mock.calls.?.?).toEqual({...})",
            "expect(writeFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(mkdirSpy.mock.invocationCallOrder.?).toBeLessThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar backup quando arquivo existe e createBackup=true",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(backupContent).toBe(oldContent)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve logar mensagem de backup criado",
          "asserts": [
            "expect(consoleLogSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve criar backup quando createBackup=false",
          "asserts": [
            "expect(copyFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.readFile com encoding utf8",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(readFileSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve propagar erro quando arquivo n칚o existe",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(nonExistentFile)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio com caracteres especiais no nome",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar caminho profundamente aninhado",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com diret칩rio que j치 existe (idempot칡ncia)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever arquivo com nome contendo caracteres especiais",
          "asserts": [
            "expect(written).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever string vazia sem erro",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever conte칰do muito grande (>1MB)",
          "asserts": [
            "expect(written.length).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com m칰ltiplas escritas sequenciais (race condition test)",
          "asserts": [
            "expect(final).toBe(content-4)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve falhar silenciosamente se backup falhar por falta de permiss칚o",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalled",
            "expect(consoleWarnSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo com diferentes encodings",
          "asserts": [
            "expect(utf8Content).toBe(content)",
            "expect(unknown).toBe(string)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro para arquivo n칚o existente",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo vazio",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para arquivo existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para diret칩rio existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para caminho vazio",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio inexistente",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio vazio",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve listar todos os arquivos em diret칩rio populado",
          "asserts": [
            "expect(files).toHaveLength(3)",
            "expect(files).toContain(file1.txt)",
            "expect(files).toContain(file2.txt)",
            "expect(files).toContain(subdir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com caracteres especiais em nomes de arquivos",
          "asserts": [
            "expect(files).toContain(specialName)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "writeFileSafe",
      "filePath": "src/utils/fs.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio recursivamente",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar se diret칩rio j치 existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio pai e escrever arquivo",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve sobrescrever arquivo existente",
          "asserts": [
            "expect(readContent).toBe(New content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro se arquivo n칚o existir",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler conte칰do de arquivo existente",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.mkdir com op칞칚o recursive:true",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(nestedDir)",
            "expect(mkdirSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar quando diret칩rio j치 existe (EEXIST)",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar ensureDir antes de escrever arquivo",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalled",
            "expect(mkdirSpy.mock.calls.?.?).toEqual({...})",
            "expect(writeFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(mkdirSpy.mock.invocationCallOrder.?).toBeLessThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar backup quando arquivo existe e createBackup=true",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(backupContent).toBe(oldContent)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve logar mensagem de backup criado",
          "asserts": [
            "expect(consoleLogSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve criar backup quando createBackup=false",
          "asserts": [
            "expect(copyFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.readFile com encoding utf8",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(readFileSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve propagar erro quando arquivo n칚o existe",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(nonExistentFile)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio com caracteres especiais no nome",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar caminho profundamente aninhado",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com diret칩rio que j치 existe (idempot칡ncia)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever arquivo com nome contendo caracteres especiais",
          "asserts": [
            "expect(written).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever string vazia sem erro",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever conte칰do muito grande (>1MB)",
          "asserts": [
            "expect(written.length).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com m칰ltiplas escritas sequenciais (race condition test)",
          "asserts": [
            "expect(final).toBe(content-4)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve falhar silenciosamente se backup falhar por falta de permiss칚o",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalled",
            "expect(consoleWarnSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo com diferentes encodings",
          "asserts": [
            "expect(utf8Content).toBe(content)",
            "expect(unknown).toBe(string)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro para arquivo n칚o existente",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo vazio",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para arquivo existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para diret칩rio existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para caminho vazio",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio inexistente",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio vazio",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve listar todos os arquivos em diret칩rio populado",
          "asserts": [
            "expect(files).toHaveLength(3)",
            "expect(files).toContain(file1.txt)",
            "expect(files).toContain(file2.txt)",
            "expect(files).toContain(subdir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com caracteres especiais em nomes de arquivos",
          "asserts": [
            "expect(files).toContain(specialName)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve retornar ok=true quando todos os SLOs s칚o atendidos",
          "asserts": [
            "expect(result.ok).toBeDefined",
            "expect(result.summary).toBeDefined",
            "expect(result.summary.total_cujs).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico",
            "expect(result.summary).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve detectar viola칞칫es de SLOs",
          "asserts": [
            "expect(result.violations).toBeDefined",
            "expect(result.recommendations).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.violations).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve gerar recomenda칞칫es quando h치 viola칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve retornar 100% quando n칚o h치 mudan칞as",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.diffCoverage).toBe(100)",
            "expect(result.linesAdded).toBe(0)",
            "expect(result.files).toHaveLength(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve usar configura칞칚o do mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/release-quality-gate.test.ts",
          "title": "deve retornar exit_code=0 quando todos os gates passam",
          "asserts": [
            "expect(result.exit_code).toBe(0)",
            "expect(result.summary.blocking_violations).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve coletar m칠tricas e calcular DORA",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.dora_metrics).toBeDefined",
            "expect(result.dora_metrics.deployment_frequency).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.change_failure_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.mttr_minutes).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.dora_tier).toMatch(/Elite|High|Medium|Low/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.dora_metrics).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve calcular DORA tier corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve usar mock data quando credenciais n칚o fornecidas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.releases.length).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.dora_metrics).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  20 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "readFile",
      "filePath": "src/utils/fs.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear dom칤nios separados por v칤rgula",
          "asserts": [
            "expect(domains).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear critical flows separados por v칤rgula",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear JSON de targets",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o se n칚o especificado",
          "asserts": [
            "expect(defaultOut).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve aceitar include-examples como boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(packages/product-e2e)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve converter --headed para headless=false",
          "asserts": [
            "expect(headless).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar headless=true por padr칚o",
          "asserts": [
            "expect(headless).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de relat칩rios padr칚o",
          "asserts": [
            "expect(defaultReport).toBe(reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar arquivo de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(SUMMARY.md)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de arquivos",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de endpoints",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de squads",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear thresholds JSON",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar URL base",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar URL inv치lida",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar nome de produto alphanumeric",
          "asserts": [
            "expect(regex.test()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar nome de produto com caracteres especiais",
          "asserts": [
            "expect(regex.test()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato markdown",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato html",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato json",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar formato inv치lido",
          "asserts": [
            "expect(['markdown', 'html', 'json']).not.toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar jest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar vitest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar mocha",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter todos os comandos esperados registrados na CLI",
          "asserts": [
            "expect(helpOutput).toContain(command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter descri칞칫es para todos os comandos",
          "asserts": [
            "expect(helpOutput).toContain",
            "expect(helpOutput).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar que comandos espec칤ficos aceitam par칙metros obrigat칩rios",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)",
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar comandos inexistentes com mensagem clara",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(output).toMatch(/unknown command|error/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve garantir que scripts npm correspondam aos comandos CLI",
          "asserts": [
            "expect(packageJson.scripts).toHaveProperty(scriptName)",
            "expect(packageJson.scripts.scriptName).toContain(cliCommand)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio recursivamente",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar se diret칩rio j치 existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio pai e escrever arquivo",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve sobrescrever arquivo existente",
          "asserts": [
            "expect(readContent).toBe(New content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro se arquivo n칚o existir",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler conte칰do de arquivo existente",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.mkdir com op칞칚o recursive:true",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(nestedDir)",
            "expect(mkdirSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar quando diret칩rio j치 existe (EEXIST)",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar ensureDir antes de escrever arquivo",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalled",
            "expect(mkdirSpy.mock.calls.?.?).toEqual({...})",
            "expect(writeFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(mkdirSpy.mock.invocationCallOrder.?).toBeLessThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar backup quando arquivo existe e createBackup=true",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(backupContent).toBe(oldContent)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve logar mensagem de backup criado",
          "asserts": [
            "expect(consoleLogSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve criar backup quando createBackup=false",
          "asserts": [
            "expect(copyFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.readFile com encoding utf8",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(readFileSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve propagar erro quando arquivo n칚o existe",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(nonExistentFile)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio com caracteres especiais no nome",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar caminho profundamente aninhado",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com diret칩rio que j치 existe (idempot칡ncia)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever arquivo com nome contendo caracteres especiais",
          "asserts": [
            "expect(written).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever string vazia sem erro",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever conte칰do muito grande (>1MB)",
          "asserts": [
            "expect(written.length).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com m칰ltiplas escritas sequenciais (race condition test)",
          "asserts": [
            "expect(final).toBe(content-4)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve falhar silenciosamente se backup falhar por falta de permiss칚o",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalled",
            "expect(consoleWarnSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo com diferentes encodings",
          "asserts": [
            "expect(utf8Content).toBe(content)",
            "expect(unknown).toBe(string)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro para arquivo n칚o existente",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo vazio",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para arquivo existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para diret칩rio existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para caminho vazio",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio inexistente",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio vazio",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve listar todos os arquivos em diret칩rio populado",
          "asserts": [
            "expect(files).toHaveLength(3)",
            "expect(files).toContain(file1.txt)",
            "expect(files).toContain(file2.txt)",
            "expect(files).toContain(subdir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com caracteres especiais em nomes de arquivos",
          "asserts": [
            "expect(files).toContain(specialName)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve medir sa칰de b치sica da su칤te",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_runtime_sec).toBeGreaterThanOrEqual(0)",
            "expect(result.flaky_tests_count).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve calcular instability index",
          "asserts": [
            "expect(result.instability_index).toBeDefined",
            "expect(unknown).toBe(number)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.instability_index).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve gerar recomenda칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve salvar relat칩rio em JSON",
          "asserts": [
            "expect(result.output).toContain(suite-health.json)",
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(timestamp)",
            "expect(content).toHaveProperty(total_runtime_sec)",
            "expect(content).toHaveProperty(instability_index)",
            "expect(content).toHaveProperty(recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve retornar ok=true quando todos os SLOs s칚o atendidos",
          "asserts": [
            "expect(result.ok).toBeDefined",
            "expect(result.summary).toBeDefined",
            "expect(result.summary.total_cujs).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico",
            "expect(result.summary).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve detectar viola칞칫es de SLOs",
          "asserts": [
            "expect(result.violations).toBeDefined",
            "expect(result.recommendations).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.violations).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve gerar recomenda칞칫es quando h치 viola칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve criar diret칩rios de testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(authExists).toBe(true)",
            "expect(claimExists).toBe(true)",
            "expect(searchExists).toBe(true)",
            "expect(fixturesExists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve gerar playwright.config.ts",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(configExists).toBe(true)",
            "expect(configContent).toContain(defineConfig)",
            "expect(configContent).toContain(timeout)",
            "expect(configContent).toContain(baseURL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve criar fixture de autentica칞칚o",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(fixtureExists).toBe(true)",
            "expect(fixtureContent).toContain(base)",
            "expect(fixtureContent).toContain(deprecated)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve gerar spec de login",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(loginExists).toBe(true)",
            "expect(loginContent).toContain(test)",
            "expect(loginContent).toContain(login)",
            "expect(loginContent).toContain(Email)",
            "expect(loginContent).toContain(Senha)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve gerar spec de reclama칞칚o",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(claimExists).toBe(true)",
            "expect(claimContent).toContain(test)",
            "expect(claimContent).toContain(reclama칞칚o)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve gerar spec de busca",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(searchExists).toBe(true)",
            "expect(searchContent).toContain(test)",
            "expect(searchContent).toContain(buscar empresa)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve retornar caminho do diret칩rio E2E",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.e2e_dir).toContain(e2e)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve configurar reporters no playwright.config.ts",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(configContent).toContain(reporter)",
            "expect(configContent).toContain(html)",
            "expect(configContent).toContain(junit)",
            "expect(configContent).toContain(json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve configurar retry e timeout no playwright.config.ts",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(configContent).toContain(retries)",
            "expect(configContent).toContain(timeout)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve configurar trace e screenshot no playwright.config.ts",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(configContent).toContain(trace)",
            "expect(configContent).toContain(screenshot)",
            "expect(configContent).toContain(video)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Vitest",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Jest",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Mocha",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(mocha)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve gerar testes para m칰ltiplos arquivos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve limitar a 20 arquivos por vez",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBeLessThanOrEqual(20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve atualizar package.json com scripts de teste",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(packageJson.scripts.test).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(packageJson.scripts.test).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve gerar guia de testes unit치rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(Unit Testing)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve lidar com erro quando arquivo fonte n칚o existe",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve auto-detectar arquivos quando n칚o especificados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-integration.test.ts",
          "title": "deve lidar com base_url inv치lida",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-integration.test.ts",
          "title": "deve lidar com endpoints vazios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve retornar 100% quando n칚o h치 mudan칞as",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.diffCoverage).toBe(100)",
            "expect(result.linesAdded).toBe(0)",
            "expect(result.files).toHaveLength(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve usar configura칞칚o do mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve ler JSON do Playwright e gerar relat칩rio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.out).toBe",
            "expect(content).toContain(QA Report)",
            "expect(content).toContain(| **Passou** | 45 (90.00%) |)",
            "expect(content).toContain(| **Falhou** | 3 |)",
            "expect(content).toContain(| **Flaky** | 2 (4.00%) 仇 |)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve incluir artefatos no relat칩rio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Artefatos)",
            "expect(content).toContain(html/index.html)",
            "expect(content).toContain(junit/results.xml)",
            "expect(content).toContain(json/results.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve adicionar recomenda칞칫es ao relat칩rio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Pr칩ximas A칞칫es)",
            "expect(content).toContain(flaky)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve verificar thresholds de flaky",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(仇 Resolver testes flaky (meta: 곣 3%))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve verificar thresholds de diff-coverage",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(N/A*)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve lidar com arquivo JSON inexistente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(0 (0.00%))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve calcular dura칞칚o em segundos corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(125s)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve usar thresholds padr칚o quando n칚o especificados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(九 Resolver testes flaky (meta: 곣 3%))",
            "expect(content).toContain(N/A*)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/release-quality-gate.test.ts",
          "title": "deve retornar exit_code=0 quando todos os gates passam",
          "asserts": [
            "expect(result.exit_code).toBe(0)",
            "expect(result.summary.blocking_violations).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve gerar relat칩rio HTML da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.report_path).toContain(.html)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve gerar relat칩rio Markdown da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.report_path).toContain(.md)",
            "expect(content).toContain(Pir칙mide de Testes)",
            "expect(content).toContain(Unit)",
            "expect(content).toContain(Integration)",
            "expect(content).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve incluir visualiza칞칚o gr치fica no HTML",
          "asserts": [
            "expect(isHTML).toBe(true)",
            "expect(content).toContain(TestProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve incluir status de sa칰de no relat칩rio",
          "asserts": [
            "expect(hasHealth).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve lidar com aus칡ncia de coverage-analysis.json",
          "asserts": [
            "expect(error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve gerar plano de testes b치sico",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.plan).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve criar arquivo TEST-PLAN.md",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(TestProduct2)",
            "expect(content).toContain(Plano de Testes)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir exemplos quando solicitado",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve usar configura칞칚o de mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve organizar por dom칤nios quando fornecidos",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve validar par칙metros obrigat칩rios",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir TODOs autom치ticos no plano",
          "asserts": [
            "expect(content).toContain(游꿢 A칞칫es Recomendadas)",
            "expect(content).toContain(TODO: Create auth fixtures)",
            "expect(content).toContain(TODO: Consider Testcontainers)",
            "expect(content).toContain(TODO: Configure CI/CD pipeline)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir Quality Gates com thresholds",
          "asserts": [
            "expect(content).toContain(Quality Gates)",
            "expect(content).toContain(Required Coverage)",
            "expect(content).toContain(Performance)",
            "expect(content).toContain(Blocking Criteria)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve calcular risk scores quando houver dados de an치lise",
          "asserts": [
            "expect(content).toContain(游댠 Risk Score Analysis)",
            "expect(content).toMatch(/Score:/)",
            "expect(content).toMatch(/Probability:/)",
            "expect(content).toMatch(/Impact:/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar estrutura completa de QA para produto",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.path).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar diret칩rios de testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar mcp-settings.json com configura칞칫es corretas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(settings.product).toBe(TestProduct)",
            "expect(settings.base_url).toBe(https://www.example.com)",
            "expect(settings.domains).toEqual([...])",
            "expect(settings.critical_flows).toEqual([...])",
            "expect(settings.targets).toBeDefined",
            "expect(settings.targets.diff_coverage_min).toBe(80)",
            "expect(settings.targets.flaky_pct_max).toBe(5)",
            "expect(settings.targets.ci_p95_min).toBe(8)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(settings.targets).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar GETTING_STARTED.md",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(TestProduct)",
            "expect(content).toContain(https://www.example.com)",
            "expect(content).toContain(Responsabilidades)",
            "expect(content).toContain(Quality Gates)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar README.md",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(TestProduct)",
            "expect(content).toContain(Quick Start)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar .gitignore apropriado",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(storageState.json)",
            "expect(content).toContain(*.bak)",
            "expect(content).toContain(node_modules)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "n칚o deve sobrescrever mcp-settings.json existente",
          "asserts": [
            "expect(finalSettings.custom_field).toBe(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar environments corretos baseado na base_url",
          "asserts": [
            "expect(settings.environments).toBeDefined",
            "expect(settings.environments.dev.url).toBe(https://dev.example.com)",
            "expect(settings.environments.stg.url).toBe(https://stg.example.com)",
            "expect(settings.environments.prod.url).toBe(https://www.example.com)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(settings.environments).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve retornar estrutura b치sica mesmo sem testes",
          "asserts": [
            "expect(result).toHaveProperty(ok)",
            "expect(result).toHaveProperty(explanations)",
            "expect(result).toHaveProperty(metrics)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve gerar m칠tricas corretas para testes vazios",
          "asserts": [
            "expect(result.metrics.totalTests).toBe(0)",
            "expect(result.metrics.assertStrongPct).toBe(0)",
            "expect(result.metrics.assertMediumPct).toBe(0)",
            "expect(result.metrics.assertWeakPct).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve falhar quando failOn=",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result).toHaveProperty(explanations)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve gerar outputs JSON e MD conforme solicitado",
          "asserts": [
            "expect(result.outputPaths).toHaveProperty(explanationsJson)",
            "expect(result.outputPaths).toHaveProperty(explanationsMd)",
            "expect(result.outputPaths).toHaveProperty(qualitySummaryMd)",
            "expect(result.outputPaths).toHaveProperty(metricsJson)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve calcular KR3a status corretamente",
          "asserts": [
            "expect(result.kr3aStatus).toMatch(/OK|ATEN칂츾O|ALERTA/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve gerar SLOs com defaults baseados em criticidade",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBe(2)",
            "expect(result.custom_slos_count).toBe(0)",
            "expect(slosData.slos).toHaveLength(2)",
            "expect(criticalSLO.latency_p99_ms).toBeLessThanOrEqual(500)",
            "expect(criticalSLO.error_rate_max).toBeLessThanOrEqual(0.01)",
            "expect(criticalSLO.availability_min).toBeGreaterThanOrEqual(0.995)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve aplicar SLOs customizados quando fornecidos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.custom_slos_count).toBe(1)",
            "expect(searchSLO.latency_p99_ms).toBe(200)",
            "expect(searchSLO.error_rate_max).toBe(0.001)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve aplicar defaults customizados globais",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testSLO.latency_p99_ms).toBe(1000)",
            "expect(testSLO.error_rate_max).toBe(0.05)",
            "expect(testSLO.availability_min).toBe(0.99)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve lidar com cat치logo vazio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve coletar m칠tricas de testes",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard HTML",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(<!DOCTYPE html>)",
            "expect(content).toContain(TestApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve incluir gr치ficos de cobertura",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(50:30:20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard com visualiza칞칚o da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Visualiza칞칚o da Pir칙mide)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve lidar com aus칡ncia de m칠tricas",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve exibir status de sa칰de dos testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(85/100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve calcular % de unit/integration/E2E corretamente",
          "asserts": [
            "expect(totalTests).toBe(3)",
            "expect(result.pyramid.unit.files_found).toBe(1)",
            "expect(result.pyramid.integration.files_found).toBe(1)",
            "expect(result.pyramid.e2e.files_found).toBe(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "4",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "5",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "6",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "7",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve marcar como saud치vel se unit >= 70%",
          "asserts": [
            "expect(result.health).toBe(healthy)",
            "expect(result.summary).toContain(SAUD츼VEL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve alertar se E2E > unit",
          "asserts": [
            "expect(result.health).toBe(inverted)",
            "expect(hasInvertedWarning).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve sugerir mais unit tests se < 70%",
          "asserts": [
            "expect(hasUnitRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve salvar COVERAGE-REPORT.md e coverage-analysis.json",
          "asserts": [
            "expect(reportExists).toBe(true)",
            "expect(analysisExists).toBe(true)",
            "expect(data.summary).toBeDefined",
            "expect(data.pyramid).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(data.summary).toBeDefined - verificar valor espec칤fico",
            "expect(data.pyramid).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve lidar com reposit칩rio sem testes",
          "asserts": [
            "expect(result.pyramid.unit.files_found).toBe(0)",
            "expect(result.pyramid.integration.files_found).toBe(0)",
            "expect(result.pyramid.e2e.files_found).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve listar cen치rios de teste",
          "asserts": [
            "expect(result.total_scenarios).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should create user",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should update user",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve atribuir squads aos cen치rios",
          "asserts": [
            "expect(Object.keys().length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should login",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve detectar cen치rios duplicados",
          "asserts": [
            "expect(result.duplicates).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.duplicates).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve gerar matriz de responsabilidades",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(Matriz de Responsabilidade - Testes)",
            "expect(content).toContain(Squad A)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should work",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve salvar cat치logo em Markdown",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(Cat치logo de Cen치rios)",
            "expect(content).toContain(TestApp)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should pass",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve lidar com reposit칩rio sem testes",
          "asserts": [
            "expect(result.total_scenarios).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve contar cen치rios por squad",
          "asserts": [
            "expect(result.total_scenarios).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "test 1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "test 2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "test 3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve identificar cen치rios por prioridade",
          "asserts": [
            "expect(result.by_priority.P1.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should handle payment",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar rotas Next.js e classificar como medium risk",
          "asserts": [
            "expect(result.findings.routes).toContain(/)",
            "expect(result.findings.routes).toContain(/about)",
            "expect(result.summary).toContain(2 rotas web)",
            "expect(routeRisks.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar endpoints Express e sugerir CDC",
          "asserts": [
            "expect(result.findings.endpoints).toHaveLength(2)",
            "expect(result.findings.endpoints).toContain(GET /api/users)",
            "expect(result.findings.endpoints).toContain(POST /api/users)",
            "expect(hasCDCRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar eventos e mapear riscos",
          "asserts": [
            "expect(result.findings.events).toHaveLength(2)",
            "expect(result.findings.events).toContain(kafka:user-created)",
            "expect(result.findings.events).toContain(event:order-placed)",
            "expect(eventRisks.length).toBe(2)",
            "expect(eventRisks.every()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "order-placed",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos findings",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(hasE2ERecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve salvar resultado em tests/analyses/analyze.json",
          "asserts": [
            "expect(fileExists).toBe(true)",
            "expect(data.summary).toBeDefined",
            "expect(data.findings).toBeDefined",
            "expect(data.recommendations).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(data.summary).toBeDefined - verificar valor espec칤fico",
            "expect(data.findings).toBeDefined - verificar valor espec칤fico",
            "expect(data.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve lidar com reposit칩rio sem c칩digo",
          "asserts": [
            "expect(result.findings.routes).toEqual([...])",
            "expect(result.findings.endpoints).toEqual([...])",
            "expect(result.findings.events).toEqual([...])",
            "expect(result.summary).toContain(0 rotas web)",
            "expect(result.summary).toContain(0 endpoints)",
            "expect(result.summary).toContain(0 eventos)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve marcar rotas cr칤ticas como high risk",
          "asserts": [
            "expect(loginRisk).toBeDefined",
            "expect(unknown).toBe(high)",
            "expect(unknown).toContain(fluxo cr칤tico)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(loginRisk).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve reduzir risco de endpoints quando OpenAPI est치 presente",
          "asserts": [
            "expect(endpointRisk).toBeDefined",
            "expect(unknown).toBe(low)",
            "expect(unknown).toContain(contrato OpenAPI)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(endpointRisk).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve recomendar quais arquivos testar primeiro",
          "asserts": [
            "expect(recommendation.ok).toBe(true)",
            "expect(recommendation.recommendation).toBeDefined",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(parserFile.priority).toBe(HIGH)",
            "expect(parserFile.reason).toContain(parsing)",
            "expect(parserFile.reason).toContain(complexa)",
            "expect(configFile.priority).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(recommendation.recommendation).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "\\\\n",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes para arquivos de alta prioridade",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.generated).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(scaffoldResult.framework).toBe(vitest)",
            "expect(testExists).toBe(true)",
            "expect(testContent).toContain(describe)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(it)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(expect)",
            "expect(testContent).toContain(vitest)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toContain(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldResult.generated).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes com framework recomendado",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testContent).toContain(jest)",
            "expect(testContent).toContain(describe)",
            "expect(packageJson.scripts.test).toContain(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas na cobertura atual",
          "asserts": [
            "expect(coverage.summary).toContain(Status:)",
            "expect(coverage.summary).toContain(Pir칙mide)",
            "expect(coverage.pyramid.unit.files_found).toBeGreaterThanOrEqual(0)",
            "expect(coverage.pyramid.e2e.files_found).toBeGreaterThanOrEqual(0)",
            "expect(coverage.health).toBe(inverted)",
            "expect(coverage.recommendations.length).toBeGreaterThan(0)",
            "expect(hasUnitRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve usar coverage analysis para gerar relat칩rio visual",
          "asserts": [
            "expect(coverage.health).toBe(healthy)",
            "expect(pyramidReport.ok).toBe(true)",
            "expect(pyramidReport.report_path).toMatch(/PYRAMID-REPORT\\.(html|md)$/)",
            "expect(htmlExists).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(htmlContent.length).toBeGreaterThan(500)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas em gaps",
          "asserts": [
            "expect(coverage.pyramid.unit.files_found).toBe(0)",
            "expect(coverage.pyramid.unit.missing_tests.length).toBeGreaterThan(0)",
            "expect(coverage.recommendations.length).toBeGreaterThan(0)",
            "expect(report.ok).toBe(true)",
            "expect(mdContent.length).toBeGreaterThan(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve gerar plano baseado nos findings da an치lise",
          "asserts": [
            "expect(analysis.findings.routes).toContain(/login)",
            "expect(analysis.findings.endpoints.length).toBeGreaterThan(0)",
            "expect(plan.ok).toBe(true)",
            "expect(plan.plan).toBeDefined",
            "expect(planExists).toBe(true)",
            "expect(planContent).toContain(Test App)",
            "expect(planContent).toContain(Playwright)",
            "expect(planContent).toContain(playwright.config.ts)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(plan.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve incluir recomenda칞칫es da an치lise no plano",
          "asserts": [
            "expect(analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(plan.ok).toBe(true)",
            "expect(planContent).toContain(Cen치rios)",
            "expect(planContent).toContain(Risco)",
            "expect(planContent).toContain(Playwright)",
            "expect(planContent).toContain(Exemplo)",
            "expect(planContent).toContain(example)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve organizar plano por dom칤nios quando especificados",
          "asserts": [
            "expect(plan.ok).toBe(true)",
            "expect(planContent.length).toBeGreaterThan(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[1/4] scaffold_contracts_pact - deve detectar servi칞os e gerar contratos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.message).toContain(Generated)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.timestamp).toBeDefined",
            "expect(catalog.product).toBe(test-cdc-app)",
            "expect(catalog.services).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.services.length).toBeGreaterThan(0)",
            "expect(catalog.potential_contracts).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.coverage).toBeDefined",
            "expect(catalog.coverage.total_integrations).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(configContent).toContain(pactConfig)",
            "expect(configContent).toContain(test-cdc-app)",
            "expect(configContent).toContain(consumer)",
            "expect(configContent).toContain(provider)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(consumer)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(interaction)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(verify)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.services).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.potential_contracts).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.coverage).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[2/4] scaffold_contracts_pact - deve detectar m칰ltiplas APIs corretamente",
          "asserts": [
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(service.endpoints).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(service.endpoints.?).toHaveProperty(method)",
            "expect(service.endpoints.?).toHaveProperty(path)",
            "expect(contract).toHaveProperty(consumer)",
            "expect(contract).toHaveProperty(provider)",
            "expect(contract).toHaveProperty(priority)",
            "expect(unknown).toContain",
            "expect(contract.estimated_interactions).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(service.endpoints).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[3/4] run_contracts_verify - deve verificar contratos gerados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.verified).toBeGreaterThanOrEqual(0)",
            "expect(result.failed).toBeGreaterThanOrEqual(0)",
            "expect(result.report_path).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(report.timestamp).toBeDefined",
            "expect(report.product).toBe(testProduct)",
            "expect(report.language).toBe(typescript)",
            "expect(report.total_contracts).toBeGreaterThan(0)",
            "expect(report.total_interactions).toBeGreaterThan(0)",
            "expect(report.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(report.results).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(report.duration_total_ms).toBeGreaterThan(0)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)",
            "expect(mdContent).toContain(Verification Rate)",
            "expect(mdContent).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico",
            "expect(report.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(report.results).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[4/4] FULL PIPELINE - scaffold + verify funcionam em sequ칡ncia",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.total_contracts).toBeGreaterThan(0)",
            "expect(configContent).toContain(pact-broker.example.com)",
            "expect(verifyResult.ok).toBe(true)",
            "expect(verifyResult.total_interactions).toBe(6)",
            "expect(verifyResult.verification_rate).toBeGreaterThan(0)",
            "expect(report.total_contracts).toBe(3)",
            "expect(report.total_interactions).toBe(6)",
            "expect(report.verified).toBeGreaterThanOrEqual(0)",
            "expect(report.failed).toBeGreaterThanOrEqual(0)",
            "expect(unknown).toBe(6)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[FULL PIPELINE] FASE 1 + FASE 2 completa",
          "asserts": [
            "expect(cujResult.ok).toBe(true)",
            "expect(slosResult.ok).toBe(true)",
            "expect(riskResult.ok).toBe(true)",
            "expect(portfolioResult.ok).toBe(true)",
            "expect(portfolioResult.output).toContain(PORTFOLIO-PLAN.md)",
            "expect(existsSync()).toBe(true)",
            "expect(portfolioResult.recommendations_count).toBeGreaterThanOrEqual(0)",
            "expect(reportContent).toContain(# Test Portfolio Plan)",
            "expect(reportContent).toContain(## 游늵 Current State)",
            "expect(reportContent).toContain(## 游꿢 Target Distribution)",
            "expect(reportContent).toContain(## 游꿢 Module Recommendations)",
            "expect(reportContent).toContain(## 九 Action Items)",
            "expect(reportContent).toContain(Fowler)",
            "expect(reportContent).toContain(70%)",
            "expect(reportContent).toContain(20%)",
            "expect(reportContent).toContain(10%)",
            "expect(reportContent).toContain(| Test Type | Count | Percentage | Target | Gap |)",
            "expect(reportContent).toContain(Unit)",
            "expect(reportContent).toContain(Integration)",
            "expect(reportContent).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[VALIDATION] Portfolio plan deve ter estrutura correta",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(content).toContain(section)",
            "expect(content).toMatch(/\\/\\\\/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[INTEGRATION] Recommendations devem estar baseadas em riscos",
          "asserts": [
            "expect(portfolioContent).toContain(游뚿 Top 5 Critical Risks)",
            "expect(portfolioContent).toContain(Module Recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[METRICS] Distribui칞칚o deve somar 100%",
          "asserts": [
            "expect(content).toContain(Current State)",
            "expect(total).toBeGreaterThanOrEqual(99.9)",
            "expect(total).toBeLessThanOrEqual(100.1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[1/3] catalog_cujs deve gerar cuj-catalog.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(cuj-catalog.json)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog).toHaveProperty(timestamp)",
            "expect(catalog).toHaveProperty(repo)",
            "expect(catalog).toHaveProperty(product)",
            "expect(catalog).toHaveProperty(cujs)",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.cujs.length).toBeGreaterThan(0)",
            "expect(firstCUJ).toHaveProperty(id)",
            "expect(firstCUJ).toHaveProperty(name)",
            "expect(firstCUJ).toHaveProperty(criticality)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[2/3] define_slos deve gerar slos.json baseado em CUJs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(slos.json)",
            "expect(existsSync()).toBe(true)",
            "expect(slos).toHaveProperty(timestamp)",
            "expect(slos).toHaveProperty(repo)",
            "expect(slos).toHaveProperty(product)",
            "expect(slos).toHaveProperty(slos)",
            "expect(slos).toHaveProperty(defaults_applied)",
            "expect(unknown).toBe(boolean)",
            "expect(firstSLO).toHaveProperty(cuj_id)",
            "expect(firstSLO).toHaveProperty(error_rate_max)",
            "expect(firstSLO).toHaveProperty(availability_min)",
            "expect(firstSLO.error_rate_max).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.error_rate_max).toBeLessThanOrEqual(1)",
            "expect(firstSLO.availability_min).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.availability_min).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[3/3] risk_register deve gerar risk-register.json cruzando CUJs + SLOs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_risks).toBeGreaterThan(0)",
            "expect(result.output).toContain(risk-register.json)",
            "expect(existsSync()).toBe(true)",
            "expect(riskReg).toHaveProperty(timestamp)",
            "expect(riskReg).toHaveProperty(repo)",
            "expect(riskReg).toHaveProperty(product)",
            "expect(riskReg).toHaveProperty(risks)",
            "expect(riskReg).toHaveProperty(top_5_critical)",
            "expect(riskReg).toHaveProperty(total_risk_score)",
            "expect(riskReg).toHaveProperty(coverage_gaps)",
            "expect(Array.isArray()).toBe(true)",
            "expect(riskReg.top_5_critical.length).toBeLessThanOrEqual(5)",
            "expect(unknown).toBe(string)",
            "expect(firstRisk).toHaveProperty(id)",
            "expect(firstRisk).toHaveProperty(cuj_id)",
            "expect(firstRisk).toHaveProperty(title)",
            "expect(firstRisk).toHaveProperty(description)",
            "expect(firstRisk).toHaveProperty(impact)",
            "expect(firstRisk).toHaveProperty(probability)",
            "expect(firstRisk).toHaveProperty(risk_score)",
            "expect(firstRisk).toHaveProperty(affected_modules)",
            "expect(firstRisk).toHaveProperty(mitigation_strategies)",
            "expect(firstRisk).toHaveProperty(recommended_tests)",
            "expect(firstRisk.risk_score).toBeGreaterThanOrEqual(0)",
            "expect(firstRisk.risk_score).toBeLessThanOrEqual(100)",
            "expect(unknown).toContain",
            "expect(unknown).toContain",
            "expect(validTests).toContain(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[FULL] Pipeline completo deve criar 3 arquivos consistentes",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.cujs.length).toBe",
            "expect(catalog.cujs.length).toBe",
            "expect(sloIds.has()).toBe(true)",
            "expect(r.id).toBe",
            "expect(cujIds.has()).toBe(true)",
            "expect(riskIds.has()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar estrutura completa de QA",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.path).toContain(EcommerceApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar mcp-settings.json com configura칞칫es corretas",
          "asserts": [
            "expect(settings).toMatchObject({...})",
            "expect(settings.environments).toHaveProperty(dev)",
            "expect(settings.environments).toHaveProperty(stg)",
            "expect(settings.environments).toHaveProperty(prod)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar estrutura de diret칩rios completa",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar GETTING_STARTED.md com documenta칞칚o",
          "asserts": [
            "expect(content).toContain(EcommerceApp)",
            "expect(content).toContain(Quality MCP)",
            "expect(content).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar README.md",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar .gitignore apropriado",
          "asserts": [
            "expect(content).toContain(node_modules/)",
            "expect(content).toContain(coverage/)",
            "expect(content).toContain(playwright-report/)",
            "expect(content).toContain(.env)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "n칚o deve sobrescrever mcp-settings.json existente",
          "asserts": [
            "expect(newSettings.custom_field).toBe(should_persist)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve permitir criar m칰ltiplos produtos no mesmo repo",
          "asserts": [
            "expect(ecommerceExists).toBe(true)",
            "expect(paymentExists).toBe(true)",
            "expect(ecommerceSettings.product).toBe(EcommerceApp)",
            "expect(ecommerceSettings.base_url).toBe(https://www.ecommerce.com)",
            "expect(paymentSettings.product).toBe(PaymentService)",
            "expect(paymentSettings.base_url).toBe(https://api.payment.com)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should get users",
          "asserts": [
            "expect(getUsers).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(getUsers).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve executar analyze e detectar endpoints",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve criar analyze.json com findings",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(findings)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve permitir pipeline completo: analyze  coverage  plan",
          "asserts": [
            "expect(analyzeResult.findings).toBeDefined",
            "expect(coverageResult.pyramid).toBeDefined",
            "expect(planResult.plan).toBeDefined",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeResult.findings).toBeDefined - verificar valor espec칤fico",
            "expect(coverageResult.pyramid).toBeDefined - verificar valor espec칤fico",
            "expect(planResult.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve usar configura칞칚o centralizada de mcp-settings.json",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve validar health da pir칙mide corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  100 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "fileExists",
      "filePath": "src/utils/fs.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio recursivamente",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar se diret칩rio j치 existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio pai e escrever arquivo",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve sobrescrever arquivo existente",
          "asserts": [
            "expect(readContent).toBe(New content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro se arquivo n칚o existir",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler conte칰do de arquivo existente",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.mkdir com op칞칚o recursive:true",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(nestedDir)",
            "expect(mkdirSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar quando diret칩rio j치 existe (EEXIST)",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar ensureDir antes de escrever arquivo",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalled",
            "expect(mkdirSpy.mock.calls.?.?).toEqual({...})",
            "expect(writeFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(mkdirSpy.mock.invocationCallOrder.?).toBeLessThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar backup quando arquivo existe e createBackup=true",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(backupContent).toBe(oldContent)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve logar mensagem de backup criado",
          "asserts": [
            "expect(consoleLogSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve criar backup quando createBackup=false",
          "asserts": [
            "expect(copyFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.readFile com encoding utf8",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(readFileSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve propagar erro quando arquivo n칚o existe",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(nonExistentFile)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio com caracteres especiais no nome",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar caminho profundamente aninhado",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com diret칩rio que j치 existe (idempot칡ncia)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever arquivo com nome contendo caracteres especiais",
          "asserts": [
            "expect(written).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever string vazia sem erro",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever conte칰do muito grande (>1MB)",
          "asserts": [
            "expect(written.length).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com m칰ltiplas escritas sequenciais (race condition test)",
          "asserts": [
            "expect(final).toBe(content-4)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve falhar silenciosamente se backup falhar por falta de permiss칚o",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalled",
            "expect(consoleWarnSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo com diferentes encodings",
          "asserts": [
            "expect(utf8Content).toBe(content)",
            "expect(unknown).toBe(string)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro para arquivo n칚o existente",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo vazio",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para arquivo existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para diret칩rio existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para caminho vazio",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio inexistente",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio vazio",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve listar todos os arquivos em diret칩rio populado",
          "asserts": [
            "expect(files).toHaveLength(3)",
            "expect(files).toContain(file1.txt)",
            "expect(files).toContain(file2.txt)",
            "expect(files).toContain(subdir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com caracteres especiais em nomes de arquivos",
          "asserts": [
            "expect(files).toContain(specialName)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve retornar ok=true quando todos os SLOs s칚o atendidos",
          "asserts": [
            "expect(result.ok).toBeDefined",
            "expect(result.summary).toBeDefined",
            "expect(result.summary.total_cujs).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico",
            "expect(result.summary).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve detectar viola칞칫es de SLOs",
          "asserts": [
            "expect(result.violations).toBeDefined",
            "expect(result.recommendations).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.violations).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve gerar recomenda칞칫es quando h치 viola칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve retornar 100% quando n칚o h치 mudan칞as",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.diffCoverage).toBe(100)",
            "expect(result.linesAdded).toBe(0)",
            "expect(result.files).toHaveLength(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve usar configura칞칚o do mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/release-quality-gate.test.ts",
          "title": "deve retornar exit_code=0 quando todos os gates passam",
          "asserts": [
            "expect(result.exit_code).toBe(0)",
            "expect(result.summary.blocking_violations).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar estrutura completa de QA para produto",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.path).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar diret칩rios de testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar mcp-settings.json com configura칞칫es corretas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(settings.product).toBe(TestProduct)",
            "expect(settings.base_url).toBe(https://www.example.com)",
            "expect(settings.domains).toEqual([...])",
            "expect(settings.critical_flows).toEqual([...])",
            "expect(settings.targets).toBeDefined",
            "expect(settings.targets.diff_coverage_min).toBe(80)",
            "expect(settings.targets.flaky_pct_max).toBe(5)",
            "expect(settings.targets.ci_p95_min).toBe(8)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(settings.targets).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar GETTING_STARTED.md",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(TestProduct)",
            "expect(content).toContain(https://www.example.com)",
            "expect(content).toContain(Responsabilidades)",
            "expect(content).toContain(Quality Gates)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar README.md",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(TestProduct)",
            "expect(content).toContain(Quick Start)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar .gitignore apropriado",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(storageState.json)",
            "expect(content).toContain(*.bak)",
            "expect(content).toContain(node_modules)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "n칚o deve sobrescrever mcp-settings.json existente",
          "asserts": [
            "expect(finalSettings.custom_field).toBe(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar environments corretos baseado na base_url",
          "asserts": [
            "expect(settings.environments).toBeDefined",
            "expect(settings.environments.dev.url).toBe(https://dev.example.com)",
            "expect(settings.environments.stg.url).toBe(https://stg.example.com)",
            "expect(settings.environments.prod.url).toBe(https://www.example.com)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(settings.environments).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar rotas Next.js e classificar como medium risk",
          "asserts": [
            "expect(result.findings.routes).toContain(/)",
            "expect(result.findings.routes).toContain(/about)",
            "expect(result.summary).toContain(2 rotas web)",
            "expect(routeRisks.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar endpoints Express e sugerir CDC",
          "asserts": [
            "expect(result.findings.endpoints).toHaveLength(2)",
            "expect(result.findings.endpoints).toContain(GET /api/users)",
            "expect(result.findings.endpoints).toContain(POST /api/users)",
            "expect(hasCDCRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar eventos e mapear riscos",
          "asserts": [
            "expect(result.findings.events).toHaveLength(2)",
            "expect(result.findings.events).toContain(kafka:user-created)",
            "expect(result.findings.events).toContain(event:order-placed)",
            "expect(eventRisks.length).toBe(2)",
            "expect(eventRisks.every()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "order-placed",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos findings",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(hasE2ERecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve salvar resultado em tests/analyses/analyze.json",
          "asserts": [
            "expect(fileExists).toBe(true)",
            "expect(data.summary).toBeDefined",
            "expect(data.findings).toBeDefined",
            "expect(data.recommendations).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(data.summary).toBeDefined - verificar valor espec칤fico",
            "expect(data.findings).toBeDefined - verificar valor espec칤fico",
            "expect(data.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve lidar com reposit칩rio sem c칩digo",
          "asserts": [
            "expect(result.findings.routes).toEqual([...])",
            "expect(result.findings.endpoints).toEqual([...])",
            "expect(result.findings.events).toEqual([...])",
            "expect(result.summary).toContain(0 rotas web)",
            "expect(result.summary).toContain(0 endpoints)",
            "expect(result.summary).toContain(0 eventos)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve marcar rotas cr칤ticas como high risk",
          "asserts": [
            "expect(loginRisk).toBeDefined",
            "expect(unknown).toBe(high)",
            "expect(unknown).toContain(fluxo cr칤tico)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(loginRisk).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve reduzir risco de endpoints quando OpenAPI est치 presente",
          "asserts": [
            "expect(endpointRisk).toBeDefined",
            "expect(unknown).toBe(low)",
            "expect(unknown).toContain(contrato OpenAPI)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(endpointRisk).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  14 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "readDir",
      "filePath": "src/utils/fs.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio recursivamente",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar se diret칩rio j치 existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio pai e escrever arquivo",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve sobrescrever arquivo existente",
          "asserts": [
            "expect(readContent).toBe(New content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro se arquivo n칚o existir",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler conte칰do de arquivo existente",
          "asserts": [
            "expect(readContent).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.mkdir com op칞칚o recursive:true",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(nestedDir)",
            "expect(mkdirSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve falhar quando diret칩rio j치 existe (EEXIST)",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalledWith(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar ensureDir antes de escrever arquivo",
          "asserts": [
            "expect(mkdirSpy).toHaveBeenCalled",
            "expect(mkdirSpy.mock.calls.?.?).toEqual({...})",
            "expect(writeFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(mkdirSpy.mock.invocationCallOrder.?).toBeLessThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar backup quando arquivo existe e createBackup=true",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(backupContent).toBe(oldContent)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve logar mensagem de backup criado",
          "asserts": [
            "expect(consoleLogSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "n칚o deve criar backup quando createBackup=false",
          "asserts": [
            "expect(copyFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve chamar fs.readFile com encoding utf8",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(filePath)",
            "expect(readFileSpy).toHaveBeenCalledTimes(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve propagar erro quando arquivo n칚o existe",
          "asserts": [
            "expect(readFileSpy).toHaveBeenCalledWith(nonExistentFile)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar diret칩rio com caracteres especiais no nome",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve criar caminho profundamente aninhado",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com diret칩rio que j치 existe (idempot칡ncia)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever arquivo com nome contendo caracteres especiais",
          "asserts": [
            "expect(written).toBe(content)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever string vazia sem erro",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve escrever conte칰do muito grande (>1MB)",
          "asserts": [
            "expect(written.length).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com m칰ltiplas escritas sequenciais (race condition test)",
          "asserts": [
            "expect(final).toBe(content-4)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve falhar silenciosamente se backup falhar por falta de permiss칚o",
          "asserts": [
            "expect(copyFileSpy).toHaveBeenCalled",
            "expect(consoleWarnSpy).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo com diferentes encodings",
          "asserts": [
            "expect(utf8Content).toBe(content)",
            "expect(unknown).toBe(string)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lan칞ar erro para arquivo n칚o existente",
          "asserts": [],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve ler arquivo vazio",
          "asserts": [
            "expect(content).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para arquivo existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar true para diret칩rio existente",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar false para caminho vazio",
          "asserts": [
            "expect(exists).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio inexistente",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve retornar array vazio para diret칩rio vazio",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve listar todos os arquivos em diret칩rio populado",
          "asserts": [
            "expect(files).toHaveLength(3)",
            "expect(files).toContain(file1.txt)",
            "expect(files).toContain(file2.txt)",
            "expect(files).toContain(subdir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/fs.test.ts",
          "title": "deve lidar com caracteres especiais em nomes de arquivos",
          "asserts": [
            "expect(files).toContain(specialName)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "inferProductFromPackageJson",
      "filePath": "src/utils/config.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "loadMCPSettings",
      "filePath": "src/utils/config.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  12 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "mergeSettings",
      "filePath": "src/utils/config.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  12 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "createMCPSettingsTemplate",
      "filePath": "src/utils/config.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "validate",
      "filePath": "src/tools/validate.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates)",
          "asserts": [
            "expect(MCP_TOOLS).toHaveLength(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tools devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(tool).toHaveProperty(name)",
            "expect(tool).toHaveProperty(description)",
            "expect(tool).toHaveProperty(inputSchema)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(tool.inputSchema.type).toBe(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve conter todos os 5 tools esperados",
          "asserts": [
            "expect(names).toContain(name)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve encontrar tool por nome",
          "asserts": [
            "expect(tool).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(tool).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve retornar undefined para tool inexistente",
          "asserts": [
            "expect(tool).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool analyze deve ter campos repo e product obrigat칩rios",
          "asserts": [
            "expect(tool.inputSchema.required).toContain(repo)",
            "expect(tool.inputSchema.required).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool validate deve ter campos de threshold",
          "asserts": [
            "expect(props).toHaveProperty(minBranch)",
            "expect(props).toHaveProperty(minMutation)",
            "expect(props).toHaveProperty(minDiffCoverage)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool scaffold deve ter campo type com enum",
          "asserts": [
            "expect(typeField.enum).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "todos os tools devem ter description com emoji",
          "asserts": [
            "expect(tool.description.length).toBeGreaterThan(10)",
            "expect(tool.description.charCodeAt()).toBeGreaterThan(255)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear dom칤nios separados por v칤rgula",
          "asserts": [
            "expect(domains).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear critical flows separados por v칤rgula",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear JSON de targets",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o se n칚o especificado",
          "asserts": [
            "expect(defaultOut).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve aceitar include-examples como boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(packages/product-e2e)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve converter --headed para headless=false",
          "asserts": [
            "expect(headless).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar headless=true por padr칚o",
          "asserts": [
            "expect(headless).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de relat칩rios padr칚o",
          "asserts": [
            "expect(defaultReport).toBe(reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar arquivo de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(SUMMARY.md)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de arquivos",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de endpoints",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de squads",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear thresholds JSON",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar URL base",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar URL inv치lida",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar nome de produto alphanumeric",
          "asserts": [
            "expect(regex.test()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar nome de produto com caracteres especiais",
          "asserts": [
            "expect(regex.test()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato markdown",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato html",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato json",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar formato inv치lido",
          "asserts": [
            "expect(['markdown', 'html', 'json']).not.toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar jest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar vitest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar mocha",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter todos os comandos esperados registrados na CLI",
          "asserts": [
            "expect(helpOutput).toContain(command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter descri칞칫es para todos os comandos",
          "asserts": [
            "expect(helpOutput).toContain",
            "expect(helpOutput).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar que comandos espec칤ficos aceitam par칙metros obrigat칩rios",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)",
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar comandos inexistentes com mensagem clara",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(output).toMatch(/unknown command|error/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve garantir que scripts npm correspondam aos comandos CLI",
          "asserts": [
            "expect(packageJson.scripts).toHaveProperty(scriptName)",
            "expect(packageJson.scripts.scriptName).toContain(cliCommand)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-run deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--fix deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-scaffold deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(opts.skipScaffold).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--repo deve rejeitar se n칚o tiver valor",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--product deve aceitar valor",
          "asserts": [
            "expect(opts.product).toBe(my-product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "analyze --repo . --product ",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.product).toBe(mcp)",
            "expect(opts.mode).toBe(analyze)",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "self-check --repo . --fix",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.minMutation).toBe(60)",
            "expect(opts.minBranch).toBe(70)",
            "expect(opts.failFast).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "Boolean defaultValue = flag sem <value>",
          "asserts": [
            "expect(booleanFlags.length).toBeGreaterThanOrEqual(2)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "String/Number defaultValue = flag com <value>",
          "asserts": [
            "expect(valueFlags.length).toBeGreaterThanOrEqual(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve PASSAR quando mutation score >= threshold",
          "asserts": [
            "expect(result.passed).toBe(true)",
            "expect(result.violations).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve FALHAR quando mutation score < threshold",
          "asserts": [
            "expect(result.passed).toBe(false)",
            "expect(result.violations).toHaveLength(1)",
            "expect(result.violations.?.gate).toBe(Mutation Score)",
            "expect(result.violations.?.threshold).toBe(70)",
            "expect(result.violations.?.actual).toBe(40)",
            "expect(result.violations.?.suggestions).toContain(游늵 Mutation Score: 40% (threshold: 70%))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve retornar sugest칫es de corre칞칚o para mutantes sobreviventes",
          "asserts": [
            "expect(result.passed).toBe(false)",
            "expect(result.violations.?.suggestions).toEqual"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve FALHAR quando relat칩rio de muta칞칚o n칚o existe",
          "asserts": [
            "expect(result.passed).toBe(false)",
            "expect(result.violations).toHaveLength(1)",
            "expect(result.violations.?.message).toContain(Nenhum relat칩rio de muta칞칚o encontrado)",
            "expect(result.violations.?.suggestions).toContain(1. Instale Stryker: npm install --save-dev @stryker-mutator/core @stryker-mutator/vitest-runner)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve lidar com relat칩rio JSON malformado",
          "asserts": [
            "expect(result.passed).toBe(false)",
            "expect(result.violations).toHaveLength(1)",
            "expect(result.violations[0].message).toContain('Erro ao ler relat칩rio de muta칞칚o')",
            "expect(result.passed).toBe(true)",
            "expect(result.violations).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve ignorar minMutation se n칚o fornecido",
          "asserts": [
            "expect(result.passed).toBe(true)",
            "expect(result.violations).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should default to FULL mode for unrecognized queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.repo).toBe(/home/user/project)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract product override",
          "asserts": [
            "expect(result.product).toBe(MyApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.repo).toBe(/tmp/test)",
            "expect(result.product).toBe(Portal)",
            "expect(result.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return empty object for no overrides",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should execute with detected mode from query",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should merge extracted overrides with detected mode",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.extracted_params).toEqual({...})",
            "expect(result.final_params).toMatchObject({...})",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should apply defaults and override with extracted params",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should prioritize explicit mode override over detected mode",
          "asserts": [
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(analyze)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.success).toBe(false)",
            "expect(result.error).toBe(Test error)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return true on success",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return false on error",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should analyze TypeScript project with basic tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(Vitest)",
            "expect(result.functions.length).toBeGreaterThan(0)",
            "expect(addFunc).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(addFunc).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should add positive numbers",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle zero",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should multiply numbers",
          "asserts": [
            "expect(multiply()).toBe(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect framework automatically",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate scenario coverage correctly",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should validate correct email",
          "asserts": [
            "expect(validateEmail()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should reject invalid email",
          "asserts": [
            "expect(validateEmail()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should throw on empty email",
          "asserts": [
            "expect(unknown).toThrow(Email required)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty repository",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])",
            "expect(result.metrics.qualityScore).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle repository without tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toEqual([...])",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle functions with weak assertions",
          "asserts": [
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should return user",
          "asserts": [
            "expect(user).toBeTruthy",
            "expect(user).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(user).toBeTruthy - usar compara칞칚o expl칤cita",
            "expect(user).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle null/undefined inputs gracefully",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle very large codebase efficiently",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBeGreaterThanOrEqual(10)",
            "expect(duration).toBeLessThan(10000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle invalid repository path",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed source files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')",
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined()",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain('TEST-QUALITY-LOGICAL-REPORT.md')",
            "expect(result.reportPath).toContain(testDir)",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(hasLogicLogs).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('python')",
            "expect(result.framework).toBe('Pytest')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('go')",
            "expect(result.framework).toBe('go test')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('java')",
            "expect(result.framework).toBe('JUnit')",
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(\n        result.metrics.scenarioCoverage.happy +\n        result.metrics.scenarioCoverage.edge +\n        result.metrics.scenarioCoverage.error +\n        result.metrics.scenarioCoverage.sideEffects\n      ).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined() - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle missing package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Unknown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should generate patches when requested",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should write report to correct location",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain(TEST-QUALITY-LOGICAL-REPORT.md)",
            "expect(result.reportPath).toContain(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should log progress to console",
          "asserts": [
            "expect(consoleSpy).toHaveBeenCalled",
            "expect(hasLogicLogs).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should create output directories if they do not exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Python projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(python)",
            "expect(result.framework).toBe(Pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Go projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(go)",
            "expect(result.framework).toBe(go test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Java projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(java)",
            "expect(result.framework).toBe(JUnit)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate quality score based on coverage",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should process valid data",
          "asserts": [
            "expect(processData()).toBe(HELLO)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty string",
          "asserts": [
            "expect(unknown).toThrow(No data)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle special characters",
          "asserts": [
            "expect(processData()).toBe(A@B)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar projeto TypeScript com package.json",
          "asserts": [
            "expect(result).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar projeto TypeScript com tsconfig.json",
          "asserts": [
            "expect(result).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve retornar false para diret칩rio sem arquivos TypeScript",
          "asserts": [
            "expect(result).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar vitest via vitest.config.ts",
          "asserts": [
            "expect(result).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar jest via jest.config.js",
          "asserts": [
            "expect(result).toBe(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve retornar null se n칚o detectar framework",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir fun칞칚o exportada simples",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})",
            "expect(functions.?.criticality).toBe(CRITICAL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir fun칞칚o async",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir arrow function exportada",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve determinar criticality CRITICAL para validadores",
          "asserts": [
            "expect(functions.?.criticality).toBe(CRITICAL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve determinar criticality HIGH para fun칞칫es de escrita",
          "asserts": [
            "expect(functions.?.criticality).toBe(HIGH)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve ignorar arquivos de teste",
          "asserts": [
            "expect(functions).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir testes com it()",
          "asserts": [
            "expect(tests).toHaveLength(1)",
            "expect(tests.?).toMatchObject({...})",
            "expect(tests.?.assertions).toHaveLength(1)",
            "expect(tests.?.assertions.?.type).toBe(toEqual)",
            "expect(tests.?.assertions.?.isWeak).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should parse valid JSON",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir testes com test()",
          "asserts": [
            "expect(tests).toHaveLength(1)",
            "expect(tests.?.name).toBe(adds two numbers)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "adds two numbers",
          "asserts": [
            "expect(unknown).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar spies",
          "asserts": [
            "expect(tests.?.hasSpies).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should log message",
          "asserts": [
            "expect(spy).toHaveBeenCalledWith(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar mocks",
          "asserts": [
            "expect(tests.?.hasMocks).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should fetch user",
          "asserts": [
            "expect(user).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar asser칞칫es fracas",
          "asserts": [
            "expect(tests.?.assertions.?.isWeak).toBe(true)",
            "expect(tests.?.assertions.?.type).toBe(toBeTruthy)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(tests.?.assertions.?.type).toBe(toBeTruthy) - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should be truthy",
          "asserts": [
            "expect(someValue).toBeTruthy"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(someValue).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar m칰ltiplas asser칞칫es",
          "asserts": [
            "expect(tests.?.assertions).toHaveLength(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "validates user",
          "asserts": [
            "expect(user.name).toBe(John)",
            "expect(user.age).toEqual(30)",
            "expect(user.email).toMatch(/@/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar happy path com asser칞칫es fortes",
          "asserts": [
            "expect(matrix).toHaveLength(1)",
            "expect(matrix.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "adds two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar error handling",
          "asserts": [
            "expect(matrix.?.error).toBe(true)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "throws on negative age",
          "asserts": [
            "expect(unknown).toThrow(Invalid age)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar edge cases por nome do teste",
          "asserts": [
            "expect(matrix.?.edge).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "handles empty string",
          "asserts": [
            "expect(getLength()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar side effects com spies",
          "asserts": [
            "expect(matrix.?.sideEffects).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "logs message to console",
          "asserts": [
            "expect(spy).toHaveBeenCalledWith(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve identificar gaps de cen치rios faltantes",
          "asserts": [
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Error Handling)",
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Edge Cases)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "fetches data",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve sugerir side effects para fun칞칫es com verbos de a칞칚o",
          "asserts": [
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Side Effects (fun칞칚o tem efeitos colaterais))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "creates user",
          "asserts": [
            "expect(user.name).toBe(John)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command tool available",
          "asserts": [
            "expect(toolName).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto tool available",
          "asserts": [
            "expect(toolName).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command as high priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto as second priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid natural language query",
          "asserts": [
            "expect(validParams.query).toBe(analise meu reposit칩rio)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept query with defaults",
          "asserts": [
            "expect(unknown).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should reject empty query",
          "asserts": [
            "expect(unknown).toThrow(Query cannot be empty)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid mode",
          "asserts": [
            "expect(validParams.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept all modes",
          "asserts": [
            "expect(params.mode).toBe(mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept skip flags",
          "asserts": [
            "expect(params.skipScaffold).toBe(true)",
            "expect(params.skipRun).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should work with minimal params (auto-detection)",
          "asserts": [
            "expect(params).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(params).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate nl_command schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(query)",
            "expect(expectedProperties).toContain(defaults)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate auto schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(mode)",
            "expect(expectedProperties).toContain(repo)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have correct mode enum values",
          "asserts": [
            "expect(validModes).toHaveLength(5)",
            "expect(validModes).toContain(full)",
            "expect(validModes).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support nl_command  auto flow",
          "asserts": [
            "expect(nlParams.query).toBeTruthy",
            "expect(unknown).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(nlParams.query).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support direct auto invocation",
          "asserts": [
            "expect(autoParams.mode).toBe(analyze)",
            "expect(autoParams.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support defaults override in nl_command",
          "asserts": [
            "expect(unknown).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle invalid mode gracefully",
          "asserts": [
            "expect(unknown).toThrow(Invalid mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle missing required params",
          "asserts": [
            "expect(unknown).toThrow(Query is required)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive nl_command description",
          "asserts": [
            "expect(description).toContain(linguagem natural)",
            "expect(description).toContain(PT/EN)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive auto description",
          "asserts": [
            "expect(description).toContain(Orquestrador)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention supported languages in nl_command",
          "asserts": [
            "expect(examples).toContain(analise meu reposit칩rio)",
            "expect(examples).toContain(criar plano)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention available modes in auto",
          "asserts": [
            "expect(modes).toHaveLength(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  36 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "suiteHealth",
      "filePath": "src/tools/suite-health.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve medir sa칰de b치sica da su칤te",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_runtime_sec).toBeGreaterThanOrEqual(0)",
            "expect(result.flaky_tests_count).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve calcular instability index",
          "asserts": [
            "expect(result.instability_index).toBeDefined",
            "expect(unknown).toBe(number)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.instability_index).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve gerar recomenda칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve salvar relat칩rio em JSON",
          "asserts": [
            "expect(result.output).toContain(suite-health.json)",
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(timestamp)",
            "expect(content).toHaveProperty(total_runtime_sec)",
            "expect(content).toHaveProperty(instability_index)",
            "expect(content).toHaveProperty(recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "sloCanaryCheck",
      "filePath": "src/tools/slo-canary-check.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve retornar ok=true quando todos os SLOs s칚o atendidos",
          "asserts": [
            "expect(result.ok).toBeDefined",
            "expect(result.summary).toBeDefined",
            "expect(result.summary.total_cujs).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico",
            "expect(result.summary).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve detectar viola칞칫es de SLOs",
          "asserts": [
            "expect(result.violations).toBeDefined",
            "expect(result.recommendations).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.violations).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/slo-canary-check.test.ts",
          "title": "deve gerar recomenda칞칫es quando h치 viola칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  5 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "selfCheck",
      "filePath": "src/tools/self-check.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-run deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--fix deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-scaffold deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(opts.skipScaffold).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--repo deve rejeitar se n칚o tiver valor",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--product deve aceitar valor",
          "asserts": [
            "expect(opts.product).toBe(my-product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "analyze --repo . --product ",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.product).toBe(mcp)",
            "expect(opts.mode).toBe(analyze)",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "self-check --repo . --fix",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.minMutation).toBe(60)",
            "expect(opts.minBranch).toBe(70)",
            "expect(opts.failFast).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "Boolean defaultValue = flag sem <value>",
          "asserts": [
            "expect(booleanFlags.length).toBeGreaterThanOrEqual(2)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "String/Number defaultValue = flag com <value>",
          "asserts": [
            "expect(valueFlags.length).toBeGreaterThanOrEqual(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  19 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "scaffoldPlaywright",
      "filePath": "src/tools/scaffold.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve criar diret칩rios de testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(authExists).toBe(true)",
            "expect(claimExists).toBe(true)",
            "expect(searchExists).toBe(true)",
            "expect(fixturesExists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve gerar playwright.config.ts",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(configExists).toBe(true)",
            "expect(configContent).toContain(defineConfig)",
            "expect(configContent).toContain(timeout)",
            "expect(configContent).toContain(baseURL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve criar fixture de autentica칞칚o",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(fixtureExists).toBe(true)",
            "expect(fixtureContent).toContain(base)",
            "expect(fixtureContent).toContain(deprecated)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve gerar spec de login",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(loginExists).toBe(true)",
            "expect(loginContent).toContain(test)",
            "expect(loginContent).toContain(login)",
            "expect(loginContent).toContain(Email)",
            "expect(loginContent).toContain(Senha)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve gerar spec de reclama칞칚o",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(claimExists).toBe(true)",
            "expect(claimContent).toContain(test)",
            "expect(claimContent).toContain(reclama칞칚o)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve gerar spec de busca",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(searchExists).toBe(true)",
            "expect(searchContent).toContain(test)",
            "expect(searchContent).toContain(buscar empresa)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve retornar caminho do diret칩rio E2E",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.e2e_dir).toContain(e2e)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve configurar reporters no playwright.config.ts",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(configContent).toContain(reporter)",
            "expect(configContent).toContain(html)",
            "expect(configContent).toContain(junit)",
            "expect(configContent).toContain(json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve configurar retry e timeout no playwright.config.ts",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(configContent).toContain(retries)",
            "expect(configContent).toContain(timeout)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold.test.ts",
          "title": "deve configurar trace e screenshot no playwright.config.ts",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(configContent).toContain(trace)",
            "expect(configContent).toContain(screenshot)",
            "expect(configContent).toContain(video)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "scaffoldUnitTests",
      "filePath": "src/tools/scaffold-unit.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Vitest",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Jest",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Mocha",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(mocha)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve gerar testes para m칰ltiplos arquivos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve limitar a 20 arquivos por vez",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBeLessThanOrEqual(20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve atualizar package.json com scripts de teste",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(packageJson.scripts.test).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(packageJson.scripts.test).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve gerar guia de testes unit치rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(Unit Testing)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve lidar com erro quando arquivo fonte n칚o existe",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve auto-detectar arquivos quando n칚o especificados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve recomendar quais arquivos testar primeiro",
          "asserts": [
            "expect(recommendation.ok).toBe(true)",
            "expect(recommendation.recommendation).toBeDefined",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(parserFile.priority).toBe(HIGH)",
            "expect(parserFile.reason).toContain(parsing)",
            "expect(parserFile.reason).toContain(complexa)",
            "expect(configFile.priority).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(recommendation.recommendation).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "\\\\n",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes para arquivos de alta prioridade",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.generated).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(scaffoldResult.framework).toBe(vitest)",
            "expect(testExists).toBe(true)",
            "expect(testContent).toContain(describe)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(it)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(expect)",
            "expect(testContent).toContain(vitest)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toContain(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldResult.generated).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes com framework recomendado",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testContent).toContain(jest)",
            "expect(testContent).toContain(describe)",
            "expect(packageJson.scripts.test).toContain(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  5 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "scaffoldPropertyTests",
      "filePath": "src/tools/scaffold-property-tests.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "scaffoldIntegrationTests",
      "filePath": "src/tools/scaffold-integration.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-integration.test.ts",
          "title": "deve lidar com base_url inv치lida",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-integration.test.ts",
          "title": "deve lidar com endpoints vazios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "cleanDatabase",
      "filePath": "src/tools/scaffold-integration.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "seedDatabase",
      "filePath": "src/tools/scaffold-integration.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "createTestUser",
      "filePath": "src/tools/scaffold-integration.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "setupServer",
      "filePath": "src/tools/scaffold-integration.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "stopServer",
      "filePath": "src/tools/scaffold-integration.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "cleanDatabase",
      "filePath": "src/tools/scaffold-integration.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "scaffoldContractsPact",
      "filePath": "src/tools/scaffold-contracts-pact.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[1/4] scaffold_contracts_pact - deve detectar servi칞os e gerar contratos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.message).toContain(Generated)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.timestamp).toBeDefined",
            "expect(catalog.product).toBe(test-cdc-app)",
            "expect(catalog.services).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.services.length).toBeGreaterThan(0)",
            "expect(catalog.potential_contracts).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.coverage).toBeDefined",
            "expect(catalog.coverage.total_integrations).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(configContent).toContain(pactConfig)",
            "expect(configContent).toContain(test-cdc-app)",
            "expect(configContent).toContain(consumer)",
            "expect(configContent).toContain(provider)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(consumer)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(interaction)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(verify)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.services).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.potential_contracts).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.coverage).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[2/4] scaffold_contracts_pact - deve detectar m칰ltiplas APIs corretamente",
          "asserts": [
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(service.endpoints).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(service.endpoints.?).toHaveProperty(method)",
            "expect(service.endpoints.?).toHaveProperty(path)",
            "expect(contract).toHaveProperty(consumer)",
            "expect(contract).toHaveProperty(provider)",
            "expect(contract).toHaveProperty(priority)",
            "expect(unknown).toContain",
            "expect(contract.estimated_interactions).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(service.endpoints).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[3/4] run_contracts_verify - deve verificar contratos gerados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.verified).toBeGreaterThanOrEqual(0)",
            "expect(result.failed).toBeGreaterThanOrEqual(0)",
            "expect(result.report_path).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(report.timestamp).toBeDefined",
            "expect(report.product).toBe(testProduct)",
            "expect(report.language).toBe(typescript)",
            "expect(report.total_contracts).toBeGreaterThan(0)",
            "expect(report.total_interactions).toBeGreaterThan(0)",
            "expect(report.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(report.results).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(report.duration_total_ms).toBeGreaterThan(0)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)",
            "expect(mdContent).toContain(Verification Rate)",
            "expect(mdContent).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico",
            "expect(report.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(report.results).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[4/4] FULL PIPELINE - scaffold + verify funcionam em sequ칡ncia",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.total_contracts).toBeGreaterThan(0)",
            "expect(configContent).toContain(pact-broker.example.com)",
            "expect(verifyResult.ok).toBe(true)",
            "expect(verifyResult.total_interactions).toBe(6)",
            "expect(verifyResult.verification_rate).toBeGreaterThan(0)",
            "expect(report.total_contracts).toBe(3)",
            "expect(report.total_interactions).toBe(6)",
            "expect(report.verified).toBeGreaterThanOrEqual(0)",
            "expect(report.failed).toBeGreaterThanOrEqual(0)",
            "expect(unknown).toBe(6)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  22 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "scaffoldApprovalTests",
      "filePath": "src/tools/scaffold-approval-tests.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "runPlaywright",
      "filePath": "src/tools/run.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "close",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve executar testes Playwright com todas as op칞칫es",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reports).toBeDefined",
            "expect(result.reports.html).toContain(reports/html)",
            "expect(result.reports.json).toContain(reports/json)",
            "expect(result.reports.junit).toContain(reports/junit)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reports).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve configurar vari치veis de ambiente",
          "asserts": [
            "expect(capturedEnv.E2E_BASE_URL).toBe(https://test.com)",
            "expect(capturedEnv.E2E_USER).toBe(testuser)",
            "expect(capturedEnv.E2E_PASS).toBe(testpass)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve usar valores padr칚o para env quando n칚o especificados",
          "asserts": [
            "expect(capturedEnv.E2E_BASE_URL).toBeDefined",
            "expect(capturedEnv.E2E_USER).toBeDefined",
            "expect(capturedEnv.E2E_PASS).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(capturedEnv.E2E_BASE_URL).toBeDefined - verificar valor espec칤fico",
            "expect(capturedEnv.E2E_USER).toBeDefined - verificar valor espec칤fico",
            "expect(capturedEnv.E2E_PASS).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve configurar modo headless",
          "asserts": [
            "expect(capturedEnv.HEADLESS).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve configurar modo headed",
          "asserts": [
            "expect(capturedEnv.HEADLESS).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve retornar caminhos dos relat칩rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reports).toBeDefined",
            "expect(result.reports.html).toContain(reports/html)",
            "expect(result.reports.junit).toContain(reports/junit/results.xml)",
            "expect(result.reports.json).toContain(reports/json/results.json)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reports).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve lidar com erro ao instalar Playwright",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve lidar com erro ao executar testes",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  7 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "runMutationTests",
      "filePath": "src/tools/run-mutation-tests.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "runDiffCoverage",
      "filePath": "src/tools/run-diff-coverage.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve retornar 100% quando n칚o h치 mudan칞as",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.diffCoverage).toBe(100)",
            "expect(result.linesAdded).toBe(0)",
            "expect(result.files).toHaveLength(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve usar configura칞칚o do mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/diff-coverage-gate.spec.ts",
          "title": "deve ter a tool diff-coverage dispon칤vel",
          "asserts": [
            "expect(runDiffCoverage).toBeDefined",
            "expect(unknown).toBe(function)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(runDiffCoverage).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/diff-coverage-gate.spec.ts",
          "title": "deve exportar schema de par칙metros",
          "asserts": [
            "expect(module).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(module).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  3 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "parseJaCoCoXML",
      "filePath": "src/tools/run-coverage.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  21 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "parseGoCoverage",
      "filePath": "src/tools/run-coverage.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  21 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "parseSimpleCov",
      "filePath": "src/tools/run-coverage.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  21 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "parsePytestCoverage",
      "filePath": "src/tools/run-coverage.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  21 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "parseCoberturaXML",
      "filePath": "src/tools/run-coverage.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  21 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "parseCloverXML",
      "filePath": "src/tools/run-coverage.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  16 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "runCoverageAnalysis",
      "filePath": "src/tools/run-coverage.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  16 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "runContractsVerify",
      "filePath": "src/tools/run-contracts-verify.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[1/4] scaffold_contracts_pact - deve detectar servi칞os e gerar contratos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.message).toContain(Generated)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.timestamp).toBeDefined",
            "expect(catalog.product).toBe(test-cdc-app)",
            "expect(catalog.services).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.services.length).toBeGreaterThan(0)",
            "expect(catalog.potential_contracts).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.coverage).toBeDefined",
            "expect(catalog.coverage.total_integrations).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(configContent).toContain(pactConfig)",
            "expect(configContent).toContain(test-cdc-app)",
            "expect(configContent).toContain(consumer)",
            "expect(configContent).toContain(provider)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(consumer)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(interaction)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(verify)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.services).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.potential_contracts).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.coverage).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[2/4] scaffold_contracts_pact - deve detectar m칰ltiplas APIs corretamente",
          "asserts": [
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(service.endpoints).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(service.endpoints.?).toHaveProperty(method)",
            "expect(service.endpoints.?).toHaveProperty(path)",
            "expect(contract).toHaveProperty(consumer)",
            "expect(contract).toHaveProperty(provider)",
            "expect(contract).toHaveProperty(priority)",
            "expect(unknown).toContain",
            "expect(contract.estimated_interactions).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(service.endpoints).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[3/4] run_contracts_verify - deve verificar contratos gerados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.verified).toBeGreaterThanOrEqual(0)",
            "expect(result.failed).toBeGreaterThanOrEqual(0)",
            "expect(result.report_path).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(report.timestamp).toBeDefined",
            "expect(report.product).toBe(testProduct)",
            "expect(report.language).toBe(typescript)",
            "expect(report.total_contracts).toBeGreaterThan(0)",
            "expect(report.total_interactions).toBeGreaterThan(0)",
            "expect(report.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(report.results).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(report.duration_total_ms).toBeGreaterThan(0)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)",
            "expect(mdContent).toContain(Verification Rate)",
            "expect(mdContent).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico",
            "expect(report.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(report.results).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[4/4] FULL PIPELINE - scaffold + verify funcionam em sequ칡ncia",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.total_contracts).toBeGreaterThan(0)",
            "expect(configContent).toContain(pact-broker.example.com)",
            "expect(verifyResult.ok).toBe(true)",
            "expect(verifyResult.total_interactions).toBe(6)",
            "expect(verifyResult.verification_rate).toBeGreaterThan(0)",
            "expect(report.total_contracts).toBe(3)",
            "expect(report.total_interactions).toBe(6)",
            "expect(report.verified).toBeGreaterThanOrEqual(0)",
            "expect(report.failed).toBeGreaterThanOrEqual(0)",
            "expect(unknown).toBe(6)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "丘멆잺  18 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "riskRegister",
      "filePath": "src/tools/risk-register.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[FULL PIPELINE] FASE 1 + FASE 2 completa",
          "asserts": [
            "expect(cujResult.ok).toBe(true)",
            "expect(slosResult.ok).toBe(true)",
            "expect(riskResult.ok).toBe(true)",
            "expect(portfolioResult.ok).toBe(true)",
            "expect(portfolioResult.output).toContain(PORTFOLIO-PLAN.md)",
            "expect(existsSync()).toBe(true)",
            "expect(portfolioResult.recommendations_count).toBeGreaterThanOrEqual(0)",
            "expect(reportContent).toContain(# Test Portfolio Plan)",
            "expect(reportContent).toContain(## 游늵 Current State)",
            "expect(reportContent).toContain(## 游꿢 Target Distribution)",
            "expect(reportContent).toContain(## 游꿢 Module Recommendations)",
            "expect(reportContent).toContain(## 九 Action Items)",
            "expect(reportContent).toContain(Fowler)",
            "expect(reportContent).toContain(70%)",
            "expect(reportContent).toContain(20%)",
            "expect(reportContent).toContain(10%)",
            "expect(reportContent).toContain(| Test Type | Count | Percentage | Target | Gap |)",
            "expect(reportContent).toContain(Unit)",
            "expect(reportContent).toContain(Integration)",
            "expect(reportContent).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[VALIDATION] Portfolio plan deve ter estrutura correta",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(content).toContain(section)",
            "expect(content).toMatch(/\\/\\\\/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[INTEGRATION] Recommendations devem estar baseadas em riscos",
          "asserts": [
            "expect(portfolioContent).toContain(游뚿 Top 5 Critical Risks)",
            "expect(portfolioContent).toContain(Module Recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[METRICS] Distribui칞칚o deve somar 100%",
          "asserts": [
            "expect(content).toContain(Current State)",
            "expect(total).toBeGreaterThanOrEqual(99.9)",
            "expect(total).toBeLessThanOrEqual(100.1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[1/3] catalog_cujs deve gerar cuj-catalog.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(cuj-catalog.json)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog).toHaveProperty(timestamp)",
            "expect(catalog).toHaveProperty(repo)",
            "expect(catalog).toHaveProperty(product)",
            "expect(catalog).toHaveProperty(cujs)",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.cujs.length).toBeGreaterThan(0)",
            "expect(firstCUJ).toHaveProperty(id)",
            "expect(firstCUJ).toHaveProperty(name)",
            "expect(firstCUJ).toHaveProperty(criticality)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[2/3] define_slos deve gerar slos.json baseado em CUJs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(slos.json)",
            "expect(existsSync()).toBe(true)",
            "expect(slos).toHaveProperty(timestamp)",
            "expect(slos).toHaveProperty(repo)",
            "expect(slos).toHaveProperty(product)",
            "expect(slos).toHaveProperty(slos)",
            "expect(slos).toHaveProperty(defaults_applied)",
            "expect(unknown).toBe(boolean)",
            "expect(firstSLO).toHaveProperty(cuj_id)",
            "expect(firstSLO).toHaveProperty(error_rate_max)",
            "expect(firstSLO).toHaveProperty(availability_min)",
            "expect(firstSLO.error_rate_max).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.error_rate_max).toBeLessThanOrEqual(1)",
            "expect(firstSLO.availability_min).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.availability_min).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[3/3] risk_register deve gerar risk-register.json cruzando CUJs + SLOs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_risks).toBeGreaterThan(0)",
            "expect(result.output).toContain(risk-register.json)",
            "expect(existsSync()).toBe(true)",
            "expect(riskReg).toHaveProperty(timestamp)",
            "expect(riskReg).toHaveProperty(repo)",
            "expect(riskReg).toHaveProperty(product)",
            "expect(riskReg).toHaveProperty(risks)",
            "expect(riskReg).toHaveProperty(top_5_critical)",
            "expect(riskReg).toHaveProperty(total_risk_score)",
            "expect(riskReg).toHaveProperty(coverage_gaps)",
            "expect(Array.isArray()).toBe(true)",
            "expect(riskReg.top_5_critical.length).toBeLessThanOrEqual(5)",
            "expect(unknown).toBe(string)",
            "expect(firstRisk).toHaveProperty(id)",
            "expect(firstRisk).toHaveProperty(cuj_id)",
            "expect(firstRisk).toHaveProperty(title)",
            "expect(firstRisk).toHaveProperty(description)",
            "expect(firstRisk).toHaveProperty(impact)",
            "expect(firstRisk).toHaveProperty(probability)",
            "expect(firstRisk).toHaveProperty(risk_score)",
            "expect(firstRisk).toHaveProperty(affected_modules)",
            "expect(firstRisk).toHaveProperty(mitigation_strategies)",
            "expect(firstRisk).toHaveProperty(recommended_tests)",
            "expect(firstRisk.risk_score).toBeGreaterThanOrEqual(0)",
            "expect(firstRisk.risk_score).toBeLessThanOrEqual(100)",
            "expect(unknown).toContain",
            "expect(unknown).toContain",
            "expect(validTests).toContain(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[FULL] Pipeline completo deve criar 3 arquivos consistentes",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.cujs.length).toBe",
            "expect(catalog.cujs.length).toBe",
            "expect(sloIds.has()).toBe(true)",
            "expect(r.id).toBe",
            "expect(cujIds.has()).toBe(true)",
            "expect(riskIds.has()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "buildReport",
      "filePath": "src/tools/report.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve ler JSON do Playwright e gerar relat칩rio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.out).toBe",
            "expect(content).toContain(QA Report)",
            "expect(content).toContain(| **Passou** | 45 (90.00%) |)",
            "expect(content).toContain(| **Falhou** | 3 |)",
            "expect(content).toContain(| **Flaky** | 2 (4.00%) 仇 |)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve incluir artefatos no relat칩rio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Artefatos)",
            "expect(content).toContain(html/index.html)",
            "expect(content).toContain(junit/results.xml)",
            "expect(content).toContain(json/results.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve adicionar recomenda칞칫es ao relat칩rio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Pr칩ximas A칞칫es)",
            "expect(content).toContain(flaky)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve verificar thresholds de flaky",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(仇 Resolver testes flaky (meta: 곣 3%))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve verificar thresholds de diff-coverage",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(N/A*)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve lidar com arquivo JSON inexistente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(0 (0.00%))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve calcular dura칞칚o em segundos corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(125s)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/report.test.ts",
          "title": "deve usar thresholds padr칚o quando n칚o especificados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(九 Resolver testes flaky (meta: 곣 3%))",
            "expect(content).toContain(N/A*)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "releaseQualityGate",
      "filePath": "src/tools/release-quality-gate.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/release-quality-gate.test.ts",
          "title": "deve retornar exit_code=0 quando todos os gates passam",
          "asserts": [
            "expect(result.exit_code).toBe(0)",
            "expect(result.summary.blocking_violations).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "recommendTestStrategy",
      "filePath": "src/tools/recommend-strategy.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar isCLI=true se tem commander",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(CLI)",
            "expect(unknown).toContain(90)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar isMCPServer=true se tem @modelcontextprotocol/sdk",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(MCP)",
            "expect(unknown).toContain(90)",
            "expect(unknown).toContain(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar hasWebUI=true se tem react/next",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(Web)",
            "expect(e2ePct).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve calcular complexity baseado em features",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve recomendar 90% unit para CLI tools",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(90)",
            "expect(unknown).toContain(10)",
            "expect(unknown).toContain(0)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve recomendar 60/25/15 para web apps complexos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBe(high)",
            "expect(unitPct).toBeGreaterThanOrEqual(50)",
            "expect(unitPct).toBeLessThanOrEqual(70)",
            "expect(integrationPct).toBeGreaterThanOrEqual(20)",
            "expect(e2ePct).toBeGreaterThanOrEqual(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar se documento j치 existe",
          "asserts": [
            "expect(result1.ok).toBe(true)",
            "expect(result1.file).toBeDefined",
            "expect(result2.ok).toBe(true)",
            "expect(result2.exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result1.file).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve identificar arquivos priorit치rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(parserFile.priority).toBe(HIGH)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve recomendar quais arquivos testar primeiro",
          "asserts": [
            "expect(recommendation.ok).toBe(true)",
            "expect(recommendation.recommendation).toBeDefined",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(parserFile.priority).toBe(HIGH)",
            "expect(parserFile.reason).toContain(parsing)",
            "expect(parserFile.reason).toContain(complexa)",
            "expect(configFile.priority).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(recommendation.recommendation).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "\\\\n",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes para arquivos de alta prioridade",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.generated).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(scaffoldResult.framework).toBe(vitest)",
            "expect(testExists).toBe(true)",
            "expect(testContent).toContain(describe)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(it)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(expect)",
            "expect(testContent).toContain(vitest)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toContain(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldResult.generated).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes com framework recomendado",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testContent).toContain(jest)",
            "expect(testContent).toContain(describe)",
            "expect(packageJson.scripts.test).toContain(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  7 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "generatePyramidReport",
      "filePath": "src/tools/pyramid-report.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve gerar relat칩rio HTML da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.report_path).toContain(.html)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve gerar relat칩rio Markdown da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.report_path).toContain(.md)",
            "expect(content).toContain(Pir칙mide de Testes)",
            "expect(content).toContain(Unit)",
            "expect(content).toContain(Integration)",
            "expect(content).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve incluir visualiza칞칚o gr치fica no HTML",
          "asserts": [
            "expect(isHTML).toBe(true)",
            "expect(content).toContain(TestProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve incluir status de sa칰de no relat칩rio",
          "asserts": [
            "expect(hasHealth).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/pyramid-report.test.ts",
          "title": "deve lidar com aus칡ncia de coverage-analysis.json",
          "asserts": [
            "expect(error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas na cobertura atual",
          "asserts": [
            "expect(coverage.summary).toContain(Status:)",
            "expect(coverage.summary).toContain(Pir칙mide)",
            "expect(coverage.pyramid.unit.files_found).toBeGreaterThanOrEqual(0)",
            "expect(coverage.pyramid.e2e.files_found).toBeGreaterThanOrEqual(0)",
            "expect(coverage.health).toBe(inverted)",
            "expect(coverage.recommendations.length).toBeGreaterThan(0)",
            "expect(hasUnitRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve usar coverage analysis para gerar relat칩rio visual",
          "asserts": [
            "expect(coverage.health).toBe(healthy)",
            "expect(pyramidReport.ok).toBe(true)",
            "expect(pyramidReport.report_path).toMatch(/PYRAMID-REPORT\\.(html|md)$/)",
            "expect(htmlExists).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(htmlContent.length).toBeGreaterThan(500)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas em gaps",
          "asserts": [
            "expect(coverage.pyramid.unit.files_found).toBe(0)",
            "expect(coverage.pyramid.unit.missing_tests.length).toBeGreaterThan(0)",
            "expect(coverage.recommendations.length).toBeGreaterThan(0)",
            "expect(report.ok).toBe(true)",
            "expect(mdContent.length).toBeGreaterThan(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  1 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "prodMetricsIngest",
      "filePath": "src/tools/prod-metrics-ingest.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve coletar m칠tricas e calcular DORA",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.dora_metrics).toBeDefined",
            "expect(result.dora_metrics.deployment_frequency).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.change_failure_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.mttr_minutes).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics.dora_tier).toMatch(/Elite|High|Medium|Low/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.dora_metrics).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve calcular DORA tier corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/prod-metrics-ingest.test.ts",
          "title": "deve usar mock data quando credenciais n칚o fornecidas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.releases.length).toBeGreaterThanOrEqual(0)",
            "expect(result.dora_metrics).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.dora_metrics).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "portfolioPlan",
      "filePath": "src/tools/portfolio-plan.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[FULL PIPELINE] FASE 1 + FASE 2 completa",
          "asserts": [
            "expect(cujResult.ok).toBe(true)",
            "expect(slosResult.ok).toBe(true)",
            "expect(riskResult.ok).toBe(true)",
            "expect(portfolioResult.ok).toBe(true)",
            "expect(portfolioResult.output).toContain(PORTFOLIO-PLAN.md)",
            "expect(existsSync()).toBe(true)",
            "expect(portfolioResult.recommendations_count).toBeGreaterThanOrEqual(0)",
            "expect(reportContent).toContain(# Test Portfolio Plan)",
            "expect(reportContent).toContain(## 游늵 Current State)",
            "expect(reportContent).toContain(## 游꿢 Target Distribution)",
            "expect(reportContent).toContain(## 游꿢 Module Recommendations)",
            "expect(reportContent).toContain(## 九 Action Items)",
            "expect(reportContent).toContain(Fowler)",
            "expect(reportContent).toContain(70%)",
            "expect(reportContent).toContain(20%)",
            "expect(reportContent).toContain(10%)",
            "expect(reportContent).toContain(| Test Type | Count | Percentage | Target | Gap |)",
            "expect(reportContent).toContain(Unit)",
            "expect(reportContent).toContain(Integration)",
            "expect(reportContent).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[VALIDATION] Portfolio plan deve ter estrutura correta",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(content).toContain(section)",
            "expect(content).toMatch(/\\/\\\\/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[INTEGRATION] Recommendations devem estar baseadas em riscos",
          "asserts": [
            "expect(portfolioContent).toContain(游뚿 Top 5 Critical Risks)",
            "expect(portfolioContent).toContain(Module Recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[METRICS] Distribui칞칚o deve somar 100%",
          "asserts": [
            "expect(content).toContain(Current State)",
            "expect(total).toBeGreaterThanOrEqual(99.9)",
            "expect(total).toBeLessThanOrEqual(100.1)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "generatePlan",
      "filePath": "src/tools/plan.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve gerar plano de testes b치sico",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.plan).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve criar arquivo TEST-PLAN.md",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(TestProduct2)",
            "expect(content).toContain(Plano de Testes)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir exemplos quando solicitado",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve usar configura칞칚o de mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve organizar por dom칤nios quando fornecidos",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve validar par칙metros obrigat칩rios",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir TODOs autom치ticos no plano",
          "asserts": [
            "expect(content).toContain(游꿢 A칞칫es Recomendadas)",
            "expect(content).toContain(TODO: Create auth fixtures)",
            "expect(content).toContain(TODO: Consider Testcontainers)",
            "expect(content).toContain(TODO: Configure CI/CD pipeline)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir Quality Gates com thresholds",
          "asserts": [
            "expect(content).toContain(Quality Gates)",
            "expect(content).toContain(Required Coverage)",
            "expect(content).toContain(Performance)",
            "expect(content).toContain(Blocking Criteria)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve calcular risk scores quando houver dados de an치lise",
          "asserts": [
            "expect(content).toContain(游댠 Risk Score Analysis)",
            "expect(content).toMatch(/Score:/)",
            "expect(content).toMatch(/Probability:/)",
            "expect(content).toMatch(/Impact:/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve gerar plano baseado nos findings da an치lise",
          "asserts": [
            "expect(analysis.findings.routes).toContain(/login)",
            "expect(analysis.findings.endpoints.length).toBeGreaterThan(0)",
            "expect(plan.ok).toBe(true)",
            "expect(plan.plan).toBeDefined",
            "expect(planExists).toBe(true)",
            "expect(planContent).toContain(Test App)",
            "expect(planContent).toContain(Playwright)",
            "expect(planContent).toContain(playwright.config.ts)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(plan.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve incluir recomenda칞칫es da an치lise no plano",
          "asserts": [
            "expect(analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(plan.ok).toBe(true)",
            "expect(planContent).toContain(Cen치rios)",
            "expect(planContent).toContain(Risco)",
            "expect(planContent).toContain(Playwright)",
            "expect(planContent).toContain(Exemplo)",
            "expect(planContent).toContain(example)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve organizar plano por dom칤nios quando especificados",
          "asserts": [
            "expect(plan.ok).toBe(true)",
            "expect(planContent.length).toBeGreaterThan(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should get users",
          "asserts": [
            "expect(getUsers).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(getUsers).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve executar analyze e detectar endpoints",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve criar analyze.json com findings",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(findings)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve permitir pipeline completo: analyze  coverage  plan",
          "asserts": [
            "expect(analyzeResult.findings).toBeDefined",
            "expect(coverageResult.pyramid).toBeDefined",
            "expect(planResult.plan).toBeDefined",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeResult.findings).toBeDefined - verificar valor espec칤fico",
            "expect(coverageResult.pyramid).toBeDefined - verificar valor espec칤fico",
            "expect(planResult.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve usar configura칞칚o centralizada de mcp-settings.json",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve validar health da pir칙mide corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "丘멆잺  11 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "detectMode",
      "filePath": "src/tools/nl-command.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should default to FULL mode for unrecognized queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.repo).toBe(/home/user/project)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract product override",
          "asserts": [
            "expect(result.product).toBe(MyApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.repo).toBe(/tmp/test)",
            "expect(result.product).toBe(Portal)",
            "expect(result.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return empty object for no overrides",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should execute with detected mode from query",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should merge extracted overrides with detected mode",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.extracted_params).toEqual({...})",
            "expect(result.final_params).toMatchObject({...})",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should apply defaults and override with extracted params",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should prioritize explicit mode override over detected mode",
          "asserts": [
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(analyze)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.success).toBe(false)",
            "expect(result.error).toBe(Test error)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return true on success",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return false on error",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "extractOverrides",
      "filePath": "src/tools/nl-command.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should default to FULL mode for unrecognized queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.repo).toBe(/home/user/project)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract product override",
          "asserts": [
            "expect(result.product).toBe(MyApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.repo).toBe(/tmp/test)",
            "expect(result.product).toBe(Portal)",
            "expect(result.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return empty object for no overrides",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should execute with detected mode from query",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should merge extracted overrides with detected mode",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.extracted_params).toEqual({...})",
            "expect(result.final_params).toMatchObject({...})",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should apply defaults and override with extracted params",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should prioritize explicit mode override over detected mode",
          "asserts": [
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(analyze)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.success).toBe(false)",
            "expect(result.error).toBe(Test error)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return true on success",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return false on error",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "nlCommand",
      "filePath": "src/tools/nl-command.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should default to FULL mode for unrecognized queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.repo).toBe(/home/user/project)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract product override",
          "asserts": [
            "expect(result.product).toBe(MyApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.repo).toBe(/tmp/test)",
            "expect(result.product).toBe(Portal)",
            "expect(result.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return empty object for no overrides",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should execute with detected mode from query",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should merge extracted overrides with detected mode",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.extracted_params).toEqual({...})",
            "expect(result.final_params).toMatchObject({...})",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should apply defaults and override with extracted params",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should prioritize explicit mode override over detected mode",
          "asserts": [
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(analyze)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.success).toBe(false)",
            "expect(result.error).toBe(Test error)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return true on success",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return false on error",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.final_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(result.final_params.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect RUN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.final_params.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.extracted_params.product).toBe(TestApp)",
            "expect(result.extracted_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should apply defaults when no override present",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.repo).toBe(tempDir)",
            "expect(result.final_params.product).toBe(DefaultProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should prioritize explicit overrides over defaults",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.product).toBe(ExplicitProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle empty query gracefully",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle query with only whitespace",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  4 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "runNLCommand",
      "filePath": "src/tools/nl-command.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should default to FULL mode for unrecognized queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.repo).toBe(/home/user/project)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract product override",
          "asserts": [
            "expect(result.product).toBe(MyApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.repo).toBe(/tmp/test)",
            "expect(result.product).toBe(Portal)",
            "expect(result.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return empty object for no overrides",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should execute with detected mode from query",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should merge extracted overrides with detected mode",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.extracted_params).toEqual({...})",
            "expect(result.final_params).toMatchObject({...})",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should apply defaults and override with extracted params",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should prioritize explicit mode override over detected mode",
          "asserts": [
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(analyze)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.success).toBe(false)",
            "expect(result.error).toBe(Test error)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return true on success",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return false on error",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "initProduct",
      "filePath": "src/tools/init-product.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar estrutura completa de QA para produto",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.path).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar diret칩rios de testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar mcp-settings.json com configura칞칫es corretas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(settings.product).toBe(TestProduct)",
            "expect(settings.base_url).toBe(https://www.example.com)",
            "expect(settings.domains).toEqual([...])",
            "expect(settings.critical_flows).toEqual([...])",
            "expect(settings.targets).toBeDefined",
            "expect(settings.targets.diff_coverage_min).toBe(80)",
            "expect(settings.targets.flaky_pct_max).toBe(5)",
            "expect(settings.targets.ci_p95_min).toBe(8)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(settings.targets).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar GETTING_STARTED.md",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(TestProduct)",
            "expect(content).toContain(https://www.example.com)",
            "expect(content).toContain(Responsabilidades)",
            "expect(content).toContain(Quality Gates)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar README.md",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(TestProduct)",
            "expect(content).toContain(Quick Start)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar .gitignore apropriado",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(content).toContain(storageState.json)",
            "expect(content).toContain(*.bak)",
            "expect(content).toContain(node_modules)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "n칚o deve sobrescrever mcp-settings.json existente",
          "asserts": [
            "expect(finalSettings.custom_field).toBe(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/init-product.test.ts",
          "title": "deve criar environments corretos baseado na base_url",
          "asserts": [
            "expect(settings.environments).toBeDefined",
            "expect(settings.environments.dev.url).toBe(https://dev.example.com)",
            "expect(settings.environments.stg.url).toBe(https://stg.example.com)",
            "expect(settings.environments.prod.url).toBe(https://www.example.com)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(settings.environments).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar estrutura completa de QA",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.path).toContain(EcommerceApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar mcp-settings.json com configura칞칫es corretas",
          "asserts": [
            "expect(settings).toMatchObject({...})",
            "expect(settings.environments).toHaveProperty(dev)",
            "expect(settings.environments).toHaveProperty(stg)",
            "expect(settings.environments).toHaveProperty(prod)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar estrutura de diret칩rios completa",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar GETTING_STARTED.md com documenta칞칚o",
          "asserts": [
            "expect(content).toContain(EcommerceApp)",
            "expect(content).toContain(Quality MCP)",
            "expect(content).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar README.md",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar .gitignore apropriado",
          "asserts": [
            "expect(content).toContain(node_modules/)",
            "expect(content).toContain(coverage/)",
            "expect(content).toContain(playwright-report/)",
            "expect(content).toContain(.env)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "n칚o deve sobrescrever mcp-settings.json existente",
          "asserts": [
            "expect(newSettings.custom_field).toBe(should_persist)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve permitir criar m칰ltiplos produtos no mesmo repo",
          "asserts": [
            "expect(ecommerceExists).toBe(true)",
            "expect(paymentExists).toBe(true)",
            "expect(ecommerceSettings.product).toBe(EcommerceApp)",
            "expect(ecommerceSettings.base_url).toBe(https://www.ecommerce.com)",
            "expect(paymentSettings.product).toBe(PaymentService)",
            "expect(paymentSettings.base_url).toBe(https://api.payment.com)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should get users",
          "asserts": [
            "expect(getUsers).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(getUsers).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve executar analyze e detectar endpoints",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve criar analyze.json com findings",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(findings)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve permitir pipeline completo: analyze  coverage  plan",
          "asserts": [
            "expect(analyzeResult.findings).toBeDefined",
            "expect(coverageResult.pyramid).toBeDefined",
            "expect(planResult.plan).toBeDefined",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeResult.findings).toBeDefined - verificar valor espec칤fico",
            "expect(coverageResult.pyramid).toBeDefined - verificar valor espec칤fico",
            "expect(planResult.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve usar configura칞칚o centralizada de mcp-settings.json",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve validar health da pir칙mide corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  8 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "explainTests",
      "filePath": "src/tools/explain-tests.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve retornar estrutura b치sica mesmo sem testes",
          "asserts": [
            "expect(result).toHaveProperty(ok)",
            "expect(result).toHaveProperty(explanations)",
            "expect(result).toHaveProperty(metrics)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve gerar m칠tricas corretas para testes vazios",
          "asserts": [
            "expect(result.metrics.totalTests).toBe(0)",
            "expect(result.metrics.assertStrongPct).toBe(0)",
            "expect(result.metrics.assertMediumPct).toBe(0)",
            "expect(result.metrics.assertWeakPct).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve falhar quando failOn=",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result).toHaveProperty(explanations)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve gerar outputs JSON e MD conforme solicitado",
          "asserts": [
            "expect(result.outputPaths).toHaveProperty(explanationsJson)",
            "expect(result.outputPaths).toHaveProperty(explanationsMd)",
            "expect(result.outputPaths).toHaveProperty(qualitySummaryMd)",
            "expect(result.outputPaths).toHaveProperty(metricsJson)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/explain-tests.test.ts",
          "title": "deve calcular KR3a status corretamente",
          "asserts": [
            "expect(result.kr3aStatus).toMatch(/OK|ATEN칂츾O|ALERTA/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "run",
      "filePath": "src/tools/explain-tests.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve validar par칙metros v치lidos",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve rejeitar sem repo",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve validar URL v치lida",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve rejeitar URL inv치lida",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve validar nome de produto alphanumeric",
          "asserts": [
            "expect(regex.test()).toBe(true)",
            "expect(regex.test()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "valid-product-123",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "invalid@product!",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve validar schema completo",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve ter todos os nomes de tools essenciais",
          "asserts": [
            "expect(toolNames).toHaveLength(16)",
            "expect(toolNames).toContain(nl_command)",
            "expect(toolNames).toContain(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear dom칤nios separados por v칤rgula",
          "asserts": [
            "expect(domains).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear critical flows separados por v칤rgula",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear JSON de targets",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o se n칚o especificado",
          "asserts": [
            "expect(defaultOut).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve aceitar include-examples como boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(packages/product-e2e)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve converter --headed para headless=false",
          "asserts": [
            "expect(headless).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar headless=true por padr칚o",
          "asserts": [
            "expect(headless).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de relat칩rios padr칚o",
          "asserts": [
            "expect(defaultReport).toBe(reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar arquivo de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(SUMMARY.md)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de arquivos",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de endpoints",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de squads",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear thresholds JSON",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar URL base",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar URL inv치lida",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar nome de produto alphanumeric",
          "asserts": [
            "expect(regex.test()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar nome de produto com caracteres especiais",
          "asserts": [
            "expect(regex.test()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato markdown",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato html",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato json",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar formato inv치lido",
          "asserts": [
            "expect(['markdown', 'html', 'json']).not.toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar jest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar vitest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar mocha",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter todos os comandos esperados registrados na CLI",
          "asserts": [
            "expect(helpOutput).toContain(command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter descri칞칫es para todos os comandos",
          "asserts": [
            "expect(helpOutput).toContain",
            "expect(helpOutput).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar que comandos espec칤ficos aceitam par칙metros obrigat칩rios",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)",
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar comandos inexistentes com mensagem clara",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(output).toMatch(/unknown command|error/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve garantir que scripts npm correspondam aos comandos CLI",
          "asserts": [
            "expect(packageJson.scripts).toHaveProperty(scriptName)",
            "expect(packageJson.scripts.scriptName).toContain(cliCommand)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-run deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--fix deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-scaffold deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(opts.skipScaffold).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--repo deve rejeitar se n칚o tiver valor",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--product deve aceitar valor",
          "asserts": [
            "expect(opts.product).toBe(my-product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "analyze --repo . --product ",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.product).toBe(mcp)",
            "expect(opts.mode).toBe(analyze)",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "self-check --repo . --fix",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.minMutation).toBe(60)",
            "expect(opts.minBranch).toBe(70)",
            "expect(opts.failFast).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "Boolean defaultValue = flag sem <value>",
          "asserts": [
            "expect(booleanFlags.length).toBeGreaterThanOrEqual(2)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "String/Number defaultValue = flag com <value>",
          "asserts": [
            "expect(valueFlags.length).toBeGreaterThanOrEqual(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve detectar adapter baseado no m칠todo detect",
          "asserts": [
            "expect(result).toBe(mockAdapter2)",
            "expect(unknown).toBe(typescript)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve retornar null se nenhum adapter detectar",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve lan칞ar erro se linguagem n칚o detectada",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.errors.length).toBeGreaterThan(0)",
            "expect(result.errors.?).toContain(n칚o detectada)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar pipeline com adapter v치lido (stub)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.execution.stepsExecuted).toContain(functions)",
            "expect(result.execution.stepsExecuted).toContain(tests)",
            "expect(result.execution.stepsExecuted).toContain(cases)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve pular mutation em perfil ci-fast",
          "asserts": [
            "expect(result.execution.stepsSkipped).toContain(mutation)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar mutation em perfil ci-strict",
          "asserts": [
            "expect(result.execution.stepsExecuted).toContain(mutation)",
            "expect(mockAdapter.capabilities.mutation).toHaveBeenCalled",
            "expect(result.report.metrics.mutationScore).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve calcular quality score corretamente",
          "asserts": [
            "expect(result.report.metrics.qualityScore).toBeGreaterThan(0)",
            "expect(result.report.metrics.grade).toMatch(/[ABCDF]/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar producer.send() com t칩picos Kafka",
          "asserts": [
            "expect(events).toContain(kafka:user-created)",
            "expect(events).toContain(kafka:order-placed)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar consumer.subscribe() e consumer.run()",
          "asserts": [
            "expect(events).toContain(kafka:payment-processed)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar sqs.sendMessage() com queue URL",
          "asserts": [
            "expect(events).toContain(aws:my-queue)",
            "expect(events).toContain(aws:notifications)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar emit() com event names",
          "asserts": [
            "expect(events).toContain(event:user:login)",
            "expect(events).toContain(event:user:logout)",
            "expect(events).toContain(event:data:updated)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "user:login",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "user:logout",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "data:updated",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve retornar array vazio se n칚o houver eventos",
          "asserts": [
            "expect(events).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve consolidar todos os eventos encontrados",
          "asserts": [
            "expect(events).toHaveLength(3)",
            "expect(events).toContain(kafka:topic-1)",
            "expect(events).toContain(aws:queue-1)",
            "expect(events).toContain(event:event-1)",
            "expect(events).toEqual"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "event-1",
          "asserts": [
            "expect(events.filter()).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve remover eventos duplicados",
          "asserts": [
            "expect(events.filter()).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar SNS subscribe com TopicArn",
          "asserts": [
            "expect(events).toContain(aws:my-topic)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar eventos com aspas simples, duplas e template literals",
          "asserts": [
            "expect(events).toContain(event:single-quote)",
            "expect(events).toContain(event:double-quote)",
            "expect(events).toContain(event:template-literal)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "single-quote",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "double-quote",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve PASSAR quando mutation score >= threshold",
          "asserts": [
            "expect(result.passed).toBe(true)",
            "expect(result.violations).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve FALHAR quando mutation score < threshold",
          "asserts": [
            "expect(result.passed).toBe(false)",
            "expect(result.violations).toHaveLength(1)",
            "expect(result.violations.?.gate).toBe(Mutation Score)",
            "expect(result.violations.?.threshold).toBe(70)",
            "expect(result.violations.?.actual).toBe(40)",
            "expect(result.violations.?.suggestions).toContain(游늵 Mutation Score: 40% (threshold: 70%))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve retornar sugest칫es de corre칞칚o para mutantes sobreviventes",
          "asserts": [
            "expect(result.passed).toBe(false)",
            "expect(result.violations.?.suggestions).toEqual"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve FALHAR quando relat칩rio de muta칞칚o n칚o existe",
          "asserts": [
            "expect(result.passed).toBe(false)",
            "expect(result.violations).toHaveLength(1)",
            "expect(result.violations.?.message).toContain(Nenhum relat칩rio de muta칞칚o encontrado)",
            "expect(result.violations.?.suggestions).toContain(1. Instale Stryker: npm install --save-dev @stryker-mutator/core @stryker-mutator/vitest-runner)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve lidar com relat칩rio JSON malformado",
          "asserts": [
            "expect(result.passed).toBe(false)",
            "expect(result.violations).toHaveLength(1)",
            "expect(result.violations[0].message).toContain('Erro ao ler relat칩rio de muta칞칚o')",
            "expect(result.passed).toBe(true)",
            "expect(result.violations).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/validate.test.ts",
          "title": "deve ignorar minMutation se n칚o fornecido",
          "asserts": [
            "expect(result.passed).toBe(true)",
            "expect(result.violations).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve medir sa칰de b치sica da su칤te",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_runtime_sec).toBeGreaterThanOrEqual(0)",
            "expect(result.flaky_tests_count).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve calcular instability index",
          "asserts": [
            "expect(result.instability_index).toBeDefined",
            "expect(unknown).toBe(number)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.instability_index).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve gerar recomenda칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve salvar relat칩rio em JSON",
          "asserts": [
            "expect(result.output).toContain(suite-health.json)",
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(timestamp)",
            "expect(content).toHaveProperty(total_runtime_sec)",
            "expect(content).toHaveProperty(instability_index)",
            "expect(content).toHaveProperty(recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "close",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve executar testes Playwright com todas as op칞칫es",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reports).toBeDefined",
            "expect(result.reports.html).toContain(reports/html)",
            "expect(result.reports.json).toContain(reports/json)",
            "expect(result.reports.junit).toContain(reports/junit)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reports).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve configurar vari치veis de ambiente",
          "asserts": [
            "expect(capturedEnv.E2E_BASE_URL).toBe(https://test.com)",
            "expect(capturedEnv.E2E_USER).toBe(testuser)",
            "expect(capturedEnv.E2E_PASS).toBe(testpass)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve usar valores padr칚o para env quando n칚o especificados",
          "asserts": [
            "expect(capturedEnv.E2E_BASE_URL).toBeDefined",
            "expect(capturedEnv.E2E_USER).toBeDefined",
            "expect(capturedEnv.E2E_PASS).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(capturedEnv.E2E_BASE_URL).toBeDefined - verificar valor espec칤fico",
            "expect(capturedEnv.E2E_USER).toBeDefined - verificar valor espec칤fico",
            "expect(capturedEnv.E2E_PASS).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve configurar modo headless",
          "asserts": [
            "expect(capturedEnv.HEADLESS).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve configurar modo headed",
          "asserts": [
            "expect(capturedEnv.HEADLESS).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve retornar caminhos dos relat칩rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reports).toBeDefined",
            "expect(result.reports.html).toContain(reports/html)",
            "expect(result.reports.junit).toContain(reports/junit/results.xml)",
            "expect(result.reports.json).toContain(reports/json/results.json)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reports).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve lidar com erro ao instalar Playwright",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run.test.ts",
          "title": "deve lidar com erro ao executar testes",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve retornar 100% quando n칚o h치 mudan칞as",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.diffCoverage).toBe(100)",
            "expect(result.linesAdded).toBe(0)",
            "expect(result.files).toHaveLength(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve usar configura칞칚o do mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should default to FULL mode for unrecognized queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.repo).toBe(/home/user/project)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract product override",
          "asserts": [
            "expect(result.product).toBe(MyApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.repo).toBe(/tmp/test)",
            "expect(result.product).toBe(Portal)",
            "expect(result.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return empty object for no overrides",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should execute with detected mode from query",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should merge extracted overrides with detected mode",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.extracted_params).toEqual({...})",
            "expect(result.final_params).toMatchObject({...})",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should apply defaults and override with extracted params",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should prioritize explicit mode override over detected mode",
          "asserts": [
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(analyze)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.success).toBe(false)",
            "expect(result.error).toBe(Test error)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return true on success",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return false on error",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should analyze TypeScript project with basic tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(Vitest)",
            "expect(result.functions.length).toBeGreaterThan(0)",
            "expect(addFunc).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(addFunc).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should add positive numbers",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle zero",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should multiply numbers",
          "asserts": [
            "expect(multiply()).toBe(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect framework automatically",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate scenario coverage correctly",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should validate correct email",
          "asserts": [
            "expect(validateEmail()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should reject invalid email",
          "asserts": [
            "expect(validateEmail()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should throw on empty email",
          "asserts": [
            "expect(unknown).toThrow(Email required)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty repository",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])",
            "expect(result.metrics.qualityScore).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle repository without tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toEqual([...])",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle functions with weak assertions",
          "asserts": [
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should return user",
          "asserts": [
            "expect(user).toBeTruthy",
            "expect(user).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(user).toBeTruthy - usar compara칞칚o expl칤cita",
            "expect(user).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle null/undefined inputs gracefully",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle very large codebase efficiently",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBeGreaterThanOrEqual(10)",
            "expect(duration).toBeLessThan(10000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle invalid repository path",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed source files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')",
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined()",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain('TEST-QUALITY-LOGICAL-REPORT.md')",
            "expect(result.reportPath).toContain(testDir)",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(hasLogicLogs).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('python')",
            "expect(result.framework).toBe('Pytest')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('go')",
            "expect(result.framework).toBe('go test')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('java')",
            "expect(result.framework).toBe('JUnit')",
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(\n        result.metrics.scenarioCoverage.happy +\n        result.metrics.scenarioCoverage.edge +\n        result.metrics.scenarioCoverage.error +\n        result.metrics.scenarioCoverage.sideEffects\n      ).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined() - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle missing package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Unknown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should generate patches when requested",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should write report to correct location",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain(TEST-QUALITY-LOGICAL-REPORT.md)",
            "expect(result.reportPath).toContain(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should log progress to console",
          "asserts": [
            "expect(consoleSpy).toHaveBeenCalled",
            "expect(hasLogicLogs).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should create output directories if they do not exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Python projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(python)",
            "expect(result.framework).toBe(Pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Go projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(go)",
            "expect(result.framework).toBe(go test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Java projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(java)",
            "expect(result.framework).toBe(JUnit)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate quality score based on coverage",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should process valid data",
          "asserts": [
            "expect(processData()).toBe(HELLO)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty string",
          "asserts": [
            "expect(unknown).toThrow(No data)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle special characters",
          "asserts": [
            "expect(processData()).toBe(A@B)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate valid unit test template",
          "asserts": [
            "expect(result).toContain(import { describe, it, expect } from 'vitest')",
            "expect(result).toContain(import { calculateTotal } from './utils/math.js')",
            "expect(result).toContain(describe('calculateTotal')",
            "expect(result).toContain(should work correctly with valid input)",
            "expect(result).toContain(should handle errors appropriately)",
            "expect(result).toContain(should handle edge cases)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate integration test template",
          "asserts": [
            "expect(result).toContain(supertest)",
            "expect(result).toContain(UserService Integration Tests)",
            "expect(result).toContain(beforeEach)",
            "expect(result).toContain(afterEach)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate E2E test template",
          "asserts": [
            "expect(result).toContain(@playwright/test)",
            "expect(result).toContain(LoginFlow)",
            "expect(result).toContain(should complete LoginFlow flow)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test file extension",
          "asserts": [
            "expect(adapter.getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test patterns",
          "asserts": [
            "expect(patterns).toContain(**/*.test.{ts,tsx,js,jsx})",
            "expect(patterns).toContain(**/__tests__/**/*.{ts,tsx,js,jsx})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test command",
          "asserts": [
            "expect(adapter.getTestCommand()).toBe(npm test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct coverage command",
          "asserts": [
            "expect(adapter.getCoverageCommand()).toBe(npm run test:coverage)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate valid unit test template",
          "asserts": [
            "expect(result).toContain(import pytest)",
            "expect(result).toContain(from src.utils.math import calculate_total)",
            "expect(result).toContain(class TestCalculateTotal:)",
            "expect(result).toContain(def test_calculate_total_with_valid_input)",
            "expect(result).toContain(def test_calculate_total_handles_errors)",
            "expect(result).toContain(@pytest.mark.parametrize)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate integration test template",
          "asserts": [
            "expect(result).toContain(from fastapi.testclient import TestClient)",
            "expect(result).toContain(class TestUserServiceIntegration:)",
            "expect(result).toContain(@pytest.fixture(autouse=True))",
            "expect(result).toContain(def setup_teardown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate E2E test template",
          "asserts": [
            "expect(result).toContain(from playwright.sync_api import Page)",
            "expect(result).toContain(class TestLoginFlowE2E:)",
            "expect(result).toContain(def test_complete_flow)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test file extension",
          "asserts": [
            "expect(adapter.getTestFileExtension()).toBe(_test.py)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test patterns",
          "asserts": [
            "expect(patterns).toContain(**/test_*.py)",
            "expect(patterns).toContain(**/*_test.py)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test command",
          "asserts": [
            "expect(adapter.getTestCommand()).toBe(pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct coverage command",
          "asserts": [
            "expect(adapter.getCoverageCommand()).toBe(pytest --cov=. --cov-report=json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return PythonAdapter for Python project",
          "asserts": [
            "expect(adapter.language).toBe(python)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return TypeScriptAdapter for TypeScript project",
          "asserts": [
            "expect(adapter.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should create TypeScriptAdapter",
          "asserts": [
            "expect(adapter.language).toBe(typescript)",
            "expect(adapter).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(adapter).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should create PythonAdapter",
          "asserts": [
            "expect(adapter.language).toBe(python)",
            "expect(adapter).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(adapter).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should throw for unknown language",
          "asserts": [
            "expect(adapter).toBeNull"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[1/4] scaffold_contracts_pact - deve detectar servi칞os e gerar contratos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.message).toContain(Generated)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.timestamp).toBeDefined",
            "expect(catalog.product).toBe(test-cdc-app)",
            "expect(catalog.services).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.services.length).toBeGreaterThan(0)",
            "expect(catalog.potential_contracts).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.coverage).toBeDefined",
            "expect(catalog.coverage.total_integrations).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(configContent).toContain(pactConfig)",
            "expect(configContent).toContain(test-cdc-app)",
            "expect(configContent).toContain(consumer)",
            "expect(configContent).toContain(provider)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(consumer)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(interaction)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(verify)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.services).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.potential_contracts).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.coverage).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[2/4] scaffold_contracts_pact - deve detectar m칰ltiplas APIs corretamente",
          "asserts": [
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(service.endpoints).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(service.endpoints.?).toHaveProperty(method)",
            "expect(service.endpoints.?).toHaveProperty(path)",
            "expect(contract).toHaveProperty(consumer)",
            "expect(contract).toHaveProperty(provider)",
            "expect(contract).toHaveProperty(priority)",
            "expect(unknown).toContain",
            "expect(contract.estimated_interactions).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(service.endpoints).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[3/4] run_contracts_verify - deve verificar contratos gerados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.verified).toBeGreaterThanOrEqual(0)",
            "expect(result.failed).toBeGreaterThanOrEqual(0)",
            "expect(result.report_path).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(report.timestamp).toBeDefined",
            "expect(report.product).toBe(testProduct)",
            "expect(report.language).toBe(typescript)",
            "expect(report.total_contracts).toBeGreaterThan(0)",
            "expect(report.total_interactions).toBeGreaterThan(0)",
            "expect(report.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(report.results).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(report.duration_total_ms).toBeGreaterThan(0)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)",
            "expect(mdContent).toContain(Verification Rate)",
            "expect(mdContent).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico",
            "expect(report.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(report.results).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[4/4] FULL PIPELINE - scaffold + verify funcionam em sequ칡ncia",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.total_contracts).toBeGreaterThan(0)",
            "expect(configContent).toContain(pact-broker.example.com)",
            "expect(verifyResult.ok).toBe(true)",
            "expect(verifyResult.total_interactions).toBe(6)",
            "expect(verifyResult.verification_rate).toBeGreaterThan(0)",
            "expect(report.total_contracts).toBe(3)",
            "expect(report.total_interactions).toBe(6)",
            "expect(report.verified).toBeGreaterThanOrEqual(0)",
            "expect(report.failed).toBeGreaterThanOrEqual(0)",
            "expect(unknown).toBe(6)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.final_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(result.final_params.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect RUN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.final_params.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.extracted_params.product).toBe(TestApp)",
            "expect(result.extracted_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should apply defaults when no override present",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.repo).toBe(tempDir)",
            "expect(result.final_params.product).toBe(DefaultProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should prioritize explicit overrides over defaults",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.product).toBe(ExplicitProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle empty query gracefully",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle query with only whitespace",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/diff-coverage-gate.spec.ts",
          "title": "deve ter a tool diff-coverage dispon칤vel",
          "asserts": [
            "expect(runDiffCoverage).toBeDefined",
            "expect(unknown).toBe(function)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(runDiffCoverage).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/diff-coverage-gate.spec.ts",
          "title": "deve exportar schema de par칙metros",
          "asserts": [
            "expect(module).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(module).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in empty repo",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in repo with package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.context.hasPackageJson).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work with existing mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute ANALYZE mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute PLAN mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should auto-detect repo from cwd",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.repoPath).toBeDefined",
            "expect(result.context.repoPath.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.repoPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should infer product from package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should create qa/<product>/ directory structure",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should generate all expected artifacts in FULL mode",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.outputs).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.steps).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle invalid repo path gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle missing product name",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle filesystem errors gracefully",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect vitest framework",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect existing test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "example",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should get users",
          "asserts": [
            "expect(getUsers).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(getUsers).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve executar analyze e detectar endpoints",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve criar analyze.json com findings",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(findings)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve permitir pipeline completo: analyze  coverage  plan",
          "asserts": [
            "expect(analyzeResult.findings).toBeDefined",
            "expect(coverageResult.pyramid).toBeDefined",
            "expect(planResult.plan).toBeDefined",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeResult.findings).toBeDefined - verificar valor espec칤fico",
            "expect(coverageResult.pyramid).toBeDefined - verificar valor espec칤fico",
            "expect(planResult.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve usar configura칞칚o centralizada de mcp-settings.json",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve validar health da pir칙mide corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command tool available",
          "asserts": [
            "expect(toolName).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto tool available",
          "asserts": [
            "expect(toolName).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command as high priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto as second priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid natural language query",
          "asserts": [
            "expect(validParams.query).toBe(analise meu reposit칩rio)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept query with defaults",
          "asserts": [
            "expect(unknown).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should reject empty query",
          "asserts": [
            "expect(unknown).toThrow(Query cannot be empty)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid mode",
          "asserts": [
            "expect(validParams.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept all modes",
          "asserts": [
            "expect(params.mode).toBe(mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept skip flags",
          "asserts": [
            "expect(params.skipScaffold).toBe(true)",
            "expect(params.skipRun).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should work with minimal params (auto-detection)",
          "asserts": [
            "expect(params).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(params).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate nl_command schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(query)",
            "expect(expectedProperties).toContain(defaults)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate auto schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(mode)",
            "expect(expectedProperties).toContain(repo)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have correct mode enum values",
          "asserts": [
            "expect(validModes).toHaveLength(5)",
            "expect(validModes).toContain(full)",
            "expect(validModes).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support nl_command  auto flow",
          "asserts": [
            "expect(nlParams.query).toBeTruthy",
            "expect(unknown).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(nlParams.query).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support direct auto invocation",
          "asserts": [
            "expect(autoParams.mode).toBe(analyze)",
            "expect(autoParams.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support defaults override in nl_command",
          "asserts": [
            "expect(unknown).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle invalid mode gracefully",
          "asserts": [
            "expect(unknown).toThrow(Invalid mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle missing required params",
          "asserts": [
            "expect(unknown).toThrow(Query is required)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive nl_command description",
          "asserts": [
            "expect(description).toContain(linguagem natural)",
            "expect(description).toContain(PT/EN)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive auto description",
          "asserts": [
            "expect(description).toContain(Orquestrador)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention supported languages in nl_command",
          "asserts": [
            "expect(examples).toContain(analise meu reposit칩rio)",
            "expect(examples).toContain(criar plano)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention available modes in auto",
          "asserts": [
            "expect(modes).toHaveLength(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  112 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "evaluateTestQuality",
      "filePath": "src/tools/evaluate-test-quality.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  5 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "defineSLOs",
      "filePath": "src/tools/define-slos.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve gerar SLOs com defaults baseados em criticidade",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBe(2)",
            "expect(result.custom_slos_count).toBe(0)",
            "expect(slosData.slos).toHaveLength(2)",
            "expect(criticalSLO.latency_p99_ms).toBeLessThanOrEqual(500)",
            "expect(criticalSLO.error_rate_max).toBeLessThanOrEqual(0.01)",
            "expect(criticalSLO.availability_min).toBeGreaterThanOrEqual(0.995)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve aplicar SLOs customizados quando fornecidos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.custom_slos_count).toBe(1)",
            "expect(searchSLO.latency_p99_ms).toBe(200)",
            "expect(searchSLO.error_rate_max).toBe(0.001)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve aplicar defaults customizados globais",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testSLO.latency_p99_ms).toBe(1000)",
            "expect(testSLO.error_rate_max).toBe(0.05)",
            "expect(testSLO.availability_min).toBe(0.99)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve lidar com cat치logo vazio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[FULL PIPELINE] FASE 1 + FASE 2 completa",
          "asserts": [
            "expect(cujResult.ok).toBe(true)",
            "expect(slosResult.ok).toBe(true)",
            "expect(riskResult.ok).toBe(true)",
            "expect(portfolioResult.ok).toBe(true)",
            "expect(portfolioResult.output).toContain(PORTFOLIO-PLAN.md)",
            "expect(existsSync()).toBe(true)",
            "expect(portfolioResult.recommendations_count).toBeGreaterThanOrEqual(0)",
            "expect(reportContent).toContain(# Test Portfolio Plan)",
            "expect(reportContent).toContain(## 游늵 Current State)",
            "expect(reportContent).toContain(## 游꿢 Target Distribution)",
            "expect(reportContent).toContain(## 游꿢 Module Recommendations)",
            "expect(reportContent).toContain(## 九 Action Items)",
            "expect(reportContent).toContain(Fowler)",
            "expect(reportContent).toContain(70%)",
            "expect(reportContent).toContain(20%)",
            "expect(reportContent).toContain(10%)",
            "expect(reportContent).toContain(| Test Type | Count | Percentage | Target | Gap |)",
            "expect(reportContent).toContain(Unit)",
            "expect(reportContent).toContain(Integration)",
            "expect(reportContent).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[VALIDATION] Portfolio plan deve ter estrutura correta",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(content).toContain(section)",
            "expect(content).toMatch(/\\/\\\\/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[INTEGRATION] Recommendations devem estar baseadas em riscos",
          "asserts": [
            "expect(portfolioContent).toContain(游뚿 Top 5 Critical Risks)",
            "expect(portfolioContent).toContain(Module Recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[METRICS] Distribui칞칚o deve somar 100%",
          "asserts": [
            "expect(content).toContain(Current State)",
            "expect(total).toBeGreaterThanOrEqual(99.9)",
            "expect(total).toBeLessThanOrEqual(100.1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[1/3] catalog_cujs deve gerar cuj-catalog.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(cuj-catalog.json)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog).toHaveProperty(timestamp)",
            "expect(catalog).toHaveProperty(repo)",
            "expect(catalog).toHaveProperty(product)",
            "expect(catalog).toHaveProperty(cujs)",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.cujs.length).toBeGreaterThan(0)",
            "expect(firstCUJ).toHaveProperty(id)",
            "expect(firstCUJ).toHaveProperty(name)",
            "expect(firstCUJ).toHaveProperty(criticality)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[2/3] define_slos deve gerar slos.json baseado em CUJs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(slos.json)",
            "expect(existsSync()).toBe(true)",
            "expect(slos).toHaveProperty(timestamp)",
            "expect(slos).toHaveProperty(repo)",
            "expect(slos).toHaveProperty(product)",
            "expect(slos).toHaveProperty(slos)",
            "expect(slos).toHaveProperty(defaults_applied)",
            "expect(unknown).toBe(boolean)",
            "expect(firstSLO).toHaveProperty(cuj_id)",
            "expect(firstSLO).toHaveProperty(error_rate_max)",
            "expect(firstSLO).toHaveProperty(availability_min)",
            "expect(firstSLO.error_rate_max).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.error_rate_max).toBeLessThanOrEqual(1)",
            "expect(firstSLO.availability_min).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.availability_min).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[3/3] risk_register deve gerar risk-register.json cruzando CUJs + SLOs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_risks).toBeGreaterThan(0)",
            "expect(result.output).toContain(risk-register.json)",
            "expect(existsSync()).toBe(true)",
            "expect(riskReg).toHaveProperty(timestamp)",
            "expect(riskReg).toHaveProperty(repo)",
            "expect(riskReg).toHaveProperty(product)",
            "expect(riskReg).toHaveProperty(risks)",
            "expect(riskReg).toHaveProperty(top_5_critical)",
            "expect(riskReg).toHaveProperty(total_risk_score)",
            "expect(riskReg).toHaveProperty(coverage_gaps)",
            "expect(Array.isArray()).toBe(true)",
            "expect(riskReg.top_5_critical.length).toBeLessThanOrEqual(5)",
            "expect(unknown).toBe(string)",
            "expect(firstRisk).toHaveProperty(id)",
            "expect(firstRisk).toHaveProperty(cuj_id)",
            "expect(firstRisk).toHaveProperty(title)",
            "expect(firstRisk).toHaveProperty(description)",
            "expect(firstRisk).toHaveProperty(impact)",
            "expect(firstRisk).toHaveProperty(probability)",
            "expect(firstRisk).toHaveProperty(risk_score)",
            "expect(firstRisk).toHaveProperty(affected_modules)",
            "expect(firstRisk).toHaveProperty(mitigation_strategies)",
            "expect(firstRisk).toHaveProperty(recommended_tests)",
            "expect(firstRisk.risk_score).toBeGreaterThanOrEqual(0)",
            "expect(firstRisk.risk_score).toBeLessThanOrEqual(100)",
            "expect(unknown).toContain",
            "expect(unknown).toContain",
            "expect(validTests).toContain(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[FULL] Pipeline completo deve criar 3 arquivos consistentes",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.cujs.length).toBe",
            "expect(catalog.cujs.length).toBe",
            "expect(sloIds.has()).toBe(true)",
            "expect(r.id).toBe",
            "expect(cujIds.has()).toBe(true)",
            "expect(riskIds.has()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "generateDashboard",
      "filePath": "src/tools/dashboard.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve coletar m칠tricas de testes",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard HTML",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(<!DOCTYPE html>)",
            "expect(content).toContain(TestApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve incluir gr치ficos de cobertura",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(50:30:20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard com visualiza칞칚o da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Visualiza칞칚o da Pir칙mide)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve lidar com aus칡ncia de m칠tricas",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve exibir status de sa칰de dos testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(85/100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "analyzeTestCoverage",
      "filePath": "src/tools/coverage.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve calcular % de unit/integration/E2E corretamente",
          "asserts": [
            "expect(totalTests).toBe(3)",
            "expect(result.pyramid.unit.files_found).toBe(1)",
            "expect(result.pyramid.integration.files_found).toBe(1)",
            "expect(result.pyramid.e2e.files_found).toBe(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "4",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "5",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "6",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "7",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve marcar como saud치vel se unit >= 70%",
          "asserts": [
            "expect(result.health).toBe(healthy)",
            "expect(result.summary).toContain(SAUD츼VEL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve alertar se E2E > unit",
          "asserts": [
            "expect(result.health).toBe(inverted)",
            "expect(hasInvertedWarning).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve sugerir mais unit tests se < 70%",
          "asserts": [
            "expect(hasUnitRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve salvar COVERAGE-REPORT.md e coverage-analysis.json",
          "asserts": [
            "expect(reportExists).toBe(true)",
            "expect(analysisExists).toBe(true)",
            "expect(data.summary).toBeDefined",
            "expect(data.pyramid).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(data.summary).toBeDefined - verificar valor espec칤fico",
            "expect(data.pyramid).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve lidar com reposit칩rio sem testes",
          "asserts": [
            "expect(result.pyramid.unit.files_found).toBe(0)",
            "expect(result.pyramid.integration.files_found).toBe(0)",
            "expect(result.pyramid.e2e.files_found).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas na cobertura atual",
          "asserts": [
            "expect(coverage.summary).toContain(Status:)",
            "expect(coverage.summary).toContain(Pir칙mide)",
            "expect(coverage.pyramid.unit.files_found).toBeGreaterThanOrEqual(0)",
            "expect(coverage.pyramid.e2e.files_found).toBeGreaterThanOrEqual(0)",
            "expect(coverage.health).toBe(inverted)",
            "expect(coverage.recommendations.length).toBeGreaterThan(0)",
            "expect(hasUnitRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve usar coverage analysis para gerar relat칩rio visual",
          "asserts": [
            "expect(coverage.health).toBe(healthy)",
            "expect(pyramidReport.ok).toBe(true)",
            "expect(pyramidReport.report_path).toMatch(/PYRAMID-REPORT\\.(html|md)$/)",
            "expect(htmlExists).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(htmlContent.length).toBeGreaterThan(500)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas em gaps",
          "asserts": [
            "expect(coverage.pyramid.unit.files_found).toBe(0)",
            "expect(coverage.pyramid.unit.missing_tests.length).toBeGreaterThan(0)",
            "expect(coverage.recommendations.length).toBeGreaterThan(0)",
            "expect(report.ok).toBe(true)",
            "expect(mdContent.length).toBeGreaterThan(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should get users",
          "asserts": [
            "expect(getUsers).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(getUsers).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve executar analyze e detectar endpoints",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve criar analyze.json com findings",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(findings)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve permitir pipeline completo: analyze  coverage  plan",
          "asserts": [
            "expect(analyzeResult.findings).toBeDefined",
            "expect(coverageResult.pyramid).toBeDefined",
            "expect(planResult.plan).toBeDefined",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeResult.findings).toBeDefined - verificar valor espec칤fico",
            "expect(coverageResult.pyramid).toBeDefined - verificar valor espec칤fico",
            "expect(planResult.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve usar configura칞칚o centralizada de mcp-settings.json",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve validar health da pir칙mide corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  8 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "consolidateCodeAnalysisReport",
      "filePath": "src/tools/consolidate-reports.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "consolidateTestPlanReport",
      "filePath": "src/tools/consolidate-reports.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "catalogScenarios",
      "filePath": "src/tools/catalog.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve listar cen치rios de teste",
          "asserts": [
            "expect(result.total_scenarios).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should create user",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should update user",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve atribuir squads aos cen치rios",
          "asserts": [
            "expect(Object.keys().length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should login",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve detectar cen치rios duplicados",
          "asserts": [
            "expect(result.duplicates).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.duplicates).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve gerar matriz de responsabilidades",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(Matriz de Responsabilidade - Testes)",
            "expect(content).toContain(Squad A)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should work",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve salvar cat치logo em Markdown",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(Cat치logo de Cen치rios)",
            "expect(content).toContain(TestApp)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should pass",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve lidar com reposit칩rio sem testes",
          "asserts": [
            "expect(result.total_scenarios).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve contar cen치rios por squad",
          "asserts": [
            "expect(result.total_scenarios).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "test 1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "test 2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "test 3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "deve identificar cen치rios por prioridade",
          "asserts": [
            "expect(result.by_priority.P1.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog.test.ts",
          "title": "should handle payment",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  1 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "catalogCUJs",
      "filePath": "src/tools/catalog-cujs.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[FULL PIPELINE] FASE 1 + FASE 2 completa",
          "asserts": [
            "expect(cujResult.ok).toBe(true)",
            "expect(slosResult.ok).toBe(true)",
            "expect(riskResult.ok).toBe(true)",
            "expect(portfolioResult.ok).toBe(true)",
            "expect(portfolioResult.output).toContain(PORTFOLIO-PLAN.md)",
            "expect(existsSync()).toBe(true)",
            "expect(portfolioResult.recommendations_count).toBeGreaterThanOrEqual(0)",
            "expect(reportContent).toContain(# Test Portfolio Plan)",
            "expect(reportContent).toContain(## 游늵 Current State)",
            "expect(reportContent).toContain(## 游꿢 Target Distribution)",
            "expect(reportContent).toContain(## 游꿢 Module Recommendations)",
            "expect(reportContent).toContain(## 九 Action Items)",
            "expect(reportContent).toContain(Fowler)",
            "expect(reportContent).toContain(70%)",
            "expect(reportContent).toContain(20%)",
            "expect(reportContent).toContain(10%)",
            "expect(reportContent).toContain(| Test Type | Count | Percentage | Target | Gap |)",
            "expect(reportContent).toContain(Unit)",
            "expect(reportContent).toContain(Integration)",
            "expect(reportContent).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[VALIDATION] Portfolio plan deve ter estrutura correta",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(content).toContain(section)",
            "expect(content).toMatch(/\\/\\\\/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[INTEGRATION] Recommendations devem estar baseadas em riscos",
          "asserts": [
            "expect(portfolioContent).toContain(游뚿 Top 5 Critical Risks)",
            "expect(portfolioContent).toContain(Module Recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[METRICS] Distribui칞칚o deve somar 100%",
          "asserts": [
            "expect(content).toContain(Current State)",
            "expect(total).toBeGreaterThanOrEqual(99.9)",
            "expect(total).toBeLessThanOrEqual(100.1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[1/3] catalog_cujs deve gerar cuj-catalog.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(cuj-catalog.json)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog).toHaveProperty(timestamp)",
            "expect(catalog).toHaveProperty(repo)",
            "expect(catalog).toHaveProperty(product)",
            "expect(catalog).toHaveProperty(cujs)",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.cujs.length).toBeGreaterThan(0)",
            "expect(firstCUJ).toHaveProperty(id)",
            "expect(firstCUJ).toHaveProperty(name)",
            "expect(firstCUJ).toHaveProperty(criticality)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[2/3] define_slos deve gerar slos.json baseado em CUJs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(slos.json)",
            "expect(existsSync()).toBe(true)",
            "expect(slos).toHaveProperty(timestamp)",
            "expect(slos).toHaveProperty(repo)",
            "expect(slos).toHaveProperty(product)",
            "expect(slos).toHaveProperty(slos)",
            "expect(slos).toHaveProperty(defaults_applied)",
            "expect(unknown).toBe(boolean)",
            "expect(firstSLO).toHaveProperty(cuj_id)",
            "expect(firstSLO).toHaveProperty(error_rate_max)",
            "expect(firstSLO).toHaveProperty(availability_min)",
            "expect(firstSLO.error_rate_max).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.error_rate_max).toBeLessThanOrEqual(1)",
            "expect(firstSLO.availability_min).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.availability_min).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[3/3] risk_register deve gerar risk-register.json cruzando CUJs + SLOs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_risks).toBeGreaterThan(0)",
            "expect(result.output).toContain(risk-register.json)",
            "expect(existsSync()).toBe(true)",
            "expect(riskReg).toHaveProperty(timestamp)",
            "expect(riskReg).toHaveProperty(repo)",
            "expect(riskReg).toHaveProperty(product)",
            "expect(riskReg).toHaveProperty(risks)",
            "expect(riskReg).toHaveProperty(top_5_critical)",
            "expect(riskReg).toHaveProperty(total_risk_score)",
            "expect(riskReg).toHaveProperty(coverage_gaps)",
            "expect(Array.isArray()).toBe(true)",
            "expect(riskReg.top_5_critical.length).toBeLessThanOrEqual(5)",
            "expect(unknown).toBe(string)",
            "expect(firstRisk).toHaveProperty(id)",
            "expect(firstRisk).toHaveProperty(cuj_id)",
            "expect(firstRisk).toHaveProperty(title)",
            "expect(firstRisk).toHaveProperty(description)",
            "expect(firstRisk).toHaveProperty(impact)",
            "expect(firstRisk).toHaveProperty(probability)",
            "expect(firstRisk).toHaveProperty(risk_score)",
            "expect(firstRisk).toHaveProperty(affected_modules)",
            "expect(firstRisk).toHaveProperty(mitigation_strategies)",
            "expect(firstRisk).toHaveProperty(recommended_tests)",
            "expect(firstRisk.risk_score).toBeGreaterThanOrEqual(0)",
            "expect(firstRisk.risk_score).toBeLessThanOrEqual(100)",
            "expect(unknown).toContain",
            "expect(unknown).toContain",
            "expect(validTests).toContain(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[FULL] Pipeline completo deve criar 3 arquivos consistentes",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.cujs.length).toBe",
            "expect(catalog.cujs.length).toBe",
            "expect(sloIds.has()).toBe(true)",
            "expect(r.id).toBe",
            "expect(cujIds.has()).toBe(true)",
            "expect(riskIds.has()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "detectRepoContext",
      "filePath": "src/tools/auto.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "autoQualityRun",
      "filePath": "src/tools/auto.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should default to FULL mode for unrecognized queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.repo).toBe(/home/user/project)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract product override",
          "asserts": [
            "expect(result.product).toBe(MyApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.repo).toBe(/tmp/test)",
            "expect(result.product).toBe(Portal)",
            "expect(result.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return empty object for no overrides",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should execute with detected mode from query",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should merge extracted overrides with detected mode",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.extracted_params).toEqual({...})",
            "expect(result.final_params).toMatchObject({...})",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should apply defaults and override with extracted params",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should prioritize explicit mode override over detected mode",
          "asserts": [
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(analyze)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.success).toBe(false)",
            "expect(result.error).toBe(Test error)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return true on success",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return false on error",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in empty repo",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in repo with package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.context.hasPackageJson).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work with existing mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute ANALYZE mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute PLAN mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should auto-detect repo from cwd",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.repoPath).toBeDefined",
            "expect(result.context.repoPath.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.repoPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should infer product from package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should create qa/<product>/ directory structure",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should generate all expected artifacts in FULL mode",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.outputs).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.steps).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle invalid repo path gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle missing product name",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle filesystem errors gracefully",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect vitest framework",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect existing test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "example",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  19 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "runAutoMode",
      "filePath": "src/tools/auto.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "analyze",
      "filePath": "src/tools/analyze.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve validar par칙metros v치lidos",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve rejeitar sem repo",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve validar URL v치lida",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve rejeitar URL inv치lida",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve validar nome de produto alphanumeric",
          "asserts": [
            "expect(regex.test()).toBe(true)",
            "expect(regex.test()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "valid-product-123",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "invalid@product!",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve validar schema completo",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.test.ts",
          "title": "deve ter todos os nomes de tools essenciais",
          "asserts": [
            "expect(toolNames).toHaveLength(16)",
            "expect(toolNames).toContain(nl_command)",
            "expect(toolNames).toContain(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates)",
          "asserts": [
            "expect(MCP_TOOLS).toHaveLength(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tools devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(tool).toHaveProperty(name)",
            "expect(tool).toHaveProperty(description)",
            "expect(tool).toHaveProperty(inputSchema)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(tool.inputSchema.type).toBe(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve conter todos os 5 tools esperados",
          "asserts": [
            "expect(names).toContain(name)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve encontrar tool por nome",
          "asserts": [
            "expect(tool).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(tool).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve retornar undefined para tool inexistente",
          "asserts": [
            "expect(tool).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool analyze deve ter campos repo e product obrigat칩rios",
          "asserts": [
            "expect(tool.inputSchema.required).toContain(repo)",
            "expect(tool.inputSchema.required).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool validate deve ter campos de threshold",
          "asserts": [
            "expect(props).toHaveProperty(minBranch)",
            "expect(props).toHaveProperty(minMutation)",
            "expect(props).toHaveProperty(minDiffCoverage)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool scaffold deve ter campo type com enum",
          "asserts": [
            "expect(typeField.enum).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "todos os tools devem ter description com emoji",
          "asserts": [
            "expect(tool.description.length).toBeGreaterThan(10)",
            "expect(tool.description.charCodeAt()).toBeGreaterThan(255)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear dom칤nios separados por v칤rgula",
          "asserts": [
            "expect(domains).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear critical flows separados por v칤rgula",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear JSON de targets",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o se n칚o especificado",
          "asserts": [
            "expect(defaultOut).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve aceitar include-examples como boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(packages/product-e2e)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve converter --headed para headless=false",
          "asserts": [
            "expect(headless).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar headless=true por padr칚o",
          "asserts": [
            "expect(headless).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de relat칩rios padr칚o",
          "asserts": [
            "expect(defaultReport).toBe(reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar arquivo de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(SUMMARY.md)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de arquivos",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de endpoints",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de squads",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear thresholds JSON",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar URL base",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar URL inv치lida",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar nome de produto alphanumeric",
          "asserts": [
            "expect(regex.test()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar nome de produto com caracteres especiais",
          "asserts": [
            "expect(regex.test()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato markdown",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato html",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato json",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar formato inv치lido",
          "asserts": [
            "expect(['markdown', 'html', 'json']).not.toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar jest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar vitest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar mocha",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter todos os comandos esperados registrados na CLI",
          "asserts": [
            "expect(helpOutput).toContain(command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter descri칞칫es para todos os comandos",
          "asserts": [
            "expect(helpOutput).toContain",
            "expect(helpOutput).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar que comandos espec칤ficos aceitam par칙metros obrigat칩rios",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)",
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar comandos inexistentes com mensagem clara",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(output).toMatch(/unknown command|error/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve garantir que scripts npm correspondam aos comandos CLI",
          "asserts": [
            "expect(packageJson.scripts).toHaveProperty(scriptName)",
            "expect(packageJson.scripts.scriptName).toContain(cliCommand)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-run deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--fix deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-scaffold deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(opts.skipScaffold).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--repo deve rejeitar se n칚o tiver valor",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--product deve aceitar valor",
          "asserts": [
            "expect(opts.product).toBe(my-product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "analyze --repo . --product ",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.product).toBe(mcp)",
            "expect(opts.mode).toBe(analyze)",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "self-check --repo . --fix",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.minMutation).toBe(60)",
            "expect(opts.minBranch).toBe(70)",
            "expect(opts.failFast).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "Boolean defaultValue = flag sem <value>",
          "asserts": [
            "expect(booleanFlags.length).toBeGreaterThanOrEqual(2)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "String/Number defaultValue = flag com <value>",
          "asserts": [
            "expect(valueFlags.length).toBeGreaterThanOrEqual(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve gerar paths padr칚o para qa/<product>",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)",
            "expect(paths.analyses).toBe(/repo/qa/my-app/tests/analyses)",
            "expect(paths.reports).toBe(/repo/qa/my-app/tests/reports)",
            "expect(paths.playwrightReports).toBe(/repo/qa/my-app/tests/reports/playwright)",
            "expect(paths.unit).toBe(/repo/qa/my-app/tests/unit)",
            "expect(paths.integration).toBe(/repo/qa/my-app/tests/integration)",
            "expect(paths.e2e).toBe(/repo/qa/my-app/tests/e2e)",
            "expect(paths.fixtures).toBe(/repo/qa/my-app/fixtures)",
            "expect(paths.fixturesAuth).toBe(/repo/qa/my-app/fixtures/auth)",
            "expect(paths.dashboards).toBe(/repo/qa/my-app/dashboards)",
            "expect(paths.patches).toBe(/repo/qa/my-app/patches)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve respeitar output_root customizado via settings",
          "asserts": [
            "expect(paths.root).toBe(/repo/custom/qa-output)",
            "expect(paths.analyses).toBe(/repo/custom/qa-output/tests/analyses)",
            "expect(paths.reports).toBe(/repo/custom/qa-output/tests/reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com paths absolutos Windows-style",
          "asserts": [
            "expect(paths.root).toContain(my-app)",
            "expect(paths.analyses).toContain(tests)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve sanitizar corretamente nomes de produto com caracteres especiais",
          "asserts": [
            "expect(paths1.root).toBe(/repo/qa/@scope/package)",
            "expect(paths2.root).toBe(/repo/qa/my_app-v2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar todos os diret칩rios da estrutura",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser idempotente (n칚o falhar se diret칩rios j치 existem)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar estrutura mesmo se diret칩rio pai n칚o existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar true para paths dentro de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar false para paths fora de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path (Windows vs Unix)",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear JSON para analyses/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/analyze.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/coverage-analysis.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear MD e HTML para reports/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PLAN.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/QUALITY-REPORT.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PYRAMID.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear dashboard.html para dashboards/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/dashboard.html)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/Dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear .patch para patches/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/patches/fix-weak-assertions.patch)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve usar root como fallback para tipos desconhecidos",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/unknown.txt)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/package.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser case-insensitive para extens칫es",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/REPORT.MD)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/Data.JSON)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path relativo ao root do QA",
          "asserts": [
            "expect(getRelativePath()).toBe(tests/reports/PLAN.md)",
            "expect(getRelativePath()).toBe(tests/analyses/analyze.json)",
            "expect(getRelativePath()).toBe(dashboards/dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path original se n칚o estiver dentro do root",
          "asserts": [
            "expect(getRelativePath()).toBe(outsidePath)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path",
          "asserts": [
            "expect(relative).toBe(tests/unit/foo.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter todas as propriedades necess치rias",
          "asserts": [
            "expect(paths).toHaveProperty(prop)",
            "expect(unknown).toBe(string)",
            "expect(paths.prop.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter paths 칰nicos (sem duplicatas)",
          "asserts": [
            "expect(uniquePaths.size).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com product name vazio ou inv치lido",
          "asserts": [
            "expect(paths1.root).toContain(/repo/qa)",
            "expect(paths2.root).toContain(/repo/qa)",
            "expect(paths1.analyses).toContain(tests/analyses)",
            "expect(paths2.analyses).toContain(tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com repo path com espa칞os",
          "asserts": [
            "expect(paths.root).toBe(/Users/my folder/repo/qa/my-app)",
            "expect(paths.analyses).toContain(/Users/my folder/repo/qa/my-app/tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve preservar case do product name",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/MyApp-V2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings.paths undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve gerar plano de testes b치sico",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.plan).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve criar arquivo TEST-PLAN.md",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(TestProduct2)",
            "expect(content).toContain(Plano de Testes)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir exemplos quando solicitado",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve usar configura칞칚o de mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve organizar por dom칤nios quando fornecidos",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve validar par칙metros obrigat칩rios",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir TODOs autom치ticos no plano",
          "asserts": [
            "expect(content).toContain(游꿢 A칞칫es Recomendadas)",
            "expect(content).toContain(TODO: Create auth fixtures)",
            "expect(content).toContain(TODO: Consider Testcontainers)",
            "expect(content).toContain(TODO: Configure CI/CD pipeline)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir Quality Gates com thresholds",
          "asserts": [
            "expect(content).toContain(Quality Gates)",
            "expect(content).toContain(Required Coverage)",
            "expect(content).toContain(Performance)",
            "expect(content).toContain(Blocking Criteria)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve calcular risk scores quando houver dados de an치lise",
          "asserts": [
            "expect(content).toContain(游댠 Risk Score Analysis)",
            "expect(content).toMatch(/Score:/)",
            "expect(content).toMatch(/Probability:/)",
            "expect(content).toMatch(/Impact:/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect FULL mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect ANALYZE mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)",
            "expect(detectMode()).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect PLAN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)",
            "expect(detectMode()).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect SCAFFOLD mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)",
            "expect(detectMode()).toBe(scaffold)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from PT queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should detect RUN mode from EN queries",
          "asserts": [
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)",
            "expect(detectMode()).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should default to FULL mode for unrecognized queries",
          "asserts": [
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)",
            "expect(detectMode()).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.repo).toBe(/home/user/project)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract product override",
          "asserts": [
            "expect(result.product).toBe(MyApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.repo).toBe(/tmp/test)",
            "expect(result.product).toBe(Portal)",
            "expect(result.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return empty object for no overrides",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should execute with detected mode from query",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should merge extracted overrides with detected mode",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.extracted_params).toEqual({...})",
            "expect(result.final_params).toMatchObject({...})",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should apply defaults and override with extracted params",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should prioritize explicit mode override over detected mode",
          "asserts": [
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(analyze)",
            "expect(autoQualityRun).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.success).toBe(false)",
            "expect(result.error).toBe(Test error)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return true on success",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/nl-command.test.ts",
          "title": "should return false on error",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve coletar m칠tricas de testes",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard HTML",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(<!DOCTYPE html>)",
            "expect(content).toContain(TestApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve incluir gr치ficos de cobertura",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(50:30:20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard com visualiza칞칚o da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Visualiza칞칚o da Pir칙mide)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve lidar com aus칡ncia de m칠tricas",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve exibir status de sa칰de dos testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(85/100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve calcular % de unit/integration/E2E corretamente",
          "asserts": [
            "expect(totalTests).toBe(3)",
            "expect(result.pyramid.unit.files_found).toBe(1)",
            "expect(result.pyramid.integration.files_found).toBe(1)",
            "expect(result.pyramid.e2e.files_found).toBe(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "4",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "5",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "6",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "7",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve marcar como saud치vel se unit >= 70%",
          "asserts": [
            "expect(result.health).toBe(healthy)",
            "expect(result.summary).toContain(SAUD츼VEL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve alertar se E2E > unit",
          "asserts": [
            "expect(result.health).toBe(inverted)",
            "expect(hasInvertedWarning).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve sugerir mais unit tests se < 70%",
          "asserts": [
            "expect(hasUnitRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve salvar COVERAGE-REPORT.md e coverage-analysis.json",
          "asserts": [
            "expect(reportExists).toBe(true)",
            "expect(analysisExists).toBe(true)",
            "expect(data.summary).toBeDefined",
            "expect(data.pyramid).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(data.summary).toBeDefined - verificar valor espec칤fico",
            "expect(data.pyramid).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/coverage.test.ts",
          "title": "deve lidar com reposit칩rio sem testes",
          "asserts": [
            "expect(result.pyramid.unit.files_found).toBe(0)",
            "expect(result.pyramid.integration.files_found).toBe(0)",
            "expect(result.pyramid.e2e.files_found).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar rotas Next.js e classificar como medium risk",
          "asserts": [
            "expect(result.findings.routes).toContain(/)",
            "expect(result.findings.routes).toContain(/about)",
            "expect(result.summary).toContain(2 rotas web)",
            "expect(routeRisks.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar endpoints Express e sugerir CDC",
          "asserts": [
            "expect(result.findings.endpoints).toHaveLength(2)",
            "expect(result.findings.endpoints).toContain(GET /api/users)",
            "expect(result.findings.endpoints).toContain(POST /api/users)",
            "expect(hasCDCRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve encontrar eventos e mapear riscos",
          "asserts": [
            "expect(result.findings.events).toHaveLength(2)",
            "expect(result.findings.events).toContain(kafka:user-created)",
            "expect(result.findings.events).toContain(event:order-placed)",
            "expect(eventRisks.length).toBe(2)",
            "expect(eventRisks.every()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "order-placed",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos findings",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(hasE2ERecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve salvar resultado em tests/analyses/analyze.json",
          "asserts": [
            "expect(fileExists).toBe(true)",
            "expect(data.summary).toBeDefined",
            "expect(data.findings).toBeDefined",
            "expect(data.recommendations).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(data.summary).toBeDefined - verificar valor espec칤fico",
            "expect(data.findings).toBeDefined - verificar valor espec칤fico",
            "expect(data.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve lidar com reposit칩rio sem c칩digo",
          "asserts": [
            "expect(result.findings.routes).toEqual([...])",
            "expect(result.findings.endpoints).toEqual([...])",
            "expect(result.findings.events).toEqual([...])",
            "expect(result.summary).toContain(0 rotas web)",
            "expect(result.summary).toContain(0 endpoints)",
            "expect(result.summary).toContain(0 eventos)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve marcar rotas cr칤ticas como high risk",
          "asserts": [
            "expect(loginRisk).toBeDefined",
            "expect(unknown).toBe(high)",
            "expect(unknown).toContain(fluxo cr칤tico)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(loginRisk).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze.test.ts",
          "title": "deve reduzir risco de endpoints quando OpenAPI est치 presente",
          "asserts": [
            "expect(endpointRisk).toBeDefined",
            "expect(unknown).toBe(low)",
            "expect(unknown).toContain(contrato OpenAPI)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(endpointRisk).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should analyze TypeScript project with basic tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(Vitest)",
            "expect(result.functions.length).toBeGreaterThan(0)",
            "expect(addFunc).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(addFunc).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should add positive numbers",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle zero",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should multiply numbers",
          "asserts": [
            "expect(multiply()).toBe(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect framework automatically",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate scenario coverage correctly",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should validate correct email",
          "asserts": [
            "expect(validateEmail()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should reject invalid email",
          "asserts": [
            "expect(validateEmail()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should throw on empty email",
          "asserts": [
            "expect(unknown).toThrow(Email required)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty repository",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])",
            "expect(result.metrics.qualityScore).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle repository without tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toEqual([...])",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle functions with weak assertions",
          "asserts": [
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should return user",
          "asserts": [
            "expect(user).toBeTruthy",
            "expect(user).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(user).toBeTruthy - usar compara칞칚o expl칤cita",
            "expect(user).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle null/undefined inputs gracefully",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle very large codebase efficiently",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBeGreaterThanOrEqual(10)",
            "expect(duration).toBeLessThan(10000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle invalid repository path",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed source files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')",
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined()",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain('TEST-QUALITY-LOGICAL-REPORT.md')",
            "expect(result.reportPath).toContain(testDir)",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(hasLogicLogs).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('python')",
            "expect(result.framework).toBe('Pytest')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('go')",
            "expect(result.framework).toBe('go test')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('java')",
            "expect(result.framework).toBe('JUnit')",
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(\n        result.metrics.scenarioCoverage.happy +\n        result.metrics.scenarioCoverage.edge +\n        result.metrics.scenarioCoverage.error +\n        result.metrics.scenarioCoverage.sideEffects\n      ).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined() - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle missing package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Unknown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should generate patches when requested",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should write report to correct location",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain(TEST-QUALITY-LOGICAL-REPORT.md)",
            "expect(result.reportPath).toContain(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should log progress to console",
          "asserts": [
            "expect(consoleSpy).toHaveBeenCalled",
            "expect(hasLogicLogs).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should create output directories if they do not exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Python projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(python)",
            "expect(result.framework).toBe(Pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Go projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(go)",
            "expect(result.framework).toBe(go test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Java projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(java)",
            "expect(result.framework).toBe(JUnit)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate quality score based on coverage",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should process valid data",
          "asserts": [
            "expect(processData()).toBe(HELLO)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty string",
          "asserts": [
            "expect(unknown).toThrow(No data)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle special characters",
          "asserts": [
            "expect(processData()).toBe(A@B)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command tool available",
          "asserts": [
            "expect(toolName).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto tool available",
          "asserts": [
            "expect(toolName).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command as high priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto as second priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid natural language query",
          "asserts": [
            "expect(validParams.query).toBe(analise meu reposit칩rio)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept query with defaults",
          "asserts": [
            "expect(unknown).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should reject empty query",
          "asserts": [
            "expect(unknown).toThrow(Query cannot be empty)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid mode",
          "asserts": [
            "expect(validParams.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept all modes",
          "asserts": [
            "expect(params.mode).toBe(mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept skip flags",
          "asserts": [
            "expect(params.skipScaffold).toBe(true)",
            "expect(params.skipRun).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should work with minimal params (auto-detection)",
          "asserts": [
            "expect(params).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(params).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate nl_command schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(query)",
            "expect(expectedProperties).toContain(defaults)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate auto schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(mode)",
            "expect(expectedProperties).toContain(repo)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have correct mode enum values",
          "asserts": [
            "expect(validModes).toHaveLength(5)",
            "expect(validModes).toContain(full)",
            "expect(validModes).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support nl_command  auto flow",
          "asserts": [
            "expect(nlParams.query).toBeTruthy",
            "expect(unknown).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(nlParams.query).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support direct auto invocation",
          "asserts": [
            "expect(autoParams.mode).toBe(analyze)",
            "expect(autoParams.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support defaults override in nl_command",
          "asserts": [
            "expect(unknown).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle invalid mode gracefully",
          "asserts": [
            "expect(unknown).toThrow(Invalid mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle missing required params",
          "asserts": [
            "expect(unknown).toThrow(Query is required)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive nl_command description",
          "asserts": [
            "expect(description).toContain(linguagem natural)",
            "expect(description).toContain(PT/EN)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive auto description",
          "asserts": [
            "expect(description).toContain(Orquestrador)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention supported languages in nl_command",
          "asserts": [
            "expect(examples).toContain(analise meu reposit칩rio)",
            "expect(examples).toContain(criar plano)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention available modes in auto",
          "asserts": [
            "expect(modes).toHaveLength(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas na cobertura atual",
          "asserts": [
            "expect(coverage.summary).toContain(Status:)",
            "expect(coverage.summary).toContain(Pir칙mide)",
            "expect(coverage.pyramid.unit.files_found).toBeGreaterThanOrEqual(0)",
            "expect(coverage.pyramid.e2e.files_found).toBeGreaterThanOrEqual(0)",
            "expect(coverage.health).toBe(inverted)",
            "expect(coverage.recommendations.length).toBeGreaterThan(0)",
            "expect(hasUnitRecommendation).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve usar coverage analysis para gerar relat칩rio visual",
          "asserts": [
            "expect(coverage.health).toBe(healthy)",
            "expect(pyramidReport.ok).toBe(true)",
            "expect(pyramidReport.report_path).toMatch(/PYRAMID-REPORT\\.(html|md)$/)",
            "expect(htmlExists).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(htmlContent.length).toBeGreaterThan(500)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas em gaps",
          "asserts": [
            "expect(coverage.pyramid.unit.files_found).toBe(0)",
            "expect(coverage.pyramid.unit.missing_tests.length).toBeGreaterThan(0)",
            "expect(coverage.recommendations.length).toBeGreaterThan(0)",
            "expect(report.ok).toBe(true)",
            "expect(mdContent.length).toBeGreaterThan(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/coverage-to-recommendations.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve gerar plano baseado nos findings da an치lise",
          "asserts": [
            "expect(analysis.findings.routes).toContain(/login)",
            "expect(analysis.findings.endpoints.length).toBeGreaterThan(0)",
            "expect(plan.ok).toBe(true)",
            "expect(plan.plan).toBeDefined",
            "expect(planExists).toBe(true)",
            "expect(planContent).toContain(Test App)",
            "expect(planContent).toContain(Playwright)",
            "expect(planContent).toContain(playwright.config.ts)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(plan.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve incluir recomenda칞칫es da an치lise no plano",
          "asserts": [
            "expect(analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(plan.ok).toBe(true)",
            "expect(planContent).toContain(Cen치rios)",
            "expect(planContent).toContain(Risco)",
            "expect(planContent).toContain(Playwright)",
            "expect(planContent).toContain(Exemplo)",
            "expect(planContent).toContain(example)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/analyze-to-plan.test.ts",
          "title": "deve organizar plano por dom칤nios quando especificados",
          "asserts": [
            "expect(plan.ok).toBe(true)",
            "expect(planContent.length).toBeGreaterThan(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.final_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(result.final_params.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect RUN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.final_params.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.extracted_params.product).toBe(TestApp)",
            "expect(result.extracted_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should apply defaults when no override present",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.repo).toBe(tempDir)",
            "expect(result.final_params.product).toBe(DefaultProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should prioritize explicit overrides over defaults",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.product).toBe(ExplicitProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle empty query gracefully",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle query with only whitespace",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar estrutura completa de QA",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.path).toContain(EcommerceApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar mcp-settings.json com configura칞칫es corretas",
          "asserts": [
            "expect(settings).toMatchObject({...})",
            "expect(settings.environments).toHaveProperty(dev)",
            "expect(settings.environments).toHaveProperty(stg)",
            "expect(settings.environments).toHaveProperty(prod)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar estrutura de diret칩rios completa",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar GETTING_STARTED.md com documenta칞칚o",
          "asserts": [
            "expect(content).toContain(EcommerceApp)",
            "expect(content).toContain(Quality MCP)",
            "expect(content).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar README.md",
          "asserts": [
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve criar .gitignore apropriado",
          "asserts": [
            "expect(content).toContain(node_modules/)",
            "expect(content).toContain(coverage/)",
            "expect(content).toContain(playwright-report/)",
            "expect(content).toContain(.env)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "n칚o deve sobrescrever mcp-settings.json existente",
          "asserts": [
            "expect(newSettings.custom_field).toBe(should_persist)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/init-product-flow.spec.ts",
          "title": "deve permitir criar m칰ltiplos produtos no mesmo repo",
          "asserts": [
            "expect(ecommerceExists).toBe(true)",
            "expect(paymentExists).toBe(true)",
            "expect(ecommerceSettings.product).toBe(EcommerceApp)",
            "expect(ecommerceSettings.base_url).toBe(https://www.ecommerce.com)",
            "expect(paymentSettings.product).toBe(PaymentService)",
            "expect(paymentSettings.base_url).toBe(https://api.payment.com)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in empty repo",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in repo with package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.context.hasPackageJson).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work with existing mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute ANALYZE mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute PLAN mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should auto-detect repo from cwd",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.repoPath).toBeDefined",
            "expect(result.context.repoPath.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.repoPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should infer product from package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should create qa/<product>/ directory structure",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should generate all expected artifacts in FULL mode",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.outputs).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.steps).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle invalid repo path gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle missing product name",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle filesystem errors gracefully",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect vitest framework",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect existing test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "example",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should get users",
          "asserts": [
            "expect(getUsers).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(getUsers).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve executar analyze e detectar endpoints",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve criar analyze.json com findings",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(findings)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve permitir pipeline completo: analyze  coverage  plan",
          "asserts": [
            "expect(analyzeResult.findings).toBeDefined",
            "expect(coverageResult.pyramid).toBeDefined",
            "expect(planResult.plan).toBeDefined",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeResult.findings).toBeDefined - verificar valor espec칤fico",
            "expect(coverageResult.pyramid).toBeDefined - verificar valor espec칤fico",
            "expect(planResult.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve usar configura칞칚o centralizada de mcp-settings.json",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve validar health da pir칙mide corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  77 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "analyzeTestLogic",
      "filePath": "src/tools/analyze-test-logic.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should analyze TypeScript project with basic tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(Vitest)",
            "expect(result.functions.length).toBeGreaterThan(0)",
            "expect(addFunc).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(addFunc).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should add positive numbers",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle zero",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should multiply numbers",
          "asserts": [
            "expect(multiply()).toBe(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect framework automatically",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate scenario coverage correctly",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should validate correct email",
          "asserts": [
            "expect(validateEmail()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should reject invalid email",
          "asserts": [
            "expect(validateEmail()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should throw on empty email",
          "asserts": [
            "expect(unknown).toThrow(Email required)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty repository",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])",
            "expect(result.metrics.qualityScore).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle repository without tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toEqual([...])",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle functions with weak assertions",
          "asserts": [
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should return user",
          "asserts": [
            "expect(user).toBeTruthy",
            "expect(user).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(user).toBeTruthy - usar compara칞칚o expl칤cita",
            "expect(user).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle null/undefined inputs gracefully",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle very large codebase efficiently",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBeGreaterThanOrEqual(10)",
            "expect(duration).toBeLessThan(10000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle invalid repository path",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed source files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')",
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined()",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain('TEST-QUALITY-LOGICAL-REPORT.md')",
            "expect(result.reportPath).toContain(testDir)",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(hasLogicLogs).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('python')",
            "expect(result.framework).toBe('Pytest')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('go')",
            "expect(result.framework).toBe('go test')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('java')",
            "expect(result.framework).toBe('JUnit')",
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(\n        result.metrics.scenarioCoverage.happy +\n        result.metrics.scenarioCoverage.edge +\n        result.metrics.scenarioCoverage.error +\n        result.metrics.scenarioCoverage.sideEffects\n      ).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined() - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle missing package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Unknown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should generate patches when requested",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should write report to correct location",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain(TEST-QUALITY-LOGICAL-REPORT.md)",
            "expect(result.reportPath).toContain(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should log progress to console",
          "asserts": [
            "expect(consoleSpy).toHaveBeenCalled",
            "expect(hasLogicLogs).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should create output directories if they do not exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Python projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(python)",
            "expect(result.framework).toBe(Pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Go projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(go)",
            "expect(result.framework).toBe(go test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Java projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(java)",
            "expect(result.framework).toBe(JUnit)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate quality score based on coverage",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should process valid data",
          "asserts": [
            "expect(processData()).toBe(HELLO)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty string",
          "asserts": [
            "expect(unknown).toThrow(No data)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle special characters",
          "asserts": [
            "expect(processData()).toBe(A@B)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  6 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "validateThresholds",
      "filePath": "src/schemas/thresholds-schema.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "mergeThresholds",
      "filePath": "src/schemas/thresholds-schema.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "calculateRiskScore",
      "filePath": "src/schemas/cuj-schemas.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate CRITICAL risk for high probability and high impact",
          "asserts": [
            "expect(result.probability).toBeGreaterThan(80)",
            "expect(result.impact).toBeGreaterThan(80)",
            "expect(result.score).toBeGreaterThan(80)",
            "expect(result.level).toBe(CRITICAL)",
            "expect(result.file).toBe(src/auth/login.ts)",
            "expect(result.reasons.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW risk for low probability and low impact",
          "asserts": [
            "expect(result.probability).toBeLessThan(20)",
            "expect(result.impact).toBeLessThan(20)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate HIGH risk for medium probability and high impact",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(40)",
            "expect(result.score).toBeLessThan(80)",
            "expect(result.level).toBe(MEDIUM)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate LOW-MEDIUM risk for balanced factors",
          "asserts": [
            "expect(result.score).toBeGreaterThanOrEqual(10)",
            "expect(result.score).toBeLessThan(40)",
            "expect(result.level).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should generate descriptive reasons",
          "asserts": [
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should handle zero test coverage correctly",
          "asserts": [
            "expect(result.impact).toBeGreaterThan(30)",
            "expect(result.reasons.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high frequency for sensitive files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)",
            "expect(estimateChangeFrequency()).toBeGreaterThan(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low frequency for config files",
          "asserts": [
            "expect(estimateChangeFrequency()).toBeLessThan(40)",
            "expect(estimateChangeFrequency()).toBeLessThan(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium frequency for regular files",
          "asserts": [
            "expect(freq).toBeGreaterThanOrEqual(40)",
            "expect(freq).toBeLessThanOrEqual(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate high complexity for parsing/analysis files",
          "asserts": [
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)",
            "expect(estimateComplexity()).toBeGreaterThan(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate medium complexity for API files",
          "asserts": [
            "expect(complexity).toBeGreaterThanOrEqual(50)",
            "expect(complexity).toBeLessThanOrEqual(70)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should estimate low complexity for config files",
          "asserts": [
            "expect(estimateComplexity()).toBeLessThan(30)",
            "expect(estimateComplexity()).toBeLessThan(30)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should count conditionals from file content",
          "asserts": [
            "expect(complexity).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should return 0 for files without bug tracking",
          "asserts": [
            "expect(estimateRecentBugs()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)",
            "expect(isUserFacing()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should detect non-user-facing files",
          "asserts": [
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)",
            "expect(isUserFacing()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should calculate and sort multiple scores",
          "asserts": [
            "expect(scores).toHaveLength(3)",
            "expect(scores.?.file).toBe(src/high-risk.ts)",
            "expect(scores.?.file).toBe(src/low-risk.ts)",
            "expect(scores.?.score).toBeGreaterThan",
            "expect(scores.?.score).toBeGreaterThan"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/risk-calculator.test.ts",
          "title": "should group scores by risk level",
          "asserts": [
            "expect(grouped.CRITICAL).toBeDefined",
            "expect(grouped.CRITICAL.length).toBeGreaterThanOrEqual(2)",
            "expect(grouped.LOW).toBeDefined",
            "expect(Object.keys().length).toBeGreaterThanOrEqual(2)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(grouped.CRITICAL).toBeDefined - verificar valor espec칤fico",
            "expect(grouped.LOW).toBeDefined - verificar valor espec칤fico"
          ]
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "calculateContractPriority",
      "filePath": "src/schemas/contract-schemas.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "runPytest",
      "filePath": "src/runners/python-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling"
      ]
    },
    {
      "name": "runUnittest",
      "filePath": "src/runners/python-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "isPytestAvailable",
      "filePath": "src/runners/python-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "isCoverageAvailable",
      "filePath": "src/runners/python-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "isPytestCovAvailable",
      "filePath": "src/runners/python-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "getInstallCommands",
      "filePath": "src/runners/python-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "runStryker",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling"
      ]
    },
    {
      "name": "runMutmut",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling"
      ]
    },
    {
      "name": "runGoMutesting",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling"
      ]
    },
    {
      "name": "isStrykerAvailable",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "isMutmutAvailable",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "isGoMutestingAvailable",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "detectMutationTool",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "runMutationAuto",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "getMutationInstallCommands",
      "filePath": "src/runners/mutation-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "runMavenTests",
      "filePath": "src/runners/java-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "runGradleTests",
      "filePath": "src/runners/java-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "runJavaTestsAuto",
      "filePath": "src/runners/java-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling"
      ]
    },
    {
      "name": "runGoTest",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游댮 Fun칞칚o lan칞a erros mas n칚o h치 testes de error handling"
      ]
    },
    {
      "name": "runGoUnitTests",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "runGoIntegrationTests",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "runGoE2ETests",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "isGoAvailable",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "isGoProject",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "getGoVersion",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "listGoPackages",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "listGoTestFiles",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "downloadGoDeps",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "isGotestsumAvailable",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "runGoTestWithGotestsum",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "getInstallCommands",
      "filePath": "src/runners/go-runner.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "parseTestFile",
      "filePath": "src/parsers/test-ast-parser.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "calculateAssertStrength",
      "filePath": "src/parsers/test-ast-parser.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "parsePITXml",
      "filePath": "src/parsers/pit-parser.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parsePITStdout",
      "filePath": "src/parsers/pit-parser.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)"
      ]
    },
    {
      "name": "pitToMutationResult",
      "filePath": "src/parsers/pit-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "parsePITReport",
      "filePath": "src/parsers/pit-parser.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseLCOV",
      "filePath": "src/parsers/lcov-line-parser.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve parsear relat칩rio LCOV corretamente",
          "asserts": [
            "expect(result.files.size).toBe(2)",
            "expect(result.totalLines).toBe(8)",
            "expect(result.coveredLines).toBe(6)",
            "expect(result.coverage).toBeCloseTo(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve extrair linhas cobertas corretamente",
          "asserts": [
            "expect(mathFile).toBeDefined",
            "expect(unknown.lines).toHaveLength(5)",
            "expect(unknown.totalLines).toBe(5)",
            "expect(unknown.coveredLines).toBe(4)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(mathFile).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas n칚o cobertas",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas cobertas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com LCOV vazio",
          "asserts": [
            "expect(result.files.size).toBe(0)",
            "expect(result.totalLines).toBe(0)",
            "expect(result.coverage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha n칚o coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para linha inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage exato para linhas espec칤ficas",
          "asserts": [
            "expect(result.total).toBe(4)",
            "expect(result.covered).toBe(4)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage com linhas n칚o cobertas",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para arquivo inexistente",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para lista de linhas vazia",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo src/",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo ./",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve converter backslash para slash",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com m칰ltiplos prefixos",
          "asserts": [
            "expect(normalizeFilePath()).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match exato",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match normalizado",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por basename",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar null para arquivo inexistente",
          "asserts": [
            "expect(found).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage preciso para diff simulado",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 0% para arquivo sem coverage",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 100% para linhas totalmente cobertas",
          "asserts": [
            "expect(result.total).toBe(2)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  1 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "isLineCovered",
      "filePath": "src/parsers/lcov-line-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve parsear relat칩rio LCOV corretamente",
          "asserts": [
            "expect(result.files.size).toBe(2)",
            "expect(result.totalLines).toBe(8)",
            "expect(result.coveredLines).toBe(6)",
            "expect(result.coverage).toBeCloseTo(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve extrair linhas cobertas corretamente",
          "asserts": [
            "expect(mathFile).toBeDefined",
            "expect(unknown.lines).toHaveLength(5)",
            "expect(unknown.totalLines).toBe(5)",
            "expect(unknown.coveredLines).toBe(4)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(mathFile).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas n칚o cobertas",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas cobertas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com LCOV vazio",
          "asserts": [
            "expect(result.files.size).toBe(0)",
            "expect(result.totalLines).toBe(0)",
            "expect(result.coverage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha n칚o coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para linha inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage exato para linhas espec칤ficas",
          "asserts": [
            "expect(result.total).toBe(4)",
            "expect(result.covered).toBe(4)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage com linhas n칚o cobertas",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para arquivo inexistente",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para lista de linhas vazia",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo src/",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo ./",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve converter backslash para slash",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com m칰ltiplos prefixos",
          "asserts": [
            "expect(normalizeFilePath()).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match exato",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match normalizado",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por basename",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar null para arquivo inexistente",
          "asserts": [
            "expect(found).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage preciso para diff simulado",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 0% para arquivo sem coverage",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 100% para linhas totalmente cobertas",
          "asserts": [
            "expect(result.total).toBe(2)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  1 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "calculateLineCoverage",
      "filePath": "src/parsers/lcov-line-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve parsear relat칩rio LCOV corretamente",
          "asserts": [
            "expect(result.files.size).toBe(2)",
            "expect(result.totalLines).toBe(8)",
            "expect(result.coveredLines).toBe(6)",
            "expect(result.coverage).toBeCloseTo(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve extrair linhas cobertas corretamente",
          "asserts": [
            "expect(mathFile).toBeDefined",
            "expect(unknown.lines).toHaveLength(5)",
            "expect(unknown.totalLines).toBe(5)",
            "expect(unknown.coveredLines).toBe(4)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(mathFile).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas n칚o cobertas",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas cobertas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com LCOV vazio",
          "asserts": [
            "expect(result.files.size).toBe(0)",
            "expect(result.totalLines).toBe(0)",
            "expect(result.coverage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha n칚o coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para linha inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage exato para linhas espec칤ficas",
          "asserts": [
            "expect(result.total).toBe(4)",
            "expect(result.covered).toBe(4)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage com linhas n칚o cobertas",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para arquivo inexistente",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para lista de linhas vazia",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo src/",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo ./",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve converter backslash para slash",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com m칰ltiplos prefixos",
          "asserts": [
            "expect(normalizeFilePath()).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match exato",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match normalizado",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por basename",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar null para arquivo inexistente",
          "asserts": [
            "expect(found).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage preciso para diff simulado",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 0% para arquivo sem coverage",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 100% para linhas totalmente cobertas",
          "asserts": [
            "expect(result.total).toBe(2)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  1 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "findLCOVFile",
      "filePath": "src/parsers/lcov-line-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "normalizeFilePath",
      "filePath": "src/parsers/lcov-line-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve parsear relat칩rio LCOV corretamente",
          "asserts": [
            "expect(result.files.size).toBe(2)",
            "expect(result.totalLines).toBe(8)",
            "expect(result.coveredLines).toBe(6)",
            "expect(result.coverage).toBeCloseTo(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve extrair linhas cobertas corretamente",
          "asserts": [
            "expect(mathFile).toBeDefined",
            "expect(unknown.lines).toHaveLength(5)",
            "expect(unknown.totalLines).toBe(5)",
            "expect(unknown.coveredLines).toBe(4)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(mathFile).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas n칚o cobertas",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas cobertas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com LCOV vazio",
          "asserts": [
            "expect(result.files.size).toBe(0)",
            "expect(result.totalLines).toBe(0)",
            "expect(result.coverage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha n칚o coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para linha inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage exato para linhas espec칤ficas",
          "asserts": [
            "expect(result.total).toBe(4)",
            "expect(result.covered).toBe(4)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage com linhas n칚o cobertas",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para arquivo inexistente",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para lista de linhas vazia",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo src/",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo ./",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve converter backslash para slash",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com m칰ltiplos prefixos",
          "asserts": [
            "expect(normalizeFilePath()).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match exato",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match normalizado",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por basename",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar null para arquivo inexistente",
          "asserts": [
            "expect(found).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage preciso para diff simulado",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 0% para arquivo sem coverage",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 100% para linhas totalmente cobertas",
          "asserts": [
            "expect(result.total).toBe(2)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  1 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "findFileInReport",
      "filePath": "src/parsers/lcov-line-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve parsear relat칩rio LCOV corretamente",
          "asserts": [
            "expect(result.files.size).toBe(2)",
            "expect(result.totalLines).toBe(8)",
            "expect(result.coveredLines).toBe(6)",
            "expect(result.coverage).toBeCloseTo(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve extrair linhas cobertas corretamente",
          "asserts": [
            "expect(mathFile).toBeDefined",
            "expect(unknown.lines).toHaveLength(5)",
            "expect(unknown.totalLines).toBe(5)",
            "expect(unknown.coveredLines).toBe(4)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(mathFile).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas n칚o cobertas",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas cobertas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com LCOV vazio",
          "asserts": [
            "expect(result.files.size).toBe(0)",
            "expect(result.totalLines).toBe(0)",
            "expect(result.coverage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha n칚o coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para linha inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage exato para linhas espec칤ficas",
          "asserts": [
            "expect(result.total).toBe(4)",
            "expect(result.covered).toBe(4)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage com linhas n칚o cobertas",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para arquivo inexistente",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para lista de linhas vazia",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo src/",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo ./",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve converter backslash para slash",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com m칰ltiplos prefixos",
          "asserts": [
            "expect(normalizeFilePath()).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match exato",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match normalizado",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por basename",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar null para arquivo inexistente",
          "asserts": [
            "expect(found).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage preciso para diff simulado",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 0% para arquivo sem coverage",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 100% para linhas totalmente cobertas",
          "asserts": [
            "expect(result.total).toBe(2)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  1 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "parseJaCoCoDetailedXml",
      "filePath": "src/parsers/jacoco-detailed-parser.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "isJaCoCoLineCovered",
      "filePath": "src/parsers/jacoco-detailed-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "calculateJaCoCoLineCoverage",
      "filePath": "src/parsers/jacoco-detailed-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "findJaCoCoFile",
      "filePath": "src/parsers/jacoco-detailed-parser.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "parseCoberturaXml",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseJaCoCoXml",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseLcov",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseGoCoverageOut",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseCloverXml",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseSimpleCovJson",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "CRITICAL",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseIstanbulJson",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseCoverageAuto",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "detectCoverageFormat",
      "filePath": "src/parsers/coverage-parsers.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "detectLanguage",
      "filePath": "src/engine/index.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve detectar adapter baseado no m칠todo detect",
          "asserts": [
            "expect(result).toBe(mockAdapter2)",
            "expect(unknown).toBe(typescript)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve retornar null se nenhum adapter detectar",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve lan칞ar erro se linguagem n칚o detectada",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.errors.length).toBeGreaterThan(0)",
            "expect(result.errors.?).toContain(n칚o detectada)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar pipeline com adapter v치lido (stub)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.execution.stepsExecuted).toContain(functions)",
            "expect(result.execution.stepsExecuted).toContain(tests)",
            "expect(result.execution.stepsExecuted).toContain(cases)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve pular mutation em perfil ci-fast",
          "asserts": [
            "expect(result.execution.stepsSkipped).toContain(mutation)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar mutation em perfil ci-strict",
          "asserts": [
            "expect(result.execution.stepsExecuted).toContain(mutation)",
            "expect(mockAdapter.capabilities.mutation).toHaveBeenCalled",
            "expect(result.report.metrics.mutationScore).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve calcular quality score corretamente",
          "asserts": [
            "expect(result.report.metrics.qualityScore).toBeGreaterThan(0)",
            "expect(result.report.metrics.grade).toMatch(/[ABCDF]/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  12 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "runPipeline",
      "filePath": "src/engine/index.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve detectar adapter baseado no m칠todo detect",
          "asserts": [
            "expect(result).toBe(mockAdapter2)",
            "expect(unknown).toBe(typescript)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve retornar null se nenhum adapter detectar",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve lan칞ar erro se linguagem n칚o detectada",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.errors.length).toBeGreaterThan(0)",
            "expect(result.errors.?).toContain(n칚o detectada)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar pipeline com adapter v치lido (stub)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.execution.stepsExecuted).toContain(functions)",
            "expect(result.execution.stepsExecuted).toContain(tests)",
            "expect(result.execution.stepsExecuted).toContain(cases)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve pular mutation em perfil ci-fast",
          "asserts": [
            "expect(result.execution.stepsSkipped).toContain(mutation)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar mutation em perfil ci-strict",
          "asserts": [
            "expect(result.execution.stepsExecuted).toContain(mutation)",
            "expect(mockAdapter.capabilities.mutation).toHaveBeenCalled",
            "expect(result.report.metrics.mutationScore).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve calcular quality score corretamente",
          "asserts": [
            "expect(result.report.metrics.qualityScore).toBeGreaterThan(0)",
            "expect(result.report.metrics.grade).toMatch(/[ABCDF]/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "wrapAdapterForEngine",
      "filePath": "src/engine/adapter-to-engine.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "getAllEngineAdapters",
      "filePath": "src/engine/adapter-to-engine.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "getEngineAdapter",
      "filePath": "src/engine/adapter-to-engine.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "findExistingTests",
      "filePath": "src/detectors/tests.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve detectar arquivos *.test.ts com vitest",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.unit.?.framework).toBe(vitest)",
            "expect(coverage.unit.?.testCount).toBe(2)",
            "expect(coverage.summary.unitCount).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "should work",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "should also work",
          "asserts": [
            "expect(unknown).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve detectar arquivos *.spec.ts com jest",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.unit.?.framework).toBe(jest)",
            "expect(coverage.unit.?.testCount).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "creates instance",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "works correctly",
          "asserts": [
            "expect(unknown).toBe(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve detectar arquivos *Test.ts com mocha",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.unit.?.framework).toBe(mocha)",
            "expect(coverage.unit.?.testCount).toBe(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "should work",
          "asserts": [
            "expect(true).to.be.true",
            ".to.be.true"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve detectar testes Playwright em tests/",
          "asserts": [
            "expect(coverage.e2e).toHaveLength(1)",
            "expect(coverage.e2e.?.framework).toBe(playwright)",
            "expect(coverage.e2e.?.testCount).toBe(2)",
            "expect(coverage.summary.e2eCount).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "user can login",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "user can logout",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve separar testes por camada corretamente",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.integration).toHaveLength(1)",
            "expect(coverage.e2e).toHaveLength(1)",
            "expect(coverage.summary.totalTests).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "unit test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "integration test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "e2e test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve contar n칰mero de test cases por arquivo",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.unit.?.testCount).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 4",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 5",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve retornar estrutura vazia se n칚o houver testes",
          "asserts": [
            "expect(coverage.unit).toEqual([...])",
            "expect(coverage.integration).toEqual([...])",
            "expect(coverage.e2e).toEqual([...])",
            "expect(coverage.summary.totalTests).toBe(0)",
            "expect(coverage.summary.ratio).toBe(0:0:0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve calcular ratio da pir칙mide corretamente",
          "asserts": [
            "expect(coverage.summary.unitCount).toBe(7)",
            "expect(coverage.summary.integrationCount).toBe(2)",
            "expect(coverage.summary.e2eCount).toBe(1)",
            "expect(coverage.summary.ratio).toBe(70:20:10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "4",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "5",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "6",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "7",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve marcar como saud치vel se propor칞칫es est칚o corretas",
          "asserts": [
            "expect(result.healthy).toBe(true)",
            "expect(result.issues).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve alertar se E2E > unit (pir칙mide invertida)",
          "asserts": [
            "expect(result.healthy).toBe(false)",
            "expect(result.issues).toContain(丘멆잺 Pir칙mide INVERTIDA: mais testes E2E que unit치rios)",
            "expect(result.recommendations).toContain(Priorize cria칞칚o de testes unit치rios para balancear a pir칙mide)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve alertar se unit < 50%",
          "asserts": [
            "expect(result.healthy).toBe(false)",
            "expect(result.issues.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve alertar se n칚o houver testes",
          "asserts": [
            "expect(result.healthy).toBe(false)",
            "expect(result.issues).toContain(Nenhum teste detectado no reposit칩rio)",
            "expect(result.recommendations).toContain(Comece criando testes unit치rios para fun칞칫es cr칤ticas)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "isPyramidHealthy",
      "filePath": "src/detectors/tests.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve detectar arquivos *.test.ts com vitest",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.unit.?.framework).toBe(vitest)",
            "expect(coverage.unit.?.testCount).toBe(2)",
            "expect(coverage.summary.unitCount).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "should work",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "should also work",
          "asserts": [
            "expect(unknown).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve detectar arquivos *.spec.ts com jest",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.unit.?.framework).toBe(jest)",
            "expect(coverage.unit.?.testCount).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "creates instance",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "works correctly",
          "asserts": [
            "expect(unknown).toBe(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve detectar arquivos *Test.ts com mocha",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.unit.?.framework).toBe(mocha)",
            "expect(coverage.unit.?.testCount).toBe(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "should work",
          "asserts": [
            "expect(true).to.be.true",
            ".to.be.true"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve detectar testes Playwright em tests/",
          "asserts": [
            "expect(coverage.e2e).toHaveLength(1)",
            "expect(coverage.e2e.?.framework).toBe(playwright)",
            "expect(coverage.e2e.?.testCount).toBe(2)",
            "expect(coverage.summary.e2eCount).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "user can login",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "user can logout",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve separar testes por camada corretamente",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.integration).toHaveLength(1)",
            "expect(coverage.e2e).toHaveLength(1)",
            "expect(coverage.summary.totalTests).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "unit test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "integration test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "e2e test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve contar n칰mero de test cases por arquivo",
          "asserts": [
            "expect(coverage.unit).toHaveLength(1)",
            "expect(coverage.unit.?.testCount).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 4",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "test 5",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve retornar estrutura vazia se n칚o houver testes",
          "asserts": [
            "expect(coverage.unit).toEqual([...])",
            "expect(coverage.integration).toEqual([...])",
            "expect(coverage.e2e).toEqual([...])",
            "expect(coverage.summary.totalTests).toBe(0)",
            "expect(coverage.summary.ratio).toBe(0:0:0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve calcular ratio da pir칙mide corretamente",
          "asserts": [
            "expect(coverage.summary.unitCount).toBe(7)",
            "expect(coverage.summary.integrationCount).toBe(2)",
            "expect(coverage.summary.e2eCount).toBe(1)",
            "expect(coverage.summary.ratio).toBe(70:20:10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "3",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "4",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "5",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "6",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "7",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "2",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "1",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve marcar como saud치vel se propor칞칫es est칚o corretas",
          "asserts": [
            "expect(result.healthy).toBe(true)",
            "expect(result.issues).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve alertar se E2E > unit (pir칙mide invertida)",
          "asserts": [
            "expect(result.healthy).toBe(false)",
            "expect(result.issues).toContain(丘멆잺 Pir칙mide INVERTIDA: mais testes E2E que unit치rios)",
            "expect(result.recommendations).toContain(Priorize cria칞칚o de testes unit치rios para balancear a pir칙mide)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve alertar se unit < 50%",
          "asserts": [
            "expect(result.healthy).toBe(false)",
            "expect(result.issues.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/tests.test.ts",
          "title": "deve alertar se n칚o houver testes",
          "asserts": [
            "expect(result.healthy).toBe(false)",
            "expect(result.issues).toContain(Nenhum teste detectado no reposit칩rio)",
            "expect(result.recommendations).toContain(Comece criando testes unit치rios para fun칞칫es cr칤ticas)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "findCoverageReports",
      "filePath": "src/detectors/tests.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "detectTestFramework",
      "filePath": "src/detectors/test-framework.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "detectAllTestFrameworks",
      "filePath": "src/detectors/test-framework.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "findNextRoutes",
      "filePath": "src/detectors/next.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve detectar rotas no formato app/page.tsx",
          "asserts": [
            "expect(routes).toContain(/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve detectar rotas no formato pages/index.tsx",
          "asserts": [
            "expect(routes).toContain(/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve detectar rotas din칙micas [id]/page.tsx",
          "asserts": [
            "expect(routes).toContain(/users/[id])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve detectar rotas catch-all [...slug]/page.tsx",
          "asserts": [
            "expect(routes).toContain(/docs/[...slug])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve ignorar route groups (app)/page.tsx",
          "asserts": [
            "expect(routes).toContain(/(marketing)/about)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve detectar API routes em app/api/route.ts",
          "asserts": [
            "expect(routes).not.toContain('/api/users')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve retornar array vazio se diret칩rio n칚o existir",
          "asserts": [
            "expect(routes).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve retornar todas as rotas encontradas",
          "asserts": [
            "expect(routes).toHaveLength(3)",
            "expect(routes).toContain(/)",
            "expect(routes).toContain(/about)",
            "expect(routes).toContain(/contact)",
            "expect(routes).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve converter rotas din칙micas pages/[id].tsx para :id",
          "asserts": [
            "expect(routes).toContain(/users/:id)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/next.test.ts",
          "title": "deve remover rotas duplicadas",
          "asserts": [
            "expect(homeRoutes).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "detectLanguage",
      "filePath": "src/detectors/language.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve detectar adapter baseado no m칠todo detect",
          "asserts": [
            "expect(result).toBe(mockAdapter2)",
            "expect(unknown).toBe(typescript)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve retornar null se nenhum adapter detectar",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve lan칞ar erro se linguagem n칚o detectada",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.errors.length).toBeGreaterThan(0)",
            "expect(result.errors.?).toContain(n칚o detectada)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar pipeline com adapter v치lido (stub)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.execution.stepsExecuted).toContain(functions)",
            "expect(result.execution.stepsExecuted).toContain(tests)",
            "expect(result.execution.stepsExecuted).toContain(cases)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve pular mutation em perfil ci-fast",
          "asserts": [
            "expect(result.execution.stepsSkipped).toContain(mutation)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar mutation em perfil ci-strict",
          "asserts": [
            "expect(result.execution.stepsExecuted).toContain(mutation)",
            "expect(mockAdapter.capabilities.mutation).toHaveBeenCalled",
            "expect(result.report.metrics.mutationScore).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve calcular quality score corretamente",
          "asserts": [
            "expect(result.report.metrics.qualityScore).toBeGreaterThan(0)",
            "expect(result.report.metrics.grade).toMatch(/[ABCDF]/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  12 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "getTestFileExtension",
      "filePath": "src/detectors/language.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate valid unit test template",
          "asserts": [
            "expect(result).toContain(import { describe, it, expect } from 'vitest')",
            "expect(result).toContain(import { calculateTotal } from './utils/math.js')",
            "expect(result).toContain(describe('calculateTotal')",
            "expect(result).toContain(should work correctly with valid input)",
            "expect(result).toContain(should handle errors appropriately)",
            "expect(result).toContain(should handle edge cases)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate integration test template",
          "asserts": [
            "expect(result).toContain(supertest)",
            "expect(result).toContain(UserService Integration Tests)",
            "expect(result).toContain(beforeEach)",
            "expect(result).toContain(afterEach)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate E2E test template",
          "asserts": [
            "expect(result).toContain(@playwright/test)",
            "expect(result).toContain(LoginFlow)",
            "expect(result).toContain(should complete LoginFlow flow)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test file extension",
          "asserts": [
            "expect(adapter.getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test patterns",
          "asserts": [
            "expect(patterns).toContain(**/*.test.{ts,tsx,js,jsx})",
            "expect(patterns).toContain(**/__tests__/**/*.{ts,tsx,js,jsx})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test command",
          "asserts": [
            "expect(adapter.getTestCommand()).toBe(npm test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct coverage command",
          "asserts": [
            "expect(adapter.getCoverageCommand()).toBe(npm run test:coverage)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate valid unit test template",
          "asserts": [
            "expect(result).toContain(import pytest)",
            "expect(result).toContain(from src.utils.math import calculate_total)",
            "expect(result).toContain(class TestCalculateTotal:)",
            "expect(result).toContain(def test_calculate_total_with_valid_input)",
            "expect(result).toContain(def test_calculate_total_handles_errors)",
            "expect(result).toContain(@pytest.mark.parametrize)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate integration test template",
          "asserts": [
            "expect(result).toContain(from fastapi.testclient import TestClient)",
            "expect(result).toContain(class TestUserServiceIntegration:)",
            "expect(result).toContain(@pytest.fixture(autouse=True))",
            "expect(result).toContain(def setup_teardown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate E2E test template",
          "asserts": [
            "expect(result).toContain(from playwright.sync_api import Page)",
            "expect(result).toContain(class TestLoginFlowE2E:)",
            "expect(result).toContain(def test_complete_flow)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test file extension",
          "asserts": [
            "expect(adapter.getTestFileExtension()).toBe(_test.py)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test patterns",
          "asserts": [
            "expect(patterns).toContain(**/test_*.py)",
            "expect(patterns).toContain(**/*_test.py)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test command",
          "asserts": [
            "expect(adapter.getTestCommand()).toBe(pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct coverage command",
          "asserts": [
            "expect(adapter.getCoverageCommand()).toBe(pytest --cov=. --cov-report=json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return PythonAdapter for Python project",
          "asserts": [
            "expect(adapter.language).toBe(python)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return TypeScriptAdapter for TypeScript project",
          "asserts": [
            "expect(adapter.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should create TypeScriptAdapter",
          "asserts": [
            "expect(adapter.language).toBe(typescript)",
            "expect(adapter).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(adapter).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should create PythonAdapter",
          "asserts": [
            "expect(adapter.language).toBe(python)",
            "expect(adapter).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(adapter).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should throw for unknown language",
          "asserts": [
            "expect(adapter).toBeNull"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "getTestTemplate",
      "filePath": "src/detectors/language.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": []
    },
    {
      "name": "findExpressRoutes",
      "filePath": "src/detectors/express.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar app.get(",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar app.post(",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar router.put, router.delete, router.patch",
          "asserts": [
            "expect(endpoints).toHaveLength(3)",
            "expect(endpoints.map()).toEqual([...])",
            "expect(endpoints.map()).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar Router() com routes",
          "asserts": [
            "expect(endpoints).toHaveLength(2)",
            "expect(endpoints.?).toMatchObject({...})",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar routes com middlewares",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar rotas com aspas simples, duplas e template literals",
          "asserts": [
            "expect(endpoints).toHaveLength(3)",
            "expect(endpoints.map()).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar server.get (Fastify)",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar router.options",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve parsear openapi.yml",
          "asserts": [
            "expect(specs).toHaveLength(1)",
            "expect(specs.?).toBe(openapi.yml)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve parsear openapi.json",
          "asserts": [
            "expect(specs).toHaveLength(1)",
            "expect(specs.?).toBe(openapi.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve extrair todos os endpoints de paths",
          "asserts": [
            "expect(specs).toHaveLength(2)",
            "expect(specs).toContain(openapi.yml)",
            "expect(specs).toContain(docs/swagger.yml)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve retornar array vazio se spec n칚o existir",
          "asserts": [
            "expect(specs).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve lidar com spec malformado",
          "asserts": [
            "expect(specs).toHaveLength(1)",
            "expect(specs.?).toBe(openapi.yml)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar swagger.json e swagger.yml",
          "asserts": [
            "expect(specs).toHaveLength(2)",
            "expect(specs).toContain(swagger.json)",
            "expect(specs).toContain(swagger.yml)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve remover specs duplicados",
          "asserts": [
            "expect(specs.length).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar arquivos .yaml al칠m de .yml",
          "asserts": [
            "expect(specs).toHaveLength(1)",
            "expect(specs.?).toBe(openapi.yaml)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  8 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "findOpenAPI",
      "filePath": "src/detectors/express.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar app.get(",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar app.post(",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar router.put, router.delete, router.patch",
          "asserts": [
            "expect(endpoints).toHaveLength(3)",
            "expect(endpoints.map()).toEqual([...])",
            "expect(endpoints.map()).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar Router() com routes",
          "asserts": [
            "expect(endpoints).toHaveLength(2)",
            "expect(endpoints.?).toMatchObject({...})",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar routes com middlewares",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar rotas com aspas simples, duplas e template literals",
          "asserts": [
            "expect(endpoints).toHaveLength(3)",
            "expect(endpoints.map()).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar server.get (Fastify)",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar router.options",
          "asserts": [
            "expect(endpoints).toHaveLength(1)",
            "expect(endpoints.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve parsear openapi.yml",
          "asserts": [
            "expect(specs).toHaveLength(1)",
            "expect(specs.?).toBe(openapi.yml)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve parsear openapi.json",
          "asserts": [
            "expect(specs).toHaveLength(1)",
            "expect(specs.?).toBe(openapi.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve extrair todos os endpoints de paths",
          "asserts": [
            "expect(specs).toHaveLength(2)",
            "expect(specs).toContain(openapi.yml)",
            "expect(specs).toContain(docs/swagger.yml)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve retornar array vazio se spec n칚o existir",
          "asserts": [
            "expect(specs).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve lidar com spec malformado",
          "asserts": [
            "expect(specs).toHaveLength(1)",
            "expect(specs.?).toBe(openapi.yml)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar swagger.json e swagger.yml",
          "asserts": [
            "expect(specs).toHaveLength(2)",
            "expect(specs).toContain(swagger.json)",
            "expect(specs).toContain(swagger.yml)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve remover specs duplicados",
          "asserts": [
            "expect(specs.length).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/express.test.ts",
          "title": "deve detectar arquivos .yaml al칠m de .yml",
          "asserts": [
            "expect(specs).toHaveLength(1)",
            "expect(specs.?).toBe(openapi.yaml)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  8 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "findEvents",
      "filePath": "src/detectors/events.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": false,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar producer.send() com t칩picos Kafka",
          "asserts": [
            "expect(events).toContain(kafka:user-created)",
            "expect(events).toContain(kafka:order-placed)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar consumer.subscribe() e consumer.run()",
          "asserts": [
            "expect(events).toContain(kafka:payment-processed)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar sqs.sendMessage() com queue URL",
          "asserts": [
            "expect(events).toContain(aws:my-queue)",
            "expect(events).toContain(aws:notifications)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar emit() com event names",
          "asserts": [
            "expect(events).toContain(event:user:login)",
            "expect(events).toContain(event:user:logout)",
            "expect(events).toContain(event:data:updated)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "user:login",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "user:logout",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "data:updated",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve retornar array vazio se n칚o houver eventos",
          "asserts": [
            "expect(events).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve consolidar todos os eventos encontrados",
          "asserts": [
            "expect(events).toHaveLength(3)",
            "expect(events).toContain(kafka:topic-1)",
            "expect(events).toContain(aws:queue-1)",
            "expect(events).toContain(event:event-1)",
            "expect(events).toEqual"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "event-1",
          "asserts": [
            "expect(events.filter()).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve remover eventos duplicados",
          "asserts": [
            "expect(events.filter()).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar SNS subscribe com TopicArn",
          "asserts": [
            "expect(events).toContain(aws:my-topic)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar eventos com aspas simples, duplas e template literals",
          "asserts": [
            "expect(events).toContain(event:single-quote)",
            "expect(events).toContain(event:double-quote)",
            "expect(events).toContain(event:template-literal)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "single-quote",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "double-quote",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "verifyJavaPactContracts",
      "filePath": "src/contracts/pact-java-verifier.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "generatePactReport",
      "filePath": "src/contracts/pact-java-verifier.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)"
      ]
    },
    {
      "name": "getPactAdapter",
      "filePath": "src/adapters/pact-adapter.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "extractServiceName",
      "filePath": "src/adapters/pact-adapter.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "detectHttpIntegrations",
      "filePath": "src/adapters/pact-adapter.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "detectLanguage",
      "filePath": "src/adapters/adapter-factory.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve detectar adapter baseado no m칠todo detect",
          "asserts": [
            "expect(result).toBe(mockAdapter2)",
            "expect(unknown).toBe(typescript)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve retornar null se nenhum adapter detectar",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve lan칞ar erro se linguagem n칚o detectada",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.errors.length).toBeGreaterThan(0)",
            "expect(result.errors.?).toContain(n칚o detectada)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar pipeline com adapter v치lido (stub)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.execution.stepsExecuted).toContain(functions)",
            "expect(result.execution.stepsExecuted).toContain(tests)",
            "expect(result.execution.stepsExecuted).toContain(cases)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve pular mutation em perfil ci-fast",
          "asserts": [
            "expect(result.execution.stepsSkipped).toContain(mutation)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar mutation em perfil ci-strict",
          "asserts": [
            "expect(result.execution.stepsExecuted).toContain(mutation)",
            "expect(mockAdapter.capabilities.mutation).toHaveBeenCalled",
            "expect(result.report.metrics.mutationScore).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve calcular quality score corretamente",
          "asserts": [
            "expect(result.report.metrics.qualityScore).toBeGreaterThan(0)",
            "expect(result.report.metrics.grade).toMatch(/[ABCDF]/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve retornar erro se nenhum servi칞o for detectado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No services or integrations detected)",
            "expect(result.total_contracts).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar contratos quando endpoints s칚o detectados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar config TypeScript para projeto TypeScript",
          "asserts": [
            "expect(result.config_path).toContain(pact.config.ts)",
            "expect(configCalls.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar consumer tests para cada contrato",
          "asserts": [
            "expect(result.consumer_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar provider tests",
          "asserts": [
            "expect(result.provider_tests).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(unknown.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve incluir broker_url no config se fornecido",
          "asserts": [
            "expect(configContent).toContain(brokerUrl)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve gerar recomenda칞칫es apropriadas",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve detectar Python e gerar config Python",
          "asserts": [
            "expect(result.config_path).toContain(pact_config.py)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-contracts-pact.test.ts",
          "title": "deve salvar catalog de contratos",
          "asserts": [
            "expect(result.catalog_path).toBeDefined",
            "expect(result.catalog_path).toContain(contract-catalog.json)",
            "expect(catalogCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Express b치sicas",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)",
            "expect(result.output).toContain(cuj-catalog.json)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/auth como critical",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/checkout como critical",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(critical)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve classificar /api/search como high",
          "asserts": [
            "expect(catalogData.cujs.?.criticality).toBe(high)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve degradar /api/admin de critical para high",
          "asserts": [
            "expect(catalogData.cujs[0].criticality).not.toBe('critical')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve catalogar rotas Next.js",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve extrair features do README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve mesclar endpoints duplicados no mesmo CUJ",
          "asserts": [
            "expect(catalogData.cujs).toHaveLength(1)",
            "expect(catalogData.cujs.?.id).toBe(auth-api)",
            "expect(catalogData.cujs.?.endpoints).toHaveLength(3)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto TypeScript",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(catalogData.cujs).toHaveLength(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Python",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve detectar projeto Java",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se language detection falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Language detection failed)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve retornar ok=false se writeFile falhar",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toContain(Disk full)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/catalog-cujs.test.ts",
          "title": "deve combinar rotas + README",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBe(2)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  12 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "createAdapter",
      "filePath": "src/adapters/adapter-factory.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": false,
        "error": true,
        "sideEffects": false
      },
      "tests": [
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate valid unit test template",
          "asserts": [
            "expect(result).toContain(import { describe, it, expect } from 'vitest')",
            "expect(result).toContain(import { calculateTotal } from './utils/math.js')",
            "expect(result).toContain(describe('calculateTotal')",
            "expect(result).toContain(should work correctly with valid input)",
            "expect(result).toContain(should handle errors appropriately)",
            "expect(result).toContain(should handle edge cases)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate integration test template",
          "asserts": [
            "expect(result).toContain(supertest)",
            "expect(result).toContain(UserService Integration Tests)",
            "expect(result).toContain(beforeEach)",
            "expect(result).toContain(afterEach)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate E2E test template",
          "asserts": [
            "expect(result).toContain(@playwright/test)",
            "expect(result).toContain(LoginFlow)",
            "expect(result).toContain(should complete LoginFlow flow)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test file extension",
          "asserts": [
            "expect(adapter.getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test patterns",
          "asserts": [
            "expect(patterns).toContain(**/*.test.{ts,tsx,js,jsx})",
            "expect(patterns).toContain(**/__tests__/**/*.{ts,tsx,js,jsx})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test command",
          "asserts": [
            "expect(adapter.getTestCommand()).toBe(npm test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct coverage command",
          "asserts": [
            "expect(adapter.getCoverageCommand()).toBe(npm run test:coverage)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate valid unit test template",
          "asserts": [
            "expect(result).toContain(import pytest)",
            "expect(result).toContain(from src.utils.math import calculate_total)",
            "expect(result).toContain(class TestCalculateTotal:)",
            "expect(result).toContain(def test_calculate_total_with_valid_input)",
            "expect(result).toContain(def test_calculate_total_handles_errors)",
            "expect(result).toContain(@pytest.mark.parametrize)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate integration test template",
          "asserts": [
            "expect(result).toContain(from fastapi.testclient import TestClient)",
            "expect(result).toContain(class TestUserServiceIntegration:)",
            "expect(result).toContain(@pytest.fixture(autouse=True))",
            "expect(result).toContain(def setup_teardown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should generate E2E test template",
          "asserts": [
            "expect(result).toContain(from playwright.sync_api import Page)",
            "expect(result).toContain(class TestLoginFlowE2E:)",
            "expect(result).toContain(def test_complete_flow)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test file extension",
          "asserts": [
            "expect(adapter.getTestFileExtension()).toBe(_test.py)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test patterns",
          "asserts": [
            "expect(patterns).toContain(**/test_*.py)",
            "expect(patterns).toContain(**/*_test.py)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct test command",
          "asserts": [
            "expect(adapter.getTestCommand()).toBe(pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return correct coverage command",
          "asserts": [
            "expect(adapter.getCoverageCommand()).toBe(pytest --cov=. --cov-report=json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return PythonAdapter for Python project",
          "asserts": [
            "expect(adapter.language).toBe(python)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should return TypeScriptAdapter for TypeScript project",
          "asserts": [
            "expect(adapter.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should create TypeScriptAdapter",
          "asserts": [
            "expect(adapter.language).toBe(typescript)",
            "expect(adapter).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(adapter).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should create PythonAdapter",
          "asserts": [
            "expect(adapter.language).toBe(python)",
            "expect(adapter).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(adapter).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/adapters/__tests__/adapters.test.ts",
          "title": "should throw for unknown language",
          "asserts": [
            "expect(adapter).toBeNull"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)",
        "丘멆잺  2 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "getAdapter",
      "filePath": "src/adapters/adapter-factory.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "getAllAdapters",
      "filePath": "src/adapters/adapter-factory.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "registerAdapter",
      "filePath": "src/adapters/adapter-factory.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "isRepositorySupported",
      "filePath": "src/adapters/adapter-factory.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "getSupportedLanguages",
      "filePath": "src/adapters/adapter-factory.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "convertOldToNewDetection",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "runTestsWithAdapter",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "parseCoverageWithAdapter",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "MEDIUM",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "validateEnvironmentWithAdapter",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "discoverTestsWithAdapter",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "scaffoldTestWithAdapter",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "runMutationWithAdapter",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "HIGH",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游댮 Falta teste de happy path (cen치rio de sucesso b치sico)",
        "游리 Falta teste de edge cases (null, undefined, empty, boundary values)",
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "detectFrameworkWithAdapter",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": [
        "游리 Fun칞칚o tem side effects mas testes n칚o verificam intera칞칫es (mocks/spies)"
      ]
    },
    {
      "name": "detectLanguageCompatible",
      "filePath": "src/adapters/adapter-bridge.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": false,
        "edge": false,
        "error": false,
        "sideEffects": false
      },
      "tests": [],
      "gaps": []
    },
    {
      "name": "name",
      "filePath": "src/engine/adapters/typescript.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates)",
          "asserts": [
            "expect(MCP_TOOLS).toHaveLength(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tools devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(tool).toHaveProperty(name)",
            "expect(tool).toHaveProperty(description)",
            "expect(tool).toHaveProperty(inputSchema)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(tool.inputSchema.type).toBe(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve conter todos os 5 tools esperados",
          "asserts": [
            "expect(names).toContain(name)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve encontrar tool por nome",
          "asserts": [
            "expect(tool).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(tool).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve retornar undefined para tool inexistente",
          "asserts": [
            "expect(tool).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool analyze deve ter campos repo e product obrigat칩rios",
          "asserts": [
            "expect(tool.inputSchema.required).toContain(repo)",
            "expect(tool.inputSchema.required).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool validate deve ter campos de threshold",
          "asserts": [
            "expect(props).toHaveProperty(minBranch)",
            "expect(props).toHaveProperty(minMutation)",
            "expect(props).toHaveProperty(minDiffCoverage)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool scaffold deve ter campo type com enum",
          "asserts": [
            "expect(typeField.enum).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "todos os tools devem ter description com emoji",
          "asserts": [
            "expect(tool.description.length).toBeGreaterThan(10)",
            "expect(tool.description.charCodeAt()).toBeGreaterThan(255)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear dom칤nios separados por v칤rgula",
          "asserts": [
            "expect(domains).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear critical flows separados por v칤rgula",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear JSON de targets",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o se n칚o especificado",
          "asserts": [
            "expect(defaultOut).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve aceitar include-examples como boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(packages/product-e2e)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve converter --headed para headless=false",
          "asserts": [
            "expect(headless).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar headless=true por padr칚o",
          "asserts": [
            "expect(headless).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de relat칩rios padr칚o",
          "asserts": [
            "expect(defaultReport).toBe(reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar arquivo de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(SUMMARY.md)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de arquivos",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de endpoints",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de squads",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear thresholds JSON",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar URL base",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar URL inv치lida",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar nome de produto alphanumeric",
          "asserts": [
            "expect(regex.test()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar nome de produto com caracteres especiais",
          "asserts": [
            "expect(regex.test()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato markdown",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato html",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato json",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar formato inv치lido",
          "asserts": [
            "expect(['markdown', 'html', 'json']).not.toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar jest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar vitest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar mocha",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter todos os comandos esperados registrados na CLI",
          "asserts": [
            "expect(helpOutput).toContain(command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter descri칞칫es para todos os comandos",
          "asserts": [
            "expect(helpOutput).toContain",
            "expect(helpOutput).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar que comandos espec칤ficos aceitam par칙metros obrigat칩rios",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)",
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar comandos inexistentes com mensagem clara",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(output).toMatch(/unknown command|error/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve garantir que scripts npm correspondam aos comandos CLI",
          "asserts": [
            "expect(packageJson.scripts).toHaveProperty(scriptName)",
            "expect(packageJson.scripts.scriptName).toContain(cliCommand)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-run deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--fix deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-scaffold deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(opts.skipScaffold).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--repo deve rejeitar se n칚o tiver valor",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--product deve aceitar valor",
          "asserts": [
            "expect(opts.product).toBe(my-product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "analyze --repo . --product ",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.product).toBe(mcp)",
            "expect(opts.mode).toBe(analyze)",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "self-check --repo . --fix",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.minMutation).toBe(60)",
            "expect(opts.minBranch).toBe(70)",
            "expect(opts.failFast).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "Boolean defaultValue = flag sem <value>",
          "asserts": [
            "expect(booleanFlags.length).toBeGreaterThanOrEqual(2)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "String/Number defaultValue = flag com <value>",
          "asserts": [
            "expect(valueFlags.length).toBeGreaterThanOrEqual(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve gerar paths padr칚o para qa/<product>",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)",
            "expect(paths.analyses).toBe(/repo/qa/my-app/tests/analyses)",
            "expect(paths.reports).toBe(/repo/qa/my-app/tests/reports)",
            "expect(paths.playwrightReports).toBe(/repo/qa/my-app/tests/reports/playwright)",
            "expect(paths.unit).toBe(/repo/qa/my-app/tests/unit)",
            "expect(paths.integration).toBe(/repo/qa/my-app/tests/integration)",
            "expect(paths.e2e).toBe(/repo/qa/my-app/tests/e2e)",
            "expect(paths.fixtures).toBe(/repo/qa/my-app/fixtures)",
            "expect(paths.fixturesAuth).toBe(/repo/qa/my-app/fixtures/auth)",
            "expect(paths.dashboards).toBe(/repo/qa/my-app/dashboards)",
            "expect(paths.patches).toBe(/repo/qa/my-app/patches)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve respeitar output_root customizado via settings",
          "asserts": [
            "expect(paths.root).toBe(/repo/custom/qa-output)",
            "expect(paths.analyses).toBe(/repo/custom/qa-output/tests/analyses)",
            "expect(paths.reports).toBe(/repo/custom/qa-output/tests/reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com paths absolutos Windows-style",
          "asserts": [
            "expect(paths.root).toContain(my-app)",
            "expect(paths.analyses).toContain(tests)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve sanitizar corretamente nomes de produto com caracteres especiais",
          "asserts": [
            "expect(paths1.root).toBe(/repo/qa/@scope/package)",
            "expect(paths2.root).toBe(/repo/qa/my_app-v2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar todos os diret칩rios da estrutura",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser idempotente (n칚o falhar se diret칩rios j치 existem)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar estrutura mesmo se diret칩rio pai n칚o existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar true para paths dentro de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar false para paths fora de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path (Windows vs Unix)",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear JSON para analyses/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/analyze.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/coverage-analysis.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear MD e HTML para reports/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PLAN.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/QUALITY-REPORT.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PYRAMID.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear dashboard.html para dashboards/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/dashboard.html)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/Dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear .patch para patches/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/patches/fix-weak-assertions.patch)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve usar root como fallback para tipos desconhecidos",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/unknown.txt)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/package.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser case-insensitive para extens칫es",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/REPORT.MD)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/Data.JSON)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path relativo ao root do QA",
          "asserts": [
            "expect(getRelativePath()).toBe(tests/reports/PLAN.md)",
            "expect(getRelativePath()).toBe(tests/analyses/analyze.json)",
            "expect(getRelativePath()).toBe(dashboards/dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path original se n칚o estiver dentro do root",
          "asserts": [
            "expect(getRelativePath()).toBe(outsidePath)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path",
          "asserts": [
            "expect(relative).toBe(tests/unit/foo.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter todas as propriedades necess치rias",
          "asserts": [
            "expect(paths).toHaveProperty(prop)",
            "expect(unknown).toBe(string)",
            "expect(paths.prop.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter paths 칰nicos (sem duplicatas)",
          "asserts": [
            "expect(uniquePaths.size).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com product name vazio ou inv치lido",
          "asserts": [
            "expect(paths1.root).toContain(/repo/qa)",
            "expect(paths2.root).toContain(/repo/qa)",
            "expect(paths1.analyses).toContain(tests/analyses)",
            "expect(paths2.analyses).toContain(tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com repo path com espa칞os",
          "asserts": [
            "expect(paths.root).toBe(/Users/my folder/repo/qa/my-app)",
            "expect(paths.analyses).toContain(/Users/my folder/repo/qa/my-app/tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve preservar case do product name",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/MyApp-V2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings.paths undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve parsear relat칩rio LCOV corretamente",
          "asserts": [
            "expect(result.files.size).toBe(2)",
            "expect(result.totalLines).toBe(8)",
            "expect(result.coveredLines).toBe(6)",
            "expect(result.coverage).toBeCloseTo(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve extrair linhas cobertas corretamente",
          "asserts": [
            "expect(mathFile).toBeDefined",
            "expect(unknown.lines).toHaveLength(5)",
            "expect(unknown.totalLines).toBe(5)",
            "expect(unknown.coveredLines).toBe(4)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(mathFile).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas n칚o cobertas",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas cobertas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com LCOV vazio",
          "asserts": [
            "expect(result.files.size).toBe(0)",
            "expect(result.totalLines).toBe(0)",
            "expect(result.coverage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha n칚o coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para linha inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage exato para linhas espec칤ficas",
          "asserts": [
            "expect(result.total).toBe(4)",
            "expect(result.covered).toBe(4)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage com linhas n칚o cobertas",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para arquivo inexistente",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para lista de linhas vazia",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo src/",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo ./",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve converter backslash para slash",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com m칰ltiplos prefixos",
          "asserts": [
            "expect(normalizeFilePath()).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match exato",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match normalizado",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por basename",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar null para arquivo inexistente",
          "asserts": [
            "expect(found).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage preciso para diff simulado",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 0% para arquivo sem coverage",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 100% para linhas totalmente cobertas",
          "asserts": [
            "expect(result.total).toBe(2)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve detectar adapter baseado no m칠todo detect",
          "asserts": [
            "expect(result).toBe(mockAdapter2)",
            "expect(unknown).toBe(typescript)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve retornar null se nenhum adapter detectar",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve lan칞ar erro se linguagem n칚o detectada",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.errors.length).toBeGreaterThan(0)",
            "expect(result.errors.?).toContain(n칚o detectada)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar pipeline com adapter v치lido (stub)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.execution.stepsExecuted).toContain(functions)",
            "expect(result.execution.stepsExecuted).toContain(tests)",
            "expect(result.execution.stepsExecuted).toContain(cases)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve pular mutation em perfil ci-fast",
          "asserts": [
            "expect(result.execution.stepsSkipped).toContain(mutation)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar mutation em perfil ci-strict",
          "asserts": [
            "expect(result.execution.stepsExecuted).toContain(mutation)",
            "expect(mockAdapter.capabilities.mutation).toHaveBeenCalled",
            "expect(result.report.metrics.mutationScore).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve calcular quality score corretamente",
          "asserts": [
            "expect(result.report.metrics.qualityScore).toBeGreaterThan(0)",
            "expect(result.report.metrics.grade).toMatch(/[ABCDF]/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar producer.send() com t칩picos Kafka",
          "asserts": [
            "expect(events).toContain(kafka:user-created)",
            "expect(events).toContain(kafka:order-placed)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar consumer.subscribe() e consumer.run()",
          "asserts": [
            "expect(events).toContain(kafka:payment-processed)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar sqs.sendMessage() com queue URL",
          "asserts": [
            "expect(events).toContain(aws:my-queue)",
            "expect(events).toContain(aws:notifications)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar emit() com event names",
          "asserts": [
            "expect(events).toContain(event:user:login)",
            "expect(events).toContain(event:user:logout)",
            "expect(events).toContain(event:data:updated)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "user:login",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "user:logout",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "data:updated",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve retornar array vazio se n칚o houver eventos",
          "asserts": [
            "expect(events).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve consolidar todos os eventos encontrados",
          "asserts": [
            "expect(events).toHaveLength(3)",
            "expect(events).toContain(kafka:topic-1)",
            "expect(events).toContain(aws:queue-1)",
            "expect(events).toContain(event:event-1)",
            "expect(events).toEqual"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "event-1",
          "asserts": [
            "expect(events.filter()).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve remover eventos duplicados",
          "asserts": [
            "expect(events.filter()).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar SNS subscribe com TopicArn",
          "asserts": [
            "expect(events).toContain(aws:my-topic)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar eventos com aspas simples, duplas e template literals",
          "asserts": [
            "expect(events).toContain(event:single-quote)",
            "expect(events).toContain(event:double-quote)",
            "expect(events).toContain(event:template-literal)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "single-quote",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "double-quote",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve medir sa칰de b치sica da su칤te",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_runtime_sec).toBeGreaterThanOrEqual(0)",
            "expect(result.flaky_tests_count).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve calcular instability index",
          "asserts": [
            "expect(result.instability_index).toBeDefined",
            "expect(unknown).toBe(number)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.instability_index).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve gerar recomenda칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve salvar relat칩rio em JSON",
          "asserts": [
            "expect(result.output).toContain(suite-health.json)",
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(timestamp)",
            "expect(content).toHaveProperty(total_runtime_sec)",
            "expect(content).toHaveProperty(instability_index)",
            "expect(content).toHaveProperty(recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Vitest",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Jest",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Mocha",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(mocha)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve gerar testes para m칰ltiplos arquivos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve limitar a 20 arquivos por vez",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBeLessThanOrEqual(20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve atualizar package.json com scripts de teste",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(packageJson.scripts.test).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(packageJson.scripts.test).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve gerar guia de testes unit치rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(Unit Testing)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve lidar com erro quando arquivo fonte n칚o existe",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve auto-detectar arquivos quando n칚o especificados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-integration.test.ts",
          "title": "deve lidar com base_url inv치lida",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-integration.test.ts",
          "title": "deve lidar com endpoints vazios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve retornar 100% quando n칚o h치 mudan칞as",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.diffCoverage).toBe(100)",
            "expect(result.linesAdded).toBe(0)",
            "expect(result.files).toHaveLength(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve usar configura칞칚o do mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar isCLI=true se tem commander",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(CLI)",
            "expect(unknown).toContain(90)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar isMCPServer=true se tem @modelcontextprotocol/sdk",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(MCP)",
            "expect(unknown).toContain(90)",
            "expect(unknown).toContain(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar hasWebUI=true se tem react/next",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(Web)",
            "expect(e2ePct).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve calcular complexity baseado em features",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve recomendar 90% unit para CLI tools",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(90)",
            "expect(unknown).toContain(10)",
            "expect(unknown).toContain(0)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve recomendar 60/25/15 para web apps complexos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBe(high)",
            "expect(unitPct).toBeGreaterThanOrEqual(50)",
            "expect(unitPct).toBeLessThanOrEqual(70)",
            "expect(integrationPct).toBeGreaterThanOrEqual(20)",
            "expect(e2ePct).toBeGreaterThanOrEqual(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar se documento j치 existe",
          "asserts": [
            "expect(result1.ok).toBe(true)",
            "expect(result1.file).toBeDefined",
            "expect(result2.ok).toBe(true)",
            "expect(result2.exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result1.file).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve identificar arquivos priorit치rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(parserFile.priority).toBe(HIGH)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve gerar plano de testes b치sico",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.plan).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve criar arquivo TEST-PLAN.md",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(TestProduct2)",
            "expect(content).toContain(Plano de Testes)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir exemplos quando solicitado",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve usar configura칞칚o de mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve organizar por dom칤nios quando fornecidos",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve validar par칙metros obrigat칩rios",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir TODOs autom치ticos no plano",
          "asserts": [
            "expect(content).toContain(游꿢 A칞칫es Recomendadas)",
            "expect(content).toContain(TODO: Create auth fixtures)",
            "expect(content).toContain(TODO: Consider Testcontainers)",
            "expect(content).toContain(TODO: Configure CI/CD pipeline)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir Quality Gates com thresholds",
          "asserts": [
            "expect(content).toContain(Quality Gates)",
            "expect(content).toContain(Required Coverage)",
            "expect(content).toContain(Performance)",
            "expect(content).toContain(Blocking Criteria)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve calcular risk scores quando houver dados de an치lise",
          "asserts": [
            "expect(content).toContain(游댠 Risk Score Analysis)",
            "expect(content).toMatch(/Score:/)",
            "expect(content).toMatch(/Probability:/)",
            "expect(content).toMatch(/Impact:/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve gerar SLOs com defaults baseados em criticidade",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBe(2)",
            "expect(result.custom_slos_count).toBe(0)",
            "expect(slosData.slos).toHaveLength(2)",
            "expect(criticalSLO.latency_p99_ms).toBeLessThanOrEqual(500)",
            "expect(criticalSLO.error_rate_max).toBeLessThanOrEqual(0.01)",
            "expect(criticalSLO.availability_min).toBeGreaterThanOrEqual(0.995)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve aplicar SLOs customizados quando fornecidos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.custom_slos_count).toBe(1)",
            "expect(searchSLO.latency_p99_ms).toBe(200)",
            "expect(searchSLO.error_rate_max).toBe(0.001)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve aplicar defaults customizados globais",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testSLO.latency_p99_ms).toBe(1000)",
            "expect(testSLO.error_rate_max).toBe(0.05)",
            "expect(testSLO.availability_min).toBe(0.99)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve lidar com cat치logo vazio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve coletar m칠tricas de testes",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard HTML",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(<!DOCTYPE html>)",
            "expect(content).toContain(TestApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve incluir gr치ficos de cobertura",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(50:30:20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard com visualiza칞칚o da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Visualiza칞칚o da Pir칙mide)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve lidar com aus칡ncia de m칠tricas",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve exibir status de sa칰de dos testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(85/100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should analyze TypeScript project with basic tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(Vitest)",
            "expect(result.functions.length).toBeGreaterThan(0)",
            "expect(addFunc).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(addFunc).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should add positive numbers",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle zero",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should multiply numbers",
          "asserts": [
            "expect(multiply()).toBe(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect framework automatically",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate scenario coverage correctly",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should validate correct email",
          "asserts": [
            "expect(validateEmail()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should reject invalid email",
          "asserts": [
            "expect(validateEmail()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should throw on empty email",
          "asserts": [
            "expect(unknown).toThrow(Email required)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty repository",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])",
            "expect(result.metrics.qualityScore).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle repository without tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toEqual([...])",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle functions with weak assertions",
          "asserts": [
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should return user",
          "asserts": [
            "expect(user).toBeTruthy",
            "expect(user).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(user).toBeTruthy - usar compara칞칚o expl칤cita",
            "expect(user).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle null/undefined inputs gracefully",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle very large codebase efficiently",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBeGreaterThanOrEqual(10)",
            "expect(duration).toBeLessThan(10000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle invalid repository path",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed source files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')",
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined()",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain('TEST-QUALITY-LOGICAL-REPORT.md')",
            "expect(result.reportPath).toContain(testDir)",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(hasLogicLogs).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('python')",
            "expect(result.framework).toBe('Pytest')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('go')",
            "expect(result.framework).toBe('go test')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('java')",
            "expect(result.framework).toBe('JUnit')",
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(\n        result.metrics.scenarioCoverage.happy +\n        result.metrics.scenarioCoverage.edge +\n        result.metrics.scenarioCoverage.error +\n        result.metrics.scenarioCoverage.sideEffects\n      ).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined() - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle missing package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Unknown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should generate patches when requested",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should write report to correct location",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain(TEST-QUALITY-LOGICAL-REPORT.md)",
            "expect(result.reportPath).toContain(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should log progress to console",
          "asserts": [
            "expect(consoleSpy).toHaveBeenCalled",
            "expect(hasLogicLogs).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should create output directories if they do not exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Python projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(python)",
            "expect(result.framework).toBe(Pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Go projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(go)",
            "expect(result.framework).toBe(go test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Java projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(java)",
            "expect(result.framework).toBe(JUnit)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate quality score based on coverage",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should process valid data",
          "asserts": [
            "expect(processData()).toBe(HELLO)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty string",
          "asserts": [
            "expect(unknown).toThrow(No data)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle special characters",
          "asserts": [
            "expect(processData()).toBe(A@B)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve recomendar quais arquivos testar primeiro",
          "asserts": [
            "expect(recommendation.ok).toBe(true)",
            "expect(recommendation.recommendation).toBeDefined",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(parserFile.priority).toBe(HIGH)",
            "expect(parserFile.reason).toContain(parsing)",
            "expect(parserFile.reason).toContain(complexa)",
            "expect(configFile.priority).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(recommendation.recommendation).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "\\\\n",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes para arquivos de alta prioridade",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.generated).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(scaffoldResult.framework).toBe(vitest)",
            "expect(testExists).toBe(true)",
            "expect(testContent).toContain(describe)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(it)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(expect)",
            "expect(testContent).toContain(vitest)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toContain(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldResult.generated).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes com framework recomendado",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testContent).toContain(jest)",
            "expect(testContent).toContain(describe)",
            "expect(packageJson.scripts.test).toContain(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command tool available",
          "asserts": [
            "expect(toolName).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto tool available",
          "asserts": [
            "expect(toolName).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command as high priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto as second priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid natural language query",
          "asserts": [
            "expect(validParams.query).toBe(analise meu reposit칩rio)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept query with defaults",
          "asserts": [
            "expect(unknown).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should reject empty query",
          "asserts": [
            "expect(unknown).toThrow(Query cannot be empty)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid mode",
          "asserts": [
            "expect(validParams.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept all modes",
          "asserts": [
            "expect(params.mode).toBe(mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept skip flags",
          "asserts": [
            "expect(params.skipScaffold).toBe(true)",
            "expect(params.skipRun).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should work with minimal params (auto-detection)",
          "asserts": [
            "expect(params).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(params).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate nl_command schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(query)",
            "expect(expectedProperties).toContain(defaults)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate auto schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(mode)",
            "expect(expectedProperties).toContain(repo)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have correct mode enum values",
          "asserts": [
            "expect(validModes).toHaveLength(5)",
            "expect(validModes).toContain(full)",
            "expect(validModes).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support nl_command  auto flow",
          "asserts": [
            "expect(nlParams.query).toBeTruthy",
            "expect(unknown).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(nlParams.query).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support direct auto invocation",
          "asserts": [
            "expect(autoParams.mode).toBe(analyze)",
            "expect(autoParams.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support defaults override in nl_command",
          "asserts": [
            "expect(unknown).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle invalid mode gracefully",
          "asserts": [
            "expect(unknown).toThrow(Invalid mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle missing required params",
          "asserts": [
            "expect(unknown).toThrow(Query is required)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive nl_command description",
          "asserts": [
            "expect(description).toContain(linguagem natural)",
            "expect(description).toContain(PT/EN)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive auto description",
          "asserts": [
            "expect(description).toContain(Orquestrador)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention supported languages in nl_command",
          "asserts": [
            "expect(examples).toContain(analise meu reposit칩rio)",
            "expect(examples).toContain(criar plano)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention available modes in auto",
          "asserts": [
            "expect(modes).toHaveLength(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[1/4] scaffold_contracts_pact - deve detectar servi칞os e gerar contratos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.message).toContain(Generated)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.timestamp).toBeDefined",
            "expect(catalog.product).toBe(test-cdc-app)",
            "expect(catalog.services).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.services.length).toBeGreaterThan(0)",
            "expect(catalog.potential_contracts).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.coverage).toBeDefined",
            "expect(catalog.coverage.total_integrations).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(configContent).toContain(pactConfig)",
            "expect(configContent).toContain(test-cdc-app)",
            "expect(configContent).toContain(consumer)",
            "expect(configContent).toContain(provider)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(consumer)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(interaction)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(verify)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.services).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.potential_contracts).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.coverage).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[2/4] scaffold_contracts_pact - deve detectar m칰ltiplas APIs corretamente",
          "asserts": [
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(service.endpoints).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(service.endpoints.?).toHaveProperty(method)",
            "expect(service.endpoints.?).toHaveProperty(path)",
            "expect(contract).toHaveProperty(consumer)",
            "expect(contract).toHaveProperty(provider)",
            "expect(contract).toHaveProperty(priority)",
            "expect(unknown).toContain",
            "expect(contract.estimated_interactions).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(service.endpoints).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[3/4] run_contracts_verify - deve verificar contratos gerados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.verified).toBeGreaterThanOrEqual(0)",
            "expect(result.failed).toBeGreaterThanOrEqual(0)",
            "expect(result.report_path).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(report.timestamp).toBeDefined",
            "expect(report.product).toBe(testProduct)",
            "expect(report.language).toBe(typescript)",
            "expect(report.total_contracts).toBeGreaterThan(0)",
            "expect(report.total_interactions).toBeGreaterThan(0)",
            "expect(report.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(report.results).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(report.duration_total_ms).toBeGreaterThan(0)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)",
            "expect(mdContent).toContain(Verification Rate)",
            "expect(mdContent).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico",
            "expect(report.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(report.results).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[4/4] FULL PIPELINE - scaffold + verify funcionam em sequ칡ncia",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.total_contracts).toBeGreaterThan(0)",
            "expect(configContent).toContain(pact-broker.example.com)",
            "expect(verifyResult.ok).toBe(true)",
            "expect(verifyResult.total_interactions).toBe(6)",
            "expect(verifyResult.verification_rate).toBeGreaterThan(0)",
            "expect(report.total_contracts).toBe(3)",
            "expect(report.total_interactions).toBe(6)",
            "expect(report.verified).toBeGreaterThanOrEqual(0)",
            "expect(report.failed).toBeGreaterThanOrEqual(0)",
            "expect(unknown).toBe(6)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[FULL PIPELINE] FASE 1 + FASE 2 completa",
          "asserts": [
            "expect(cujResult.ok).toBe(true)",
            "expect(slosResult.ok).toBe(true)",
            "expect(riskResult.ok).toBe(true)",
            "expect(portfolioResult.ok).toBe(true)",
            "expect(portfolioResult.output).toContain(PORTFOLIO-PLAN.md)",
            "expect(existsSync()).toBe(true)",
            "expect(portfolioResult.recommendations_count).toBeGreaterThanOrEqual(0)",
            "expect(reportContent).toContain(# Test Portfolio Plan)",
            "expect(reportContent).toContain(## 游늵 Current State)",
            "expect(reportContent).toContain(## 游꿢 Target Distribution)",
            "expect(reportContent).toContain(## 游꿢 Module Recommendations)",
            "expect(reportContent).toContain(## 九 Action Items)",
            "expect(reportContent).toContain(Fowler)",
            "expect(reportContent).toContain(70%)",
            "expect(reportContent).toContain(20%)",
            "expect(reportContent).toContain(10%)",
            "expect(reportContent).toContain(| Test Type | Count | Percentage | Target | Gap |)",
            "expect(reportContent).toContain(Unit)",
            "expect(reportContent).toContain(Integration)",
            "expect(reportContent).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[VALIDATION] Portfolio plan deve ter estrutura correta",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(content).toContain(section)",
            "expect(content).toMatch(/\\/\\\\/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[INTEGRATION] Recommendations devem estar baseadas em riscos",
          "asserts": [
            "expect(portfolioContent).toContain(游뚿 Top 5 Critical Risks)",
            "expect(portfolioContent).toContain(Module Recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[METRICS] Distribui칞칚o deve somar 100%",
          "asserts": [
            "expect(content).toContain(Current State)",
            "expect(total).toBeGreaterThanOrEqual(99.9)",
            "expect(total).toBeLessThanOrEqual(100.1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[1/3] catalog_cujs deve gerar cuj-catalog.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(cuj-catalog.json)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog).toHaveProperty(timestamp)",
            "expect(catalog).toHaveProperty(repo)",
            "expect(catalog).toHaveProperty(product)",
            "expect(catalog).toHaveProperty(cujs)",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.cujs.length).toBeGreaterThan(0)",
            "expect(firstCUJ).toHaveProperty(id)",
            "expect(firstCUJ).toHaveProperty(name)",
            "expect(firstCUJ).toHaveProperty(criticality)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[2/3] define_slos deve gerar slos.json baseado em CUJs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(slos.json)",
            "expect(existsSync()).toBe(true)",
            "expect(slos).toHaveProperty(timestamp)",
            "expect(slos).toHaveProperty(repo)",
            "expect(slos).toHaveProperty(product)",
            "expect(slos).toHaveProperty(slos)",
            "expect(slos).toHaveProperty(defaults_applied)",
            "expect(unknown).toBe(boolean)",
            "expect(firstSLO).toHaveProperty(cuj_id)",
            "expect(firstSLO).toHaveProperty(error_rate_max)",
            "expect(firstSLO).toHaveProperty(availability_min)",
            "expect(firstSLO.error_rate_max).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.error_rate_max).toBeLessThanOrEqual(1)",
            "expect(firstSLO.availability_min).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.availability_min).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[3/3] risk_register deve gerar risk-register.json cruzando CUJs + SLOs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_risks).toBeGreaterThan(0)",
            "expect(result.output).toContain(risk-register.json)",
            "expect(existsSync()).toBe(true)",
            "expect(riskReg).toHaveProperty(timestamp)",
            "expect(riskReg).toHaveProperty(repo)",
            "expect(riskReg).toHaveProperty(product)",
            "expect(riskReg).toHaveProperty(risks)",
            "expect(riskReg).toHaveProperty(top_5_critical)",
            "expect(riskReg).toHaveProperty(total_risk_score)",
            "expect(riskReg).toHaveProperty(coverage_gaps)",
            "expect(Array.isArray()).toBe(true)",
            "expect(riskReg.top_5_critical.length).toBeLessThanOrEqual(5)",
            "expect(unknown).toBe(string)",
            "expect(firstRisk).toHaveProperty(id)",
            "expect(firstRisk).toHaveProperty(cuj_id)",
            "expect(firstRisk).toHaveProperty(title)",
            "expect(firstRisk).toHaveProperty(description)",
            "expect(firstRisk).toHaveProperty(impact)",
            "expect(firstRisk).toHaveProperty(probability)",
            "expect(firstRisk).toHaveProperty(risk_score)",
            "expect(firstRisk).toHaveProperty(affected_modules)",
            "expect(firstRisk).toHaveProperty(mitigation_strategies)",
            "expect(firstRisk).toHaveProperty(recommended_tests)",
            "expect(firstRisk.risk_score).toBeGreaterThanOrEqual(0)",
            "expect(firstRisk.risk_score).toBeLessThanOrEqual(100)",
            "expect(unknown).toContain",
            "expect(unknown).toContain",
            "expect(validTests).toContain(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[FULL] Pipeline completo deve criar 3 arquivos consistentes",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.cujs.length).toBe",
            "expect(catalog.cujs.length).toBe",
            "expect(sloIds.has()).toBe(true)",
            "expect(r.id).toBe",
            "expect(cujIds.has()).toBe(true)",
            "expect(riskIds.has()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.final_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(result.final_params.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect RUN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.final_params.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.extracted_params.product).toBe(TestApp)",
            "expect(result.extracted_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should apply defaults when no override present",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.repo).toBe(tempDir)",
            "expect(result.final_params.product).toBe(DefaultProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should prioritize explicit overrides over defaults",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.product).toBe(ExplicitProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle empty query gracefully",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle query with only whitespace",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in empty repo",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in repo with package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.context.hasPackageJson).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work with existing mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute ANALYZE mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute PLAN mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should auto-detect repo from cwd",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.repoPath).toBeDefined",
            "expect(result.context.repoPath.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.repoPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should infer product from package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should create qa/<product>/ directory structure",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should generate all expected artifacts in FULL mode",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.outputs).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.steps).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle invalid repo path gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle missing product name",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle filesystem errors gracefully",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect vitest framework",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect existing test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "example",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should get users",
          "asserts": [
            "expect(getUsers).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(getUsers).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve executar analyze e detectar endpoints",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve criar analyze.json com findings",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(findings)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve permitir pipeline completo: analyze  coverage  plan",
          "asserts": [
            "expect(analyzeResult.findings).toBeDefined",
            "expect(coverageResult.pyramid).toBeDefined",
            "expect(planResult.plan).toBeDefined",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeResult.findings).toBeDefined - verificar valor espec칤fico",
            "expect(coverageResult.pyramid).toBeDefined - verificar valor espec칤fico",
            "expect(planResult.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve usar configura칞칚o centralizada de mcp-settings.json",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve validar health da pir칙mide corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar projeto TypeScript com package.json",
          "asserts": [
            "expect(result).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar projeto TypeScript com tsconfig.json",
          "asserts": [
            "expect(result).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve retornar false para diret칩rio sem arquivos TypeScript",
          "asserts": [
            "expect(result).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar vitest via vitest.config.ts",
          "asserts": [
            "expect(result).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar jest via jest.config.js",
          "asserts": [
            "expect(result).toBe(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve retornar null se n칚o detectar framework",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir fun칞칚o exportada simples",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})",
            "expect(functions.?.criticality).toBe(CRITICAL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir fun칞칚o async",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir arrow function exportada",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve determinar criticality CRITICAL para validadores",
          "asserts": [
            "expect(functions.?.criticality).toBe(CRITICAL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve determinar criticality HIGH para fun칞칫es de escrita",
          "asserts": [
            "expect(functions.?.criticality).toBe(HIGH)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve ignorar arquivos de teste",
          "asserts": [
            "expect(functions).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir testes com it()",
          "asserts": [
            "expect(tests).toHaveLength(1)",
            "expect(tests.?).toMatchObject({...})",
            "expect(tests.?.assertions).toHaveLength(1)",
            "expect(tests.?.assertions.?.type).toBe(toEqual)",
            "expect(tests.?.assertions.?.isWeak).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should parse valid JSON",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir testes com test()",
          "asserts": [
            "expect(tests).toHaveLength(1)",
            "expect(tests.?.name).toBe(adds two numbers)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "adds two numbers",
          "asserts": [
            "expect(unknown).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar spies",
          "asserts": [
            "expect(tests.?.hasSpies).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should log message",
          "asserts": [
            "expect(spy).toHaveBeenCalledWith(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar mocks",
          "asserts": [
            "expect(tests.?.hasMocks).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should fetch user",
          "asserts": [
            "expect(user).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar asser칞칫es fracas",
          "asserts": [
            "expect(tests.?.assertions.?.isWeak).toBe(true)",
            "expect(tests.?.assertions.?.type).toBe(toBeTruthy)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(tests.?.assertions.?.type).toBe(toBeTruthy) - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should be truthy",
          "asserts": [
            "expect(someValue).toBeTruthy"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(someValue).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar m칰ltiplas asser칞칫es",
          "asserts": [
            "expect(tests.?.assertions).toHaveLength(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "validates user",
          "asserts": [
            "expect(user.name).toBe(John)",
            "expect(user.age).toEqual(30)",
            "expect(user.email).toMatch(/@/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar happy path com asser칞칫es fortes",
          "asserts": [
            "expect(matrix).toHaveLength(1)",
            "expect(matrix.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "adds two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar error handling",
          "asserts": [
            "expect(matrix.?.error).toBe(true)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "throws on negative age",
          "asserts": [
            "expect(unknown).toThrow(Invalid age)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar edge cases por nome do teste",
          "asserts": [
            "expect(matrix.?.edge).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "handles empty string",
          "asserts": [
            "expect(getLength()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar side effects com spies",
          "asserts": [
            "expect(matrix.?.sideEffects).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "logs message to console",
          "asserts": [
            "expect(spy).toHaveBeenCalledWith(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve identificar gaps de cen치rios faltantes",
          "asserts": [
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Error Handling)",
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Edge Cases)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "fetches data",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve sugerir side effects para fun칞칫es com verbos de a칞칚o",
          "asserts": [
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Side Effects (fun칞칚o tem efeitos colaterais))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "creates user",
          "asserts": [
            "expect(user.name).toBe(John)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  115 assertion(s) fraca(s) detectada(s)"
      ]
    },
    {
      "name": "name",
      "filePath": "src/engine/adapters/typescript.ts",
      "criticality": "LOW",
      "scenarios": {
        "happy": true,
        "edge": true,
        "error": true,
        "sideEffects": true
      },
      "tests": [
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "should greet",
          "asserts": [
            "expect(greet()).toBe(Hello, World!)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve inicializar produto via init-product",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.path).toContain(ServerTestApp)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar analyze e retornar findings",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toHaveProperty(routes)",
            "expect(result.findings).toHaveProperty(endpoints)",
            "expect(result.findings).toHaveProperty(events)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve executar coverage e calcular pir칙mide",
          "asserts": [
            "expect(result).toHaveProperty(pyramid)",
            "expect(result.pyramid).toMatchObject({...})",
            "expect(result.health).toMatch(/healthy|inverted|needs_attention/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar plano baseado em an치lise",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(result.plan).toMatch(/PLAN/)",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve validar par칙metros com schemas Zod",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve integrar config centralizado de mcp-settings.json",
          "asserts": [
            "expect(result).toHaveProperty(findings)",
            "expect(result.findings).toBeTypeOf(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve gerar catalog de cen치rios",
          "asserts": [
            "expect(result).toHaveProperty(product)",
            "expect(result).toHaveProperty(total_scenarios)",
            "expect(result.total_scenarios).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve recomendar estrat칠gia de testes",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de unit tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/server.integration.test.ts",
          "title": "deve scaffold de integration tests funcionar",
          "asserts": [
            "expect(result).toMatchObject({...})",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve ter exatamente 10 tools consolidados (5 originais + 5 Quality Gates)",
          "asserts": [
            "expect(MCP_TOOLS).toHaveLength(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tools devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(tool).toHaveProperty(name)",
            "expect(tool).toHaveProperty(description)",
            "expect(tool).toHaveProperty(inputSchema)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(tool.inputSchema.type).toBe(object)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "deve conter todos os 5 tools esperados",
          "asserts": [
            "expect(names).toContain(name)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve encontrar tool por nome",
          "asserts": [
            "expect(tool).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(tool).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "findTool deve retornar undefined para tool inexistente",
          "asserts": [
            "expect(tool).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool analyze deve ter campos repo e product obrigat칩rios",
          "asserts": [
            "expect(tool.inputSchema.required).toContain(repo)",
            "expect(tool.inputSchema.required).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool validate deve ter campos de threshold",
          "asserts": [
            "expect(props).toHaveProperty(minBranch)",
            "expect(props).toHaveProperty(minMutation)",
            "expect(props).toHaveProperty(minDiffCoverage)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "tool scaffold deve ter campo type com enum",
          "asserts": [
            "expect(typeField.enum).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/mcp-tools.test.ts",
          "title": "todos os tools devem ter description com emoji",
          "asserts": [
            "expect(tool.description.length).toBeGreaterThan(10)",
            "expect(tool.description.charCodeAt()).toBeGreaterThan(255)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear dom칤nios separados por v칤rgula",
          "asserts": [
            "expect(domains).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear critical flows separados por v칤rgula",
          "asserts": [
            "expect(flows).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear JSON de targets",
          "asserts": [
            "expect(targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o se n칚o especificado",
          "asserts": [
            "expect(defaultOut).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve aceitar include-examples como boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(packages/product-e2e)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve converter --headed para headless=false",
          "asserts": [
            "expect(headless).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar headless=true por padr칚o",
          "asserts": [
            "expect(headless).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar diret칩rio de relat칩rios padr칚o",
          "asserts": [
            "expect(defaultReport).toBe(reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve usar arquivo de sa칤da padr칚o",
          "asserts": [
            "expect(defaultOut).toBe(SUMMARY.md)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de arquivos",
          "asserts": [
            "expect(files).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de endpoints",
          "asserts": [
            "expect(endpoints).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear lista de squads",
          "asserts": [
            "expect(squads).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": ",",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve parsear thresholds JSON",
          "asserts": [
            "expect(thresholds).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar URL base",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar URL inv치lida",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar nome de produto alphanumeric",
          "asserts": [
            "expect(regex.test()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar nome de produto com caracteres especiais",
          "asserts": [
            "expect(regex.test()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato markdown",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato html",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar formato json",
          "asserts": [
            "expect(unknown).toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar formato inv치lido",
          "asserts": [
            "expect(['markdown', 'html', 'json']).not.toContain(format)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar jest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar vitest",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve suportar mocha",
          "asserts": [
            "expect(unknown).toContain(framework)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter todos os comandos esperados registrados na CLI",
          "asserts": [
            "expect(helpOutput).toContain(command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve ter descri칞칫es para todos os comandos",
          "asserts": [
            "expect(helpOutput).toContain",
            "expect(helpOutput).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve validar que comandos espec칤ficos aceitam par칙metros obrigat칩rios",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)",
            "expect(unknown).toBe(false)",
            "expect(unknown).toMatch(/required option.*--repo/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve rejeitar comandos inexistentes com mensagem clara",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(output).toMatch(/unknown command|error/i)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli.test.ts",
          "title": "deve garantir que scripts npm correspondam aos comandos CLI",
          "asserts": [
            "expect(packageJson.scripts).toHaveProperty(scriptName)",
            "expect(packageJson.scripts.scriptName).toContain(cliCommand)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve ter exatamente 6 comandos consolidados",
          "asserts": [
            "expect(COMMANDS).toHaveLength(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter propriedades obrigat칩rias",
          "asserts": [
            "expect(cmd).toHaveProperty(name)",
            "expect(cmd).toHaveProperty(module)",
            "expect(cmd).toHaveProperty(description)",
            "expect(cmd).toHaveProperty(flags)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem ter pelo menos uma flag",
          "asserts": [
            "expect(cmd.flags.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todas as flags devem ter estrutura v치lida",
          "asserts": [
            "expect(flag).toHaveProperty(name)",
            "expect(flag).toHaveProperty(description)",
            "expect(flag).toHaveProperty(required)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(string)",
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "deve conter todos os comandos esperados",
          "asserts": [
            "expect(commandNames).toContain(expectedCmd)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando analyze deve ter flags obrigat칩rias",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(requiredNames).toContain(repo)",
            "expect(requiredNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve ter flags de threshold",
          "asserts": [
            "expect(validateCmd).toBeDefined",
            "expect(flagNames).toContain(min-branch)",
            "expect(flagNames).toContain(min-mutation)",
            "expect(flagNames).toContain(min-diff-coverage)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(validateCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter flag type",
          "asserts": [
            "expect(scaffoldCmd).toBeDefined",
            "expect(flagNames).toContain(type)",
            "expect(flagNames).toContain(repo)",
            "expect(flagNames).toContain(product)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter flag fix",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(flagNames).toContain(fix)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags boolean devem ter defaultValue do tipo boolean",
          "asserts": [
            "expect(unknown).toBe(boolean)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "flags de valor devem ter defaultValue string/number/undefined, n칚o boolean",
          "asserts": [
            "expect(typeof flag.defaultValue).not.toBe('boolean')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-run deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipRunFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipRunFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --skip-scaffold deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(skipScaffoldFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(skipScaffoldFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "REGRESS츾O: --fix deve ser boolean (bug fix e6939d9)",
          "asserts": [
            "expect(fixFlag).toBeDefined",
            "expect(unknown).toBe(boolean)",
            "expect(unknown.defaultValue).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(fixFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar comando por nome",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve retornar undefined para comando inexistente",
          "asserts": [
            "expect(cmd).toBeUndefined"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "findCommand deve encontrar por alias",
          "asserts": [
            "expect(found).toBeDefined",
            "expect(unknown.name).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(found).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve validar flags obrigat칩rias",
          "asserts": [
            "expect(result1.valid).toBe(false)",
            "expect(result1.missing).toContain(repo)",
            "expect(result1.missing).toContain(product)",
            "expect(result2.valid).toBe(true)",
            "expect(result2.missing).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "validateRequiredFlags deve permitir flags opcionais ausentes",
          "asserts": [
            "expect(result.valid).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "scripts npm devem corresponder aos comandos principais",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "todos os comandos devem apontar para m칩dulos .js v치lidos",
          "asserts": [
            "expect(cmd.module).toMatch(/\\.js$/)",
            "expect(cmd.module).toMatch(/^\\.\\/tools\\//)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "m칩dulos devem seguir padr칚o de naming",
          "asserts": [
            "expect(moduleName).toBeTruthy",
            "expect(moduleName.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(moduleName).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando validate deve aceitar thresholds opcionais",
          "asserts": [
            "expect(minBranch).toBeDefined",
            "expect(unknown.required).toBe(false)",
            "expect(minMutation).toBeDefined",
            "expect(unknown.required).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(minBranch).toBeDefined - verificar valor espec칤fico",
            "expect(minMutation).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando scaffold deve ter defaults 칰teis",
          "asserts": [
            "expect(typeFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(unit)",
            "expect(frameworkFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(typeFlag).toBeDefined - verificar valor espec칤fico",
            "expect(frameworkFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comando self-check deve ter repo default",
          "asserts": [
            "expect(repoFlag).toBeDefined",
            "expect(unknown.defaultValue).toBe(.)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(repoFlag).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "comandos principais devem ter exemplos",
          "asserts": [
            "expect(cmd).toBeDefined",
            "expect(unknown.examples).toBeDefined",
            "expect(unknown.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(cmd).toBeDefined - verificar valor espec칤fico",
            "expect(unknown.examples).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem conter nome do comando",
          "asserts": [
            "expect(example).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-manifest.test.ts",
          "title": "exemplos devem ter sintaxe v치lida",
          "asserts": [
            "expect(example).toMatch(/quality\\s+\\w+/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-run deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(analyzeCmd).toBeDefined",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--fix deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(selfCheckCmd).toBeDefined",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(selfCheckCmd).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--skip-scaffold deve aceitar sintaxe boolean (sem valor)",
          "asserts": [
            "expect(opts.skipScaffold).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--repo deve rejeitar se n칚o tiver valor",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "--product deve aceitar valor",
          "asserts": [
            "expect(opts.product).toBe(my-product)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "analyze --repo . --product ",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.product).toBe(mcp)",
            "expect(opts.mode).toBe(analyze)",
            "expect(opts.skipRun).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "self-check --repo . --fix",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.fix).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "validate --repo . --min-mutation 60 --min-branch 70 --fail-fast",
          "asserts": [
            "expect(opts.repo).toBe(.)",
            "expect(opts.minMutation).toBe(60)",
            "expect(opts.minBranch).toBe(70)",
            "expect(opts.failFast).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "Boolean defaultValue = flag sem <value>",
          "asserts": [
            "expect(booleanFlags.length).toBeGreaterThanOrEqual(2)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/__tests__/cli-boolean-flags.integration.test.ts",
          "title": "String/Number defaultValue = flag com <value>",
          "asserts": [
            "expect(valueFlags.length).toBeGreaterThanOrEqual(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve gerar paths padr칚o para qa/<product>",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)",
            "expect(paths.analyses).toBe(/repo/qa/my-app/tests/analyses)",
            "expect(paths.reports).toBe(/repo/qa/my-app/tests/reports)",
            "expect(paths.playwrightReports).toBe(/repo/qa/my-app/tests/reports/playwright)",
            "expect(paths.unit).toBe(/repo/qa/my-app/tests/unit)",
            "expect(paths.integration).toBe(/repo/qa/my-app/tests/integration)",
            "expect(paths.e2e).toBe(/repo/qa/my-app/tests/e2e)",
            "expect(paths.fixtures).toBe(/repo/qa/my-app/fixtures)",
            "expect(paths.fixturesAuth).toBe(/repo/qa/my-app/fixtures/auth)",
            "expect(paths.dashboards).toBe(/repo/qa/my-app/dashboards)",
            "expect(paths.patches).toBe(/repo/qa/my-app/patches)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve respeitar output_root customizado via settings",
          "asserts": [
            "expect(paths.root).toBe(/repo/custom/qa-output)",
            "expect(paths.analyses).toBe(/repo/custom/qa-output/tests/analyses)",
            "expect(paths.reports).toBe(/repo/custom/qa-output/tests/reports)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com paths absolutos Windows-style",
          "asserts": [
            "expect(paths.root).toContain(my-app)",
            "expect(paths.analyses).toContain(tests)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve sanitizar corretamente nomes de produto com caracteres especiais",
          "asserts": [
            "expect(paths1.root).toBe(/repo/qa/@scope/package)",
            "expect(paths2.root).toBe(/repo/qa/my_app-v2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar todos os diret칩rios da estrutura",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser idempotente (n칚o falhar se diret칩rios j치 existem)",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve criar estrutura mesmo se diret칩rio pai n칚o existir",
          "asserts": [
            "expect(stats.isDirectory()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar true para paths dentro de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar false para paths fora de qa/<product>",
          "asserts": [
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)",
            "expect(isWithinQARoot()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path (Windows vs Unix)",
          "asserts": [
            "expect(isWithinQARoot()).toBe(true)",
            "expect(isWithinQARoot()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear JSON para analyses/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/analyze.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/coverage-analysis.json)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/TEST-QUALITY-LOGICAL.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear MD e HTML para reports/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PLAN.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/QUALITY-REPORT.md)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/PYRAMID.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear dashboard.html para dashboards/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/dashboard.html)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/dashboards/Dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve mapear .patch para patches/",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/patches/fix-weak-assertions.patch)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve usar root como fallback para tipos desconhecidos",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/unknown.txt)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/package.json)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ser case-insensitive para extens칫es",
          "asserts": [
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/reports/REPORT.MD)",
            "expect(getOutputPath()).toBe(/repo/qa/my-app/tests/analyses/Data.JSON)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path relativo ao root do QA",
          "asserts": [
            "expect(getRelativePath()).toBe(tests/reports/PLAN.md)",
            "expect(getRelativePath()).toBe(tests/analyses/analyze.json)",
            "expect(getRelativePath()).toBe(dashboards/dashboard.html)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve retornar path original se n칚o estiver dentro do root",
          "asserts": [
            "expect(getRelativePath()).toBe(outsidePath)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve normalizar separadores de path",
          "asserts": [
            "expect(relative).toBe(tests/unit/foo.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter todas as propriedades necess치rias",
          "asserts": [
            "expect(paths).toHaveProperty(prop)",
            "expect(unknown).toBe(string)",
            "expect(paths.prop.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve ter paths 칰nicos (sem duplicatas)",
          "asserts": [
            "expect(uniquePaths.size).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com product name vazio ou inv치lido",
          "asserts": [
            "expect(paths1.root).toContain(/repo/qa)",
            "expect(paths2.root).toContain(/repo/qa)",
            "expect(paths1.analyses).toContain(tests/analyses)",
            "expect(paths2.analyses).toContain(tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve lidar com repo path com espa칞os",
          "asserts": [
            "expect(paths.root).toBe(/Users/my folder/repo/qa/my-app)",
            "expect(paths.analyses).toContain(/Users/my folder/repo/qa/my-app/tests/analyses)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve preservar case do product name",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/MyApp-V2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/paths.test.ts",
          "title": "deve funcionar com settings.paths undefined",
          "asserts": [
            "expect(paths.root).toBe(/repo/qa/my-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should load settings from /qa/<product>/mcp-settings.json with priority",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should fall back to root mcp-settings.json if product settings not found",
          "asserts": [
            "expect(result).toEqual(mockSettings)",
            "expect(fileExists).toHaveBeenCalledWith"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null if no settings file found",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid JSON and return null",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate settings with Zod schema and reject invalid data",
          "asserts": [
            "expect(result).toBeNull",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should accept minimal valid settings with defaults",
          "asserts": [
            "expect(result).toMatchObject({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return params when fileSettings is null",
          "asserts": [
            "expect(result).toEqual(params)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should merge fileSettings with params, giving precedence to params",
          "asserts": [
            "expect(result.product).toBe(ParamProduct)",
            "expect(result.base_url).toBe(https://param.example.com)",
            "expect(result.domains).toEqual([...])",
            "expect(unknown).toBe(85)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should deep merge targets object",
          "asserts": [
            "expect(result.targets).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create directory structure and settings template",
          "asserts": [
            "expect(result).toBe",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(mkdirSpy).toHaveBeenCalledWith",
            "expect(writeFileSpy).toHaveBeenCalled",
            "expect(writtenContent).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should not overwrite existing settings file",
          "asserts": [
            "expect(writeFileSpy).not.toHaveBeenCalled()"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should use generic localhost environments (agn칩stico)",
          "asserts": [
            "expect(writtenContent.environments).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should validate correct schema",
          "asserts": [
            "expect(result.success).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid product name (empty)",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject invalid base_url",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should reject diff_coverage_min out of range",
          "asserts": [
            "expect(result.success).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should apply default values for optional fields",
          "asserts": [
            "expect(result.domains).toEqual([...])",
            "expect(result.critical_flows).toEqual([...])",
            "expect(result.targets).toEqual({...})",
            "expect(result.environments).toEqual({...})",
            "expect(result.auth).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product name from package.json",
          "asserts": [
            "expect(result).toBe(company-my-awesome-product)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should return null when package.json not found",
          "asserts": [
            "expect(result).toBe(repo)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should handle invalid package.json gracefully",
          "asserts": [
            "expect(result).toBe('repo')"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create generic template with localhost defaults",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(TestProduct)",
            "expect(content.base_url).toBe(http://localhost:3000)",
            "expect(content.domains).toEqual([...])",
            "expect(content.critical_flows).toEqual([...])",
            "expect(content.targets.diff_coverage_min).toBe(80)",
            "expect(content.environments.dev.url).toBe(http://localhost:3000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should create mcp-settings.example.json automatically",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content.product).toBe(MyProduct)",
            "expect(content.domains).toContain(billing)",
            "expect(content.critical_flows).toContain(login)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/utils/__tests__/config.test.ts",
          "title": "should infer product from package.json when not provided",
          "asserts": [
            "expect(content.product).toBe(my-cool-app)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve detectar adapter baseado no m칠todo detect",
          "asserts": [
            "expect(result).toBe(mockAdapter2)",
            "expect(unknown).toBe(typescript)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve retornar null se nenhum adapter detectar",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve lan칞ar erro se linguagem n칚o detectada",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.errors.length).toBeGreaterThan(0)",
            "expect(result.errors.?).toContain(n칚o detectada)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar pipeline com adapter v치lido (stub)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.execution.stepsExecuted).toContain(functions)",
            "expect(result.execution.stepsExecuted).toContain(tests)",
            "expect(result.execution.stepsExecuted).toContain(cases)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve pular mutation em perfil ci-fast",
          "asserts": [
            "expect(result.execution.stepsSkipped).toContain(mutation)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve executar mutation em perfil ci-strict",
          "asserts": [
            "expect(result.execution.stepsExecuted).toContain(mutation)",
            "expect(mockAdapter.capabilities.mutation).toHaveBeenCalled",
            "expect(result.report.metrics.mutationScore).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/__tests__/engine.test.ts",
          "title": "deve calcular quality score corretamente",
          "asserts": [
            "expect(result.report.metrics.qualityScore).toBeGreaterThan(0)",
            "expect(result.report.metrics.grade).toMatch(/[ABCDF]/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve parsear relat칩rio LCOV corretamente",
          "asserts": [
            "expect(result.files.size).toBe(2)",
            "expect(result.totalLines).toBe(8)",
            "expect(result.coveredLines).toBe(6)",
            "expect(result.coverage).toBeCloseTo(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve extrair linhas cobertas corretamente",
          "asserts": [
            "expect(mathFile).toBeDefined",
            "expect(unknown.lines).toHaveLength(5)",
            "expect(unknown.totalLines).toBe(5)",
            "expect(unknown.coveredLines).toBe(4)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(mathFile).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas n칚o cobertas",
          "asserts": [
            "expect(unknown).toBe(false)",
            "expect(unknown).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve marcar linhas cobertas",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com LCOV vazio",
          "asserts": [
            "expect(result.files.size).toBe(0)",
            "expect(result.totalLines).toBe(0)",
            "expect(result.coverage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve identificar linha n칚o coberta",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para arquivo inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar false para linha inexistente",
          "asserts": [
            "expect(isLineCovered()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage exato para linhas espec칤ficas",
          "asserts": [
            "expect(result.total).toBe(4)",
            "expect(result.covered).toBe(4)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage com linhas n칚o cobertas",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para arquivo inexistente",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar 0 para lista de linhas vazia",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo src/",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve remover prefixo ./",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve converter backslash para slash",
          "asserts": [
            "expect(normalizeFilePath()).toBe(utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve lidar com m칰ltiplos prefixos",
          "asserts": [
            "expect(normalizeFilePath()).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match exato",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por match normalizado",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve encontrar arquivo por basename",
          "asserts": [
            "expect(found).toBe(src/utils/math.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve retornar null para arquivo inexistente",
          "asserts": [
            "expect(found).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular coverage preciso para diff simulado",
          "asserts": [
            "expect(result.total).toBe(3)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBeCloseTo(66.67)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 0% para arquivo sem coverage",
          "asserts": [
            "expect(result.total).toBe(0)",
            "expect(result.covered).toBe(0)",
            "expect(result.percentage).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/parsers/__tests__/lcov-line-parser.test.ts",
          "title": "deve calcular 100% para linhas totalmente cobertas",
          "asserts": [
            "expect(result.total).toBe(2)",
            "expect(result.covered).toBe(2)",
            "expect(result.percentage).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Vitest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm run test:coverage)",
            "expect(result.coverageFile).toBe(coverage/coverage-summary.json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar TypeScript com Jest",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)",
            "expect(result.testCommand).toBe(npm test)",
            "expect(result.coverageCommand).toBe(npm test -- --coverage)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar JavaScript puro (sem TypeScript)",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com go.mod",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)",
            "expect(result.testCommand).toBe(go test ./...)",
            "expect(result.coverageCommand).toBe(go test -coverprofile=coverage.out ./... && go tool cover -func=coverage.out)",
            "expect(result.coverageFile).toBe(coverage.out)",
            "expect(result.testPatterns).toEqual([...])",
            "expect(result.sourcePatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Go com testify framework",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Maven (pom.xml)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(mvn test)",
            "expect(result.coverageCommand).toBe(mvn clean test jacoco:report)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Java com Gradle (build.gradle)",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)",
            "expect(result.testCommand).toBe(./gradlew test)",
            "expect(result.coverageCommand).toBe(./gradlew test jacocoTestReport)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com requirements.txt e pytest",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)",
            "expect(result.testCommand).toBe(pytest)",
            "expect(result.coverageCommand).toBe(pytest --cov=. --cov-report=json)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Python com pyproject.toml",
          "asserts": [
            "expect(result.primary).toBe(python)",
            "expect(result.framework).toBe(pytest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar Ruby com Gemfile e RSpec",
          "asserts": [
            "expect(result.primary).toBe(ruby)",
            "expect(result.framework).toBe(rspec)",
            "expect(result.testCommand).toBe(bundle exec rspec)",
            "expect(result.coverageCommand).toBe(bundle exec rspec)",
            "expect(result.testPatterns).toEqual([...])"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve detectar C# com arquivo .csproj",
          "asserts": [
            "expect(result.primary).toBe(csharp)",
            "expect(result.framework).toBe(nunit)",
            "expect(result.testCommand).toBe(dotnet test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback para TypeScript quando n칚o detecta linguagem",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)",
            "expect(console.warn).toHaveBeenCalledWith(丘멆잺  Linguagem n칚o detectada automaticamente.)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com erro de leitura de diret칩rio",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com package.json inv치lido",
          "asserts": [],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve lidar com arquivos vazios",
          "asserts": [
            "expect(result.primary).toBe(typescript)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Go quando tem go.mod e package.json",
          "asserts": [
            "expect(result.primary).toBe(go)",
            "expect(result.framework).toBe(go-test)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve priorizar Java quando tem pom.xml e package.json",
          "asserts": [
            "expect(result.primary).toBe(java)",
            "expect(result.framework).toBe(junit)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve retornar extens칚o correta para cada linguagem",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(Test.java)",
            "expect(getTestFileExtension()).toBe(_test.go)",
            "expect(getTestFileExtension()).toBe(_spec.rb)",
            "expect(getTestFileExtension()).toBe(_test.py)",
            "expect(getTestFileExtension()).toBe(Tests.cs)",
            "expect(getTestFileExtension()).toBe(Test.php)",
            "expect(getTestFileExtension()).toBe(_test.rs)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve usar fallback .test.ts para linguagens desconhecidas",
          "asserts": [
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)",
            "expect(getTestFileExtension()).toBe(.test.ts)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template TypeScript/JavaScript correto",
          "asserts": [
            "expect(template).toContain(\"import { describe, it, expect } from 'vitest'\")",
            "expect(template).toContain(\"import { myFunction } from './myModule'\")",
            "expect(template).toContain(\"describe('myFunction', () => {\")",
            "expect(template).toContain('should work correctly')",
            "expect(template).toContain('should handle edge cases')",
            "expect(template).toContain('should handle errors')",
            "expect(tsTemplate).toContain('vitest')",
            "expect(tsTemplate).toContain('parseData')",
            "expect(tsTemplate).toContain('../parser')",
            "expect(jsTemplate).toContain('vitest')",
            "expect(jsTemplate).toContain('helper')",
            "expect(template).toContain('calculateTotalPrice')",
            "expect(template).toContain('../business/pricing')",
            "expect(template).toContain(\"describe('calculateTotalPrice'\")",
            "expect(template).toContain('../../shared/validation')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve gerar template para diferentes linguagens",
          "asserts": [
            "expect(tsTemplate).toContain(vitest)",
            "expect(tsTemplate).toContain(parseData)",
            "expect(tsTemplate).toContain(../parser)",
            "expect(jsTemplate).toContain(vitest)",
            "expect(jsTemplate).toContain(helper)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com nomes de fun칞칚o complexos",
          "asserts": [
            "expect(template).toContain(calculateTotalPrice)",
            "expect(template).toContain(../business/pricing)",
            "expect(template).toContain(describe('calculateTotalPrice')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/language.test.ts",
          "title": "deve funcionar com caminhos relativos diferentes",
          "asserts": [
            "expect(template).toContain(../../shared/validation)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar producer.send() com t칩picos Kafka",
          "asserts": [
            "expect(events).toContain(kafka:user-created)",
            "expect(events).toContain(kafka:order-placed)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar consumer.subscribe() e consumer.run()",
          "asserts": [
            "expect(events).toContain(kafka:payment-processed)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar sqs.sendMessage() com queue URL",
          "asserts": [
            "expect(events).toContain(aws:my-queue)",
            "expect(events).toContain(aws:notifications)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar emit() com event names",
          "asserts": [
            "expect(events).toContain(event:user:login)",
            "expect(events).toContain(event:user:logout)",
            "expect(events).toContain(event:data:updated)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "user:login",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "user:logout",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "data:updated",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve retornar array vazio se n칚o houver eventos",
          "asserts": [
            "expect(events).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve consolidar todos os eventos encontrados",
          "asserts": [
            "expect(events).toHaveLength(3)",
            "expect(events).toContain(kafka:topic-1)",
            "expect(events).toContain(aws:queue-1)",
            "expect(events).toContain(event:event-1)",
            "expect(events).toEqual"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "event-1",
          "asserts": [
            "expect(events.filter()).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve remover eventos duplicados",
          "asserts": [
            "expect(events.filter()).toHaveLength(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar SNS subscribe com TopicArn",
          "asserts": [
            "expect(events).toContain(aws:my-topic)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "deve detectar eventos com aspas simples, duplas e template literals",
          "asserts": [
            "expect(events).toContain(event:single-quote)",
            "expect(events).toContain(event:double-quote)",
            "expect(events).toContain(event:template-literal)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "single-quote",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/detectors/__tests__/events.test.ts",
          "title": "double-quote",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve medir sa칰de b치sica da su칤te",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_runtime_sec).toBeGreaterThanOrEqual(0)",
            "expect(result.flaky_tests_count).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "test",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve calcular instability index",
          "asserts": [
            "expect(result.instability_index).toBeDefined",
            "expect(unknown).toBe(number)",
            "expect(result.instability_index).toBeGreaterThanOrEqual(0)",
            "expect(result.instability_index).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.instability_index).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve gerar recomenda칞칫es",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/suite-health.test.ts",
          "title": "deve salvar relat칩rio em JSON",
          "asserts": [
            "expect(result.output).toContain(suite-health.json)",
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(timestamp)",
            "expect(content).toHaveProperty(total_runtime_sec)",
            "expect(content).toHaveProperty(instability_index)",
            "expect(content).toHaveProperty(recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Vitest",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Jest",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve detectar framework Mocha",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(mocha)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve gerar testes para m칰ltiplos arquivos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve limitar a 20 arquivos por vez",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBeLessThanOrEqual(20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve atualizar package.json com scripts de teste",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(packageJson.scripts.test).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(packageJson.scripts.test).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve gerar guia de testes unit치rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(Unit Testing)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve lidar com erro quando arquivo fonte n칚o existe",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-unit.test.ts",
          "title": "deve auto-detectar arquivos quando n칚o especificados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-integration.test.ts",
          "title": "deve lidar com base_url inv치lida",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/scaffold-integration.test.ts",
          "title": "deve lidar com endpoints vazios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.generated.length).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve executar mutation tests com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.overallScore).toBeGreaterThanOrEqual(0)",
            "expect(result.passed).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve retornar passed=false se score < minScore",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.passed).toBe(false)",
            "expect(result.overallScore).toBe(30)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-mutation-tests.test.ts",
          "title": "deve lidar com erro graciosamente",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve retornar 100% quando n칚o h치 mudan칞as",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.diffCoverage).toBe(100)",
            "expect(result.linesAdded).toBe(0)",
            "expect(result.files).toHaveLength(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-diff-coverage.test.ts",
          "title": "deve usar configura칞칚o do mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve executar cobertura e analisar resultados com status excellent",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(85)",
            "expect(result.analysis.status).toBe(excellent)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar gaps quando cobertura baixa (critical)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(critical)",
            "expect(result.analysis.meetsThresholds).toBe(false)",
            "expect(result.analysis.gaps.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve identificar status good quando cobertura est치 entre 70-80%",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.status).toBe(good)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve priorizar arquivos com menor cobertura",
          "asserts": [
            "expect(result.files.length).toBe(2)",
            "expect(result.files.?.path).toContain(file1)",
            "expect(result.files.?.lines).toBe(10)",
            "expect(result.analysis.priorities.length).toBeGreaterThan(0)",
            "expect(result.analysis.priorities.?.priority).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar relat칩rio detalhado em Markdown",
          "asserts": [
            "expect(result.reportPath).toBeDefined",
            "expect(result.reportPath).toContain(COVERAGE-ANALYSIS.md)",
            "expect(reportExists).toBe(true)",
            "expect(reportContent).toContain(Relat칩rio de Cobertura)",
            "expect(reportContent).toContain(70)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.reportPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve usar thresholds customizados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.meetsThresholds).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo de cobertura inexistente",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.error).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.error).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular gaps corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(linesGap).toBeDefined",
            "expect(linesGap).toContain(200 linhas)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(linesGap).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve gerar recomenda칞칫es espec칤ficas baseadas nos gaps",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.recommendations.length).toBeGreaterThan(0)",
            "expect(result.analysis.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve classificar prioridades corretamente (high, medium, low)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.analysis.priorities.length).toBe(3)",
            "expect(highPriority).toBeDefined",
            "expect(mediumPriority).toBeDefined",
            "expect(lowPriority).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(highPriority).toBeDefined - verificar valor espec칤fico",
            "expect(mediumPriority).toBeDefined - verificar valor espec칤fico",
            "expect(lowPriority).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Vitest/Jest corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)",
            "expect(result.summary.functions.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar arquivo JSON do Mocha corretamente",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.summary.lines.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Maven",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Java com Gradle",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar XML JaCoCo quando dispon칤vel",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Python com pytest",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar estrutura de projeto Python com pyproject.toml",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Go",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato coverage.out com modo atomic",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar projeto Go com coverage.out vazio",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar detec칞칚o de projeto Ruby",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve validar formato SimpleCov alternativo",
          "asserts": [
            "expect(unknown).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de C# mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com detec칞칚o de PHP mesmo sem comando dispon칤vel",
          "asserts": [
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML JaCoCo com todos os counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(40)",
            "expect(result.total.branches.covered).toBe(30)",
            "expect(result.total.branches.pct).toBe(75)",
            "expect(result.total.functions.total).toBe(20)",
            "expect(result.total.functions.covered).toBe(15)",
            "expect(result.total.functions.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem counters",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com counters parciais",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.pct).toBe(70)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.functions.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear coverage.out completo",
          "asserts": [
            "expect(result.total.statements.total).toBe(5)",
            "expect(result.total.statements.covered).toBe(3)",
            "expect(result.total.statements.pct).toBe(60)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve ignorar linha mode",
          "asserts": [
            "expect(result.total.statements.total).toBe(1)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBe(100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo vazio",
          "asserts": [
            "expect(result.total.statements.total).toBe(0)",
            "expect(result.total.statements.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente statements com count 0",
          "asserts": [
            "expect(result.total.statements.total).toBe(3)",
            "expect(result.total.statements.covered).toBe(1)",
            "expect(result.total.statements.pct).toBeCloseTo(33.33)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov com wrapper coverage",
          "asserts": [
            "expect(result.total.lines.total).toBe(9)",
            "expect(result.total.lines.covered).toBe(8)",
            "expect(result.total.lines.pct).toBeCloseTo(88.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON SimpleCov sem wrapper",
          "asserts": [
            "expect(result.total.lines.total).toBe(4)",
            "expect(result.total.lines.covered).toBe(3)",
            "expect(result.total.lines.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com arquivo sem cobertura",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve contar corretamente m칰ltiplos arquivos",
          "asserts": [
            "expect(result.total.lines.total).toBe(8)",
            "expect(result.total.lines.covered).toBe(4)",
            "expect(result.total.lines.pct).toBe(50)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear JSON coverage.py completo",
          "asserts": [
            "expect(result.total.lines.total).toBe(200)",
            "expect(result.total.lines.covered).toBe(160)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.branches.total).toBe(50)",
            "expect(result.total.branches.covered).toBe(40)",
            "expect(result.total.branches.pct).toBe(80)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com JSON sem branches",
          "asserts": [
            "expect(result.total.lines.pct).toBe(75)",
            "expect(result.total.branches.total).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve calcular branch percentage corretamente",
          "asserts": [
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Cobertura com rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(85)",
            "expect(result.total.branches.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem rates",
          "asserts": [
            "expect(result.total.lines.pct).toBe(0)",
            "expect(result.total.branches.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar rates decimais corretamente",
          "asserts": [
            "expect(result.total.lines.pct).toBe(95.25)",
            "expect(result.total.branches.pct).toBe(67.89)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve parsear XML Clover com metrics completas",
          "asserts": [
            "expect(result.total.lines.total).toBe(100)",
            "expect(result.total.lines.covered).toBe(80)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(200)",
            "expect(result.total.statements.covered).toBe(150)",
            "expect(result.total.statements.pct).toBe(75)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve lidar com XML sem metrics",
          "asserts": [
            "expect(result.total.lines.total).toBe(0)",
            "expect(result.total.lines.pct).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-coverage.test.ts",
          "title": "deve processar apenas elements se statements n칚o existir",
          "asserts": [
            "expect(result.total.lines.total).toBe(50)",
            "expect(result.total.lines.covered).toBe(40)",
            "expect(result.total.lines.pct).toBe(80)",
            "expect(result.total.statements.total).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se diret칩rio de pacts n칚o existir",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.message).toContain(No Pact contracts found)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.recommendations).toContain(Run `quality scaffold --type contracts` to generate Pact contracts)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve retornar erro se nenhum arquivo pact for encontrado",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.verification_rate).toBe(0)",
            "expect(result.total_interactions).toBe(0)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve verificar contratos com sucesso",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_interactions).toBe(1)",
            "expect(result.verified).toBe(1)",
            "expect(result.failed).toBe(0)",
            "expect(result.verification_rate).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve calcular verification_rate corretamente",
          "asserts": [
            "expect(result.total_interactions).toBe(3)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio JSON",
          "asserts": [
            "expect(result.report_path).toBeDefined",
            "expect(result.report_path).toContain(contracts-verify.json)",
            "expect(reportCalls.length).toBe(1)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar relat칩rio Markdown",
          "asserts": [
            "expect(mdCalls.length).toBe(1)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve incluir falhas no resultado quando houver",
          "asserts": [
            "expect(result.failures).toBeDefined",
            "expect(Array.isArray()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.failures).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve gerar recomenda칞칫es baseadas nos resultados",
          "asserts": [
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve processar m칰ltiplos arquivos pact",
          "asserts": [
            "expect(result.total_interactions).toBe(2)",
            "expect(vi.mocked()).toHaveBeenCalledTimes(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/run-contracts-verify.test.ts",
          "title": "deve aceitar provider_base_url customizado",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar isCLI=true se tem commander",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(CLI)",
            "expect(unknown).toContain(90)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar isMCPServer=true se tem @modelcontextprotocol/sdk",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(MCP)",
            "expect(unknown).toContain(90)",
            "expect(unknown).toContain(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar hasWebUI=true se tem react/next",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(Web)",
            "expect(e2ePct).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve calcular complexity baseado em features",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBe(high)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve recomendar 90% unit para CLI tools",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toContain(90)",
            "expect(unknown).toContain(10)",
            "expect(unknown).toContain(0)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve recomendar 60/25/15 para web apps complexos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBe(high)",
            "expect(unitPct).toBeGreaterThanOrEqual(50)",
            "expect(unitPct).toBeLessThanOrEqual(70)",
            "expect(integrationPct).toBeGreaterThanOrEqual(20)",
            "expect(e2ePct).toBeGreaterThanOrEqual(10)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve detectar se documento j치 existe",
          "asserts": [
            "expect(result1.ok).toBe(true)",
            "expect(result1.file).toBeDefined",
            "expect(result2.ok).toBe(true)",
            "expect(result2.exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result1.file).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/recommend-strategy.test.ts",
          "title": "deve identificar arquivos priorit치rios",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(parserFile.priority).toBe(HIGH)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve gerar plano de testes b치sico",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.plan).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve criar arquivo TEST-PLAN.md",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toContain(TestProduct2)",
            "expect(content).toContain(Plano de Testes)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir exemplos quando solicitado",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve usar configura칞칚o de mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve organizar por dom칤nios quando fornecidos",
          "asserts": [
            "expect(content).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(content).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve validar par칙metros obrigat칩rios",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir TODOs autom치ticos no plano",
          "asserts": [
            "expect(content).toContain(游꿢 A칞칫es Recomendadas)",
            "expect(content).toContain(TODO: Create auth fixtures)",
            "expect(content).toContain(TODO: Consider Testcontainers)",
            "expect(content).toContain(TODO: Configure CI/CD pipeline)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve incluir Quality Gates com thresholds",
          "asserts": [
            "expect(content).toContain(Quality Gates)",
            "expect(content).toContain(Required Coverage)",
            "expect(content).toContain(Performance)",
            "expect(content).toContain(Blocking Criteria)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/plan.test.ts",
          "title": "deve calcular risk scores quando houver dados de an치lise",
          "asserts": [
            "expect(content).toContain(游댠 Risk Score Analysis)",
            "expect(content).toMatch(/Score:/)",
            "expect(content).toMatch(/Probability:/)",
            "expect(content).toMatch(/Impact:/)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve identificar fun칞칫es exportadas sem testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBe(3)",
            "expect(result.functions).toContainEqual",
            "expect(result.untested.length).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve categorizar fun칞칫es corretamente",
          "asserts": [
            "expect(unknown).toBe(parser)",
            "expect(unknown).toBe(validator)",
            "expect(unknown).toBe(core)",
            "expect(unknown).toBe(util)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve determinar criticidade corretamente",
          "asserts": [
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(CRITICAL)",
            "expect(unknown).toBe(HIGH)",
            "expect(unknown).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar fun칞칫es com testes",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(2)",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should add two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular m칠tricas de qualidade",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(50)",
            "expect(result.metrics.criticalFunctionsTotal).toBe(2)",
            "expect(result.metrics.criticalFunctionsTested).toBe(2)",
            "expect(result.metrics.usesDescribeBlocks).toBe(true)",
            "expect(result.metrics.usesBeforeAfterHooks).toBe(true)",
            "expect(result.metrics.hasEdgeCaseTests).toBe(true)",
            "expect(result.metrics.hasErrorHandlingTests).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid XML",
          "asserts": [
            "expect(parseJaCoCoXML()).toBeDefined",
            "expect(parseJaCoCoXML()).toHaveProperty(total)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseJaCoCoXML()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle empty XML",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle null input (edge case)",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse coverage data",
          "asserts": [
            "expect(parsePytestCoverage()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parsePytestCoverage()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar recomenda칞칫es para fun칞칫es cr칤ticas sem testes",
          "asserts": [
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve calcular quality score e grade corretamente",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(60)",
            "expect(result.metrics.grade).toMatch(/[A-D]/)",
            "expect(result.metrics.avgAssertionsPerTest).toBeGreaterThan(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should parse valid data",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toHaveProperty(result)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle edge cases",
          "asserts": [
            "expect(parseData()).toBeDefined",
            "expect(parseData()).toThrow"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(parseData()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should handle errors",
          "asserts": [
            "expect(unknown).toThrow"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve gerar relat칩rio de qualidade",
          "asserts": [
            "expect(result.reportPath).toBe",
            "expect(reportContent).toContain(# 游꿢 Relat칩rio de Qualidade de Testes)",
            "expect(reportContent).toContain(TestProduct)",
            "expect(reportContent).toContain(Quality Score:)",
            "expect(reportContent).toContain(Grade:)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "deve detectar testes sem assertions",
          "asserts": [
            "expect(result.metrics.avgAssertionsPerTest).toBeLessThan(2)",
            "expect(result.recommendations.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should do something",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/evaluate-test-quality.test.ts",
          "title": "should work",
          "asserts": [
            "expect(doSomething()).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(doSomething()).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve gerar SLOs com defaults baseados em criticidade",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBe(2)",
            "expect(result.custom_slos_count).toBe(0)",
            "expect(slosData.slos).toHaveLength(2)",
            "expect(criticalSLO.latency_p99_ms).toBeLessThanOrEqual(500)",
            "expect(criticalSLO.error_rate_max).toBeLessThanOrEqual(0.01)",
            "expect(criticalSLO.availability_min).toBeGreaterThanOrEqual(0.995)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve aplicar SLOs customizados quando fornecidos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.custom_slos_count).toBe(1)",
            "expect(searchSLO.latency_p99_ms).toBe(200)",
            "expect(searchSLO.error_rate_max).toBe(0.001)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve aplicar defaults customizados globais",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testSLO.latency_p99_ms).toBe(1000)",
            "expect(testSLO.error_rate_max).toBe(0.05)",
            "expect(testSLO.availability_min).toBe(0.99)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/define-slos.test.ts",
          "title": "deve lidar com cat치logo vazio",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve coletar m칠tricas de testes",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard HTML",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(exists).toBe(true)",
            "expect(content).toContain(<!DOCTYPE html>)",
            "expect(content).toContain(TestApp)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve incluir gr치ficos de cobertura",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(50:30:20)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve gerar dashboard com visualiza칞칚o da pir칙mide",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(Visualiza칞칚o da Pir칙mide)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve lidar com aus칡ncia de m칠tricas",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/dashboard.test.ts",
          "title": "deve exibir status de sa칰de dos testes",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(content).toContain(85/100)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect product from package.json",
          "asserts": [
            "expect(context.product).toBe(my-awesome-app)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect existing tests",
          "asserts": [
            "expect(context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should detect test framework from package.json",
          "asserts": [
            "expect(context.testFramework).toBe(vitest)",
            "expect(context.language).toBe(typescript)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should fallback to directory name if no package.json",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(false)",
            "expect(context.hasTests).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle package.json without name",
          "asserts": [
            "expect(context.product).toContain(.test-auto-)",
            "expect(context.hasPackageJson).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute analyze mode successfully",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(analyze).toHaveBeenCalledWith({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute plan mode (analyze + plan)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(generatePlan).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute scaffold mode (analyze + plan + scaffold)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(scaffold-unit)",
            "expect(scaffoldUnitTests).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip scaffold if tests already exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should execute full mode (all steps)",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.steps).toContain(analyze)",
            "expect(result.steps).toContain(plan)",
            "expect(result.steps).toContain(code-analysis-report)",
            "expect(result.steps).toContain(test-plan-report)",
            "expect(result.steps).toContain(coverage)",
            "expect(result.steps).toContain(dashboard)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should skip run if skipRun is true",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should handle errors gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)",
            "expect(result.steps).toEqual([...])"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro",
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return true on successful run",
          "asserts": [
            "expect(success).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/auto.test.ts",
          "title": "should return false on failed run",
          "asserts": [
            "expect(success).toBe(false)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should analyze TypeScript project with basic tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(typescript)",
            "expect(result.framework).toBe(Vitest)",
            "expect(result.functions.length).toBeGreaterThan(0)",
            "expect(addFunc).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(addFunc).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should add positive numbers",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle negative numbers",
          "asserts": [
            "expect(add()).toBe"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle zero",
          "asserts": [
            "expect(add()).toBe(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should multiply numbers",
          "asserts": [
            "expect(multiply()).toBe(6)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect framework automatically",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate scenario coverage correctly",
          "asserts": [
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should validate correct email",
          "asserts": [
            "expect(validateEmail()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should reject invalid email",
          "asserts": [
            "expect(validateEmail()).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should throw on empty email",
          "asserts": [
            "expect(unknown).toThrow(Email required)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty repository",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])",
            "expect(result.metrics.qualityScore).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle repository without tests",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(unknown).toEqual([...])",
            "expect(unknown).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle functions with weak assertions",
          "asserts": [
            "expect(unknown).toBeGreaterThan(0)",
            "expect(unknown).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should return user",
          "asserts": [
            "expect(user).toBeTruthy",
            "expect(user).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(user).toBeTruthy - usar compara칞칚o expl칤cita",
            "expect(user).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle null/undefined inputs gracefully",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle very large codebase efficiently",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.functions.length).toBeGreaterThanOrEqual(10)",
            "expect(duration).toBeLessThan(10000)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle invalid repository path",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.ok).toBe(true)",
            "expect(result.functions).toEqual([...])"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed source files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')",
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined()",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain('TEST-QUALITY-LOGICAL-REPORT.md')",
            "expect(result.reportPath).toContain(testDir)",
            "expect(consoleSpy).toHaveBeenCalled()",
            "expect(hasLogicLogs).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('python')",
            "expect(result.framework).toBe('Pytest')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('go')",
            "expect(result.framework).toBe('go test')",
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe('java')",
            "expect(result.framework).toBe('JUnit')",
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(\n        result.metrics.scenarioCoverage.happy +\n        result.metrics.scenarioCoverage.edge +\n        result.metrics.scenarioCoverage.error +\n        result.metrics.scenarioCoverage.sideEffects\n      ).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined() - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle malformed test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe('Unknown')"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle missing package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.framework).toBe(Unknown)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should generate patches when requested",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.patches).toBeDefined",
            "expect(consoleSpy).toHaveBeenCalled"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.patches).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should write report to correct location",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.reportPath).toContain(TEST-QUALITY-LOGICAL-REPORT.md)",
            "expect(result.reportPath).toContain(testDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should log progress to console",
          "asserts": [
            "expect(consoleSpy).toHaveBeenCalled",
            "expect(hasLogicLogs).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should create output directories if they do not exist",
          "asserts": [
            "expect(result.ok).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Python projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(python)",
            "expect(result.framework).toBe(Pytest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Go projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(go)",
            "expect(result.framework).toBe(go test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should detect Java projects",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.language).toBe(java)",
            "expect(result.framework).toBe(JUnit)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should calculate quality score based on coverage",
          "asserts": [
            "expect(result.metrics.qualityScore).toBeGreaterThan(70)",
            "expect(result.metrics.scenarioCoverage.happy).toBeGreaterThan(0)",
            "expect(unknown).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should process valid data",
          "asserts": [
            "expect(processData()).toBe(HELLO)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle empty string",
          "asserts": [
            "expect(unknown).toThrow(No data)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/tools/__tests__/analyze-test-logic.test.ts",
          "title": "should handle special characters",
          "asserts": [
            "expect(processData()).toBe(A@B)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve recomendar quais arquivos testar primeiro",
          "asserts": [
            "expect(recommendation.ok).toBe(true)",
            "expect(recommendation.recommendation).toBeDefined",
            "expect(unknown).toBeDefined",
            "expect(unknown).toBeGreaterThan(0)",
            "expect(parserFile.priority).toBe(HIGH)",
            "expect(parserFile.reason).toContain(parsing)",
            "expect(parserFile.reason).toContain(complexa)",
            "expect(configFile.priority).toBe(LOW)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(recommendation.recommendation).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "\\\\n",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes para arquivos de alta prioridade",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.generated).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(scaffoldResult.framework).toBe(vitest)",
            "expect(testExists).toBe(true)",
            "expect(testContent).toContain(describe)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(it)",
            "expect(testContent).toContain(test)",
            "expect(testContent).toContain(expect)",
            "expect(testContent).toContain(vitest)",
            "expect(unknown).toBeDefined",
            "expect(unknown).toContain(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(scaffoldResult.generated).toBeDefined - verificar valor espec칤fico",
            "expect(unknown).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/recommend-to-scaffold.test.ts",
          "title": "deve criar testes com framework recomendado",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(testContent).toContain(jest)",
            "expect(testContent).toContain(describe)",
            "expect(packageJson.scripts.test).toContain(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command tool available",
          "asserts": [
            "expect(toolName).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto tool available",
          "asserts": [
            "expect(toolName).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have nl_command as high priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(nl_command)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have auto as second priority tool",
          "asserts": [
            "expect(priorityTools.?).toBe(auto)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid natural language query",
          "asserts": [
            "expect(validParams.query).toBe(analise meu reposit칩rio)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept query with defaults",
          "asserts": [
            "expect(unknown).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should reject empty query",
          "asserts": [
            "expect(unknown).toThrow(Query cannot be empty)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept valid mode",
          "asserts": [
            "expect(validParams.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept all modes",
          "asserts": [
            "expect(params.mode).toBe(mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should accept skip flags",
          "asserts": [
            "expect(params.skipScaffold).toBe(true)",
            "expect(params.skipRun).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should work with minimal params (auto-detection)",
          "asserts": [
            "expect(params).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(params).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate nl_command schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(query)",
            "expect(expectedProperties).toContain(defaults)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should validate auto schema structure",
          "asserts": [
            "expect(expectedProperties).toContain(mode)",
            "expect(expectedProperties).toContain(repo)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have correct mode enum values",
          "asserts": [
            "expect(validModes).toHaveLength(5)",
            "expect(validModes).toContain(full)",
            "expect(validModes).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support nl_command  auto flow",
          "asserts": [
            "expect(nlParams.query).toBeTruthy",
            "expect(unknown).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(nlParams.query).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support direct auto invocation",
          "asserts": [
            "expect(autoParams.mode).toBe(analyze)",
            "expect(autoParams.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should support defaults override in nl_command",
          "asserts": [
            "expect(unknown).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle invalid mode gracefully",
          "asserts": [
            "expect(unknown).toThrow(Invalid mode)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should handle missing required params",
          "asserts": [
            "expect(unknown).toThrow(Query is required)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive nl_command description",
          "asserts": [
            "expect(description).toContain(linguagem natural)",
            "expect(description).toContain(PT/EN)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should have descriptive auto description",
          "asserts": [
            "expect(description).toContain(Orquestrador)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention supported languages in nl_command",
          "asserts": [
            "expect(examples).toContain(analise meu reposit칩rio)",
            "expect(examples).toContain(criar plano)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/integration/mcp-server.test.ts",
          "title": "should mention available modes in auto",
          "asserts": [
            "expect(modes).toHaveLength(5)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[1/4] scaffold_contracts_pact - deve detectar servi칞os e gerar contratos",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.message).toContain(Generated)",
            "expect(result.total_contracts).toBeGreaterThan(0)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.catalog_path).toBeDefined",
            "expect(result.config_path).toBeDefined",
            "expect(result.consumer_tests).toBeDefined",
            "expect(result.provider_tests).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.timestamp).toBeDefined",
            "expect(catalog.product).toBe(test-cdc-app)",
            "expect(catalog.services).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.services.length).toBeGreaterThan(0)",
            "expect(catalog.potential_contracts).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.coverage).toBeDefined",
            "expect(catalog.coverage.total_integrations).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(configContent).toContain(pactConfig)",
            "expect(configContent).toContain(test-cdc-app)",
            "expect(configContent).toContain(consumer)",
            "expect(configContent).toContain(provider)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(consumer)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(interaction)",
            "expect(unknown.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(testContent).toContain(provider)",
            "expect(testContent).toContain(verify)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(result.recommendations.some()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.catalog_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.config_path).toBeDefined - verificar valor espec칤fico",
            "expect(result.consumer_tests).toBeDefined - verificar valor espec칤fico",
            "expect(result.provider_tests).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.services).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.potential_contracts).toBeDefined - verificar valor espec칤fico",
            "expect(catalog.coverage).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[2/4] scaffold_contracts_pact - deve detectar m칰ltiplas APIs corretamente",
          "asserts": [
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(serviceNames.some()).toBe(true)",
            "expect(service.endpoints).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(service.endpoints.?).toHaveProperty(method)",
            "expect(service.endpoints.?).toHaveProperty(path)",
            "expect(contract).toHaveProperty(consumer)",
            "expect(contract).toHaveProperty(provider)",
            "expect(contract).toHaveProperty(priority)",
            "expect(unknown).toContain",
            "expect(contract.estimated_interactions).toBeGreaterThanOrEqual(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(service.endpoints).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[3/4] run_contracts_verify - deve verificar contratos gerados",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(result.verification_rate).toBeLessThanOrEqual(1)",
            "expect(result.total_interactions).toBeGreaterThan(0)",
            "expect(result.verified).toBeGreaterThanOrEqual(0)",
            "expect(result.failed).toBeGreaterThanOrEqual(0)",
            "expect(result.report_path).toBeDefined",
            "expect(existsSync()).toBe(true)",
            "expect(report.timestamp).toBeDefined",
            "expect(report.product).toBe(testProduct)",
            "expect(report.language).toBe(typescript)",
            "expect(report.total_contracts).toBeGreaterThan(0)",
            "expect(report.total_interactions).toBeGreaterThan(0)",
            "expect(report.verification_rate).toBeGreaterThanOrEqual(0)",
            "expect(report.results).toBeDefined",
            "expect(Array.isArray()).toBe(true)",
            "expect(report.duration_total_ms).toBeGreaterThan(0)",
            "expect(result.recommendations).toBeDefined",
            "expect(result.recommendations.length).toBeGreaterThan(0)",
            "expect(existsSync()).toBe(true)",
            "expect(mdContent).toContain(Contract Verification Report)",
            "expect(mdContent).toContain(Summary)",
            "expect(mdContent).toContain(Verification Rate)",
            "expect(mdContent).toContain"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": [
            "expect(result.report_path).toBeDefined - verificar valor espec칤fico",
            "expect(report.timestamp).toBeDefined - verificar valor espec칤fico",
            "expect(report.results).toBeDefined - verificar valor espec칤fico",
            "expect(result.recommendations).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-3-cdc-pact.e2e.test.ts",
          "title": "[4/4] FULL PIPELINE - scaffold + verify funcionam em sequ칡ncia",
          "asserts": [
            "expect(scaffoldResult.ok).toBe(true)",
            "expect(scaffoldResult.total_contracts).toBeGreaterThan(0)",
            "expect(configContent).toContain(pact-broker.example.com)",
            "expect(verifyResult.ok).toBe(true)",
            "expect(verifyResult.total_interactions).toBe(6)",
            "expect(verifyResult.verification_rate).toBeGreaterThan(0)",
            "expect(report.total_contracts).toBe(3)",
            "expect(report.total_interactions).toBe(6)",
            "expect(report.verified).toBeGreaterThanOrEqual(0)",
            "expect(report.failed).toBeGreaterThanOrEqual(0)",
            "expect(unknown).toBe(6)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[FULL PIPELINE] FASE 1 + FASE 2 completa",
          "asserts": [
            "expect(cujResult.ok).toBe(true)",
            "expect(slosResult.ok).toBe(true)",
            "expect(riskResult.ok).toBe(true)",
            "expect(portfolioResult.ok).toBe(true)",
            "expect(portfolioResult.output).toContain(PORTFOLIO-PLAN.md)",
            "expect(existsSync()).toBe(true)",
            "expect(portfolioResult.recommendations_count).toBeGreaterThanOrEqual(0)",
            "expect(reportContent).toContain(# Test Portfolio Plan)",
            "expect(reportContent).toContain(## 游늵 Current State)",
            "expect(reportContent).toContain(## 游꿢 Target Distribution)",
            "expect(reportContent).toContain(## 游꿢 Module Recommendations)",
            "expect(reportContent).toContain(## 九 Action Items)",
            "expect(reportContent).toContain(Fowler)",
            "expect(reportContent).toContain(70%)",
            "expect(reportContent).toContain(20%)",
            "expect(reportContent).toContain(10%)",
            "expect(reportContent).toContain(| Test Type | Count | Percentage | Target | Gap |)",
            "expect(reportContent).toContain(Unit)",
            "expect(reportContent).toContain(Integration)",
            "expect(reportContent).toContain(E2E)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[VALIDATION] Portfolio plan deve ter estrutura correta",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(content).toContain(section)",
            "expect(content).toMatch(/\\/\\\\/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[INTEGRATION] Recommendations devem estar baseadas em riscos",
          "asserts": [
            "expect(portfolioContent).toContain(游뚿 Top 5 Critical Risks)",
            "expect(portfolioContent).toContain(Module Recommendations)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-2-portfolio-plan.e2e.test.ts",
          "title": "[METRICS] Distribui칞칚o deve somar 100%",
          "asserts": [
            "expect(content).toContain(Current State)",
            "expect(total).toBeGreaterThanOrEqual(99.9)",
            "expect(total).toBeLessThanOrEqual(100.1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[1/3] catalog_cujs deve gerar cuj-catalog.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.cujs_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(cuj-catalog.json)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog).toHaveProperty(timestamp)",
            "expect(catalog).toHaveProperty(repo)",
            "expect(catalog).toHaveProperty(product)",
            "expect(catalog).toHaveProperty(cujs)",
            "expect(Array.isArray()).toBe(true)",
            "expect(catalog.cujs.length).toBeGreaterThan(0)",
            "expect(firstCUJ).toHaveProperty(id)",
            "expect(firstCUJ).toHaveProperty(name)",
            "expect(firstCUJ).toHaveProperty(criticality)",
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[2/3] define_slos deve gerar slos.json baseado em CUJs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.slos_count).toBeGreaterThan(0)",
            "expect(result.output).toContain(slos.json)",
            "expect(existsSync()).toBe(true)",
            "expect(slos).toHaveProperty(timestamp)",
            "expect(slos).toHaveProperty(repo)",
            "expect(slos).toHaveProperty(product)",
            "expect(slos).toHaveProperty(slos)",
            "expect(slos).toHaveProperty(defaults_applied)",
            "expect(unknown).toBe(boolean)",
            "expect(firstSLO).toHaveProperty(cuj_id)",
            "expect(firstSLO).toHaveProperty(error_rate_max)",
            "expect(firstSLO).toHaveProperty(availability_min)",
            "expect(firstSLO.error_rate_max).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.error_rate_max).toBeLessThanOrEqual(1)",
            "expect(firstSLO.availability_min).toBeGreaterThanOrEqual(0)",
            "expect(firstSLO.availability_min).toBeLessThanOrEqual(1)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[3/3] risk_register deve gerar risk-register.json cruzando CUJs + SLOs",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.total_risks).toBeGreaterThan(0)",
            "expect(result.output).toContain(risk-register.json)",
            "expect(existsSync()).toBe(true)",
            "expect(riskReg).toHaveProperty(timestamp)",
            "expect(riskReg).toHaveProperty(repo)",
            "expect(riskReg).toHaveProperty(product)",
            "expect(riskReg).toHaveProperty(risks)",
            "expect(riskReg).toHaveProperty(top_5_critical)",
            "expect(riskReg).toHaveProperty(total_risk_score)",
            "expect(riskReg).toHaveProperty(coverage_gaps)",
            "expect(Array.isArray()).toBe(true)",
            "expect(riskReg.top_5_critical.length).toBeLessThanOrEqual(5)",
            "expect(unknown).toBe(string)",
            "expect(firstRisk).toHaveProperty(id)",
            "expect(firstRisk).toHaveProperty(cuj_id)",
            "expect(firstRisk).toHaveProperty(title)",
            "expect(firstRisk).toHaveProperty(description)",
            "expect(firstRisk).toHaveProperty(impact)",
            "expect(firstRisk).toHaveProperty(probability)",
            "expect(firstRisk).toHaveProperty(risk_score)",
            "expect(firstRisk).toHaveProperty(affected_modules)",
            "expect(firstRisk).toHaveProperty(mitigation_strategies)",
            "expect(firstRisk).toHaveProperty(recommended_tests)",
            "expect(firstRisk.risk_score).toBeGreaterThanOrEqual(0)",
            "expect(firstRisk.risk_score).toBeLessThanOrEqual(100)",
            "expect(unknown).toContain",
            "expect(unknown).toContain",
            "expect(validTests).toContain(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/phase-1-cuj-slo-risk.e2e.test.ts",
          "title": "[FULL] Pipeline completo deve criar 3 arquivos consistentes",
          "asserts": [
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(existsSync()).toBe(true)",
            "expect(catalog.cujs.length).toBe",
            "expect(catalog.cujs.length).toBe",
            "expect(sloIds.has()).toBe(true)",
            "expect(r.id).toBe",
            "expect(cujIds.has()).toBe(true)",
            "expect(riskIds.has()).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)",
            "expect(result.final_params.mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)",
            "expect(result.final_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)",
            "expect(result.final_params.mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect RUN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect FULL mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(full)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect ANALYZE mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should detect PLAN mode from ",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.detected_mode).toBe(plan)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract repo override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.final_params.repo).toBe(tempDir)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract mode override",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.mode).toBe(run)",
            "expect(result.final_params.mode).toBe(run)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should extract multiple overrides",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.extracted_params.repo).toBe(tempDir)",
            "expect(result.extracted_params.product).toBe(TestApp)",
            "expect(result.extracted_params.mode).toBe(analyze)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should apply defaults when no override present",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.repo).toBe(tempDir)",
            "expect(result.final_params.product).toBe(DefaultProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should prioritize explicit overrides over defaults",
          "asserts": [
            "expect(result.success).toBe(true)",
            "expect(result.final_params.product).toBe(ExplicitProduct)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle empty query gracefully",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/nl-command-flow.spec.ts",
          "title": "should handle query with only whitespace",
          "asserts": [
            "expect(result).toBeDefined",
            "expect(result.success).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico",
            "expect(result.success).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in empty repo",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work in repo with package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.context.hasPackageJson).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should work with existing mcp-settings.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute ANALYZE mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should execute PLAN mode correctly",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.outputs).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should auto-detect repo from cwd",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.repoPath).toBeDefined",
            "expect(result.context.repoPath.length).toBeGreaterThan(0)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.repoPath).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should infer product from package.json",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should create qa/<product>/ directory structure",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context).toBeDefined",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context).toBeDefined - verificar valor espec칤fico",
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should generate all expected artifacts in FULL mode",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.outputs).toBeDefined",
            "expect(result.steps.length).toBeGreaterThan(0)",
            "expect(result.steps).toContain(analyze)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.outputs).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle invalid repo path gracefully",
          "asserts": [
            "expect(result.ok).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle missing product name",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.product).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.context.product).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should handle filesystem errors gracefully",
          "asserts": [
            "expect(result.ok).toBeDefined"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": [
            "expect(result.ok).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect vitest framework",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.testFramework).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "should detect existing test files",
          "asserts": [
            "expect(result.ok).toBe(true)",
            "expect(result.context.hasTests).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/auto-full-cycle.spec.ts",
          "title": "example",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should get users",
          "asserts": [
            "expect(getUsers).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(getUsers).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "should login successfully",
          "asserts": [],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve executar analyze e detectar endpoints",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve criar analyze.json com findings",
          "asserts": [
            "expect(exists).toBe(true)",
            "expect(content).toHaveProperty(findings)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve permitir pipeline completo: analyze  coverage  plan",
          "asserts": [
            "expect(analyzeResult.findings).toBeDefined",
            "expect(coverageResult.pyramid).toBeDefined",
            "expect(planResult.plan).toBeDefined",
            "expect(exists).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(analyzeResult.findings).toBeDefined - verificar valor espec칤fico",
            "expect(coverageResult.pyramid).toBeDefined - verificar valor espec칤fico",
            "expect(planResult.plan).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve usar configura칞칚o centralizada de mcp-settings.json",
          "asserts": [
            "expect(result.findings).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result.findings).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "qa/mcp-Quality-CLI/tests/e2e/analyze-coverage-flow.spec.ts",
          "title": "deve validar health da pir칙mide corretamente",
          "asserts": [
            "expect(unknown).toContain"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar projeto TypeScript com package.json",
          "asserts": [
            "expect(result).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar projeto TypeScript com tsconfig.json",
          "asserts": [
            "expect(result).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve retornar false para diret칩rio sem arquivos TypeScript",
          "asserts": [
            "expect(result).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar vitest via vitest.config.ts",
          "asserts": [
            "expect(result).toBe(vitest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar jest via jest.config.js",
          "asserts": [
            "expect(result).toBe(jest)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve retornar null se n칚o detectar framework",
          "asserts": [
            "expect(result).toBeNull"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir fun칞칚o exportada simples",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})",
            "expect(functions.?.criticality).toBe(CRITICAL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir fun칞칚o async",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir arrow function exportada",
          "asserts": [
            "expect(functions).toHaveLength(1)",
            "expect(functions.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve determinar criticality CRITICAL para validadores",
          "asserts": [
            "expect(functions.?.criticality).toBe(CRITICAL)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve determinar criticality HIGH para fun칞칫es de escrita",
          "asserts": [
            "expect(functions.?.criticality).toBe(HIGH)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve ignorar arquivos de teste",
          "asserts": [
            "expect(functions).toHaveLength(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir testes com it()",
          "asserts": [
            "expect(tests).toHaveLength(1)",
            "expect(tests.?).toMatchObject({...})",
            "expect(tests.?.assertions).toHaveLength(1)",
            "expect(tests.?.assertions.?.type).toBe(toEqual)",
            "expect(tests.?.assertions.?.isWeak).toBe(false)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should parse valid JSON",
          "asserts": [
            "expect(result).toEqual({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve descobrir testes com test()",
          "asserts": [
            "expect(tests).toHaveLength(1)",
            "expect(tests.?.name).toBe(adds two numbers)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "adds two numbers",
          "asserts": [
            "expect(unknown).toBe(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar spies",
          "asserts": [
            "expect(tests.?.hasSpies).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should log message",
          "asserts": [
            "expect(spy).toHaveBeenCalledWith(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar mocks",
          "asserts": [
            "expect(tests.?.hasMocks).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should fetch user",
          "asserts": [
            "expect(user).toEqual({...})"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar asser칞칫es fracas",
          "asserts": [
            "expect(tests.?.assertions.?.isWeak).toBe(true)",
            "expect(tests.?.assertions.?.type).toBe(toBeTruthy)"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(tests.?.assertions.?.type).toBe(toBeTruthy) - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "should be truthy",
          "asserts": [
            "expect(someValue).toBeTruthy"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(someValue).toBeTruthy - usar compara칞칚o expl칤cita"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar m칰ltiplas asser칞칫es",
          "asserts": [
            "expect(tests.?.assertions).toHaveLength(2)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "validates user",
          "asserts": [
            "expect(user.name).toBe(John)",
            "expect(user.age).toEqual(30)",
            "expect(user.email).toMatch(/@/)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar happy path com asser칞칫es fortes",
          "asserts": [
            "expect(matrix).toHaveLength(1)",
            "expect(matrix.?).toMatchObject({...})"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "adds two numbers",
          "asserts": [
            "expect(add()).toBe(3)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar error handling",
          "asserts": [
            "expect(matrix.?.error).toBe(true)"
          ],
          "gaps": [
            "Verificar que erro 칠 lan칞ado",
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "throws on negative age",
          "asserts": [
            "expect(unknown).toThrow(Invalid age)"
          ],
          "gaps": [
            "Verificar mensagem do erro"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar edge cases por nome do teste",
          "asserts": [
            "expect(matrix.?.edge).toBe(true)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "handles empty string",
          "asserts": [
            "expect(getLength()).toBe(0)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve detectar side effects com spies",
          "asserts": [
            "expect(matrix.?.sideEffects).toBe(true)"
          ],
          "gaps": [
            "Verificar intera칞칫es com mocks (toHaveBeenCalledWith)"
          ],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "logs message to console",
          "asserts": [
            "expect(spy).toHaveBeenCalledWith(test)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve identificar gaps de cen치rios faltantes",
          "asserts": [
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Error Handling)",
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Edge Cases)"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "fetches data",
          "asserts": [
            "expect(result).toBeDefined"
          ],
          "gaps": [],
          "weakAsserts": [
            "expect(result).toBeDefined - verificar valor espec칤fico"
          ]
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "deve sugerir side effects para fun칞칫es com verbos de a칞칚o",
          "asserts": [
            "expect(matrix.?.gaps).toContain(Falta cen치rio: Side Effects (fun칞칚o tem efeitos colaterais))"
          ],
          "gaps": [],
          "weakAsserts": []
        },
        {
          "file": "src/engine/adapters/__tests__/typescript.test.ts",
          "title": "creates user",
          "asserts": [
            "expect(user.name).toBe(John)"
          ],
          "gaps": [],
          "weakAsserts": []
        }
      ],
      "gaps": [
        "丘멆잺  115 assertion(s) fraca(s) detectada(s)"
      ]
    }
  ],
  "recommendations": [
    "游댮 Apenas 51.7% das fun칞칫es t칡m teste de happy path",
    "游리 Apenas 35.0% das fun칞칫es t칡m testes de edge cases",
    "游리 Apenas 33.9% das fun칞칫es t칡m testes de error handling",
    "游댮 52 fun칞칚o(칫es) cr칤tica(s) com gaps l칩gicos"
  ],
  "reportPath": "qa/mcp-Quality-CLI/tests/reports/TEST-QUALITY-LOGICAL-REPORT.md",
  "patches": [
    "qa/mcp-Quality-CLI/patches/add-tests-validateRequiredFlags.patch",
    "qa/mcp-Quality-CLI/patches/add-tests-generateCommandHelp.patch",
    "qa/mcp-Quality-CLI/patches/add-tests-validate.patch",
    "qa/mcp-Quality-CLI/patches/add-tests-sloCanaryCheck.patch",
    "qa/mcp-Quality-CLI/patches/add-tests-selfCheck.patch"
  ]
}