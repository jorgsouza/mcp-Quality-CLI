/**
 * Pact Adapter - Multi-language Contract Testing Support
 * 
 * Gera configuração e templates para:
 * - TypeScript/JavaScript: @pact-foundation/pact
 * - Python: pact-python
 * - Java: pact-jvm
 * - Go: pact-go (futuro)
 * 
 * Baseado em: https://docs.pact.io/
 */

import type { PactConfig, PactInteraction, ServiceIntegration } from '../schemas/contract-schemas.js';

export interface PactAdapterConfig {
  language: 'typescript' | 'javascript' | 'python' | 'java' | 'go';
  framework: string;
  consumerName: string;
  providerName: string;
  baseUrl: string;
  outputDir: string;
  pactBrokerUrl?: string;
  pactBrokerToken?: string;
}

export interface GeneratedPactFiles {
  configFile: { path: string; content: string };
  consumerTest: { path: string; content: string };
  providerTest: { path: string; content: string };
  packageUpdates?: { dependencies: Record<string, string> };
}

/**
 * Pact Adapter Interface
 */
export interface PactAdapter {
  language: string;
  
  /**
   * Gera pact.config file específico da linguagem
   */
  generatePactConfig(config: PactAdapterConfig): string;
  
  /**
   * Gera consumer test file
   */
  generateConsumerTest(params: {
    consumerName: string;
    providerName: string;
    interactions: PactInteraction[];
    outputDir: string;
  }): string;
  
  /**
   * Gera provider verification test
   */
  generateProviderTest(params: {
    providerName: string;
    consumerNames: string[];
    baseUrl: string;
    pactDir: string;
    stateHandlers?: Record<string, string>;
  }): string;
  
  /**
   * Retorna dependências necessárias
   */
  getRequiredDependencies(): Record<string, string>;
  
  /**
   * Retorna comandos para executar testes
   */
  getTestCommands(): {
    consumer: string;
    provider: string;
    publish?: string;
  };
}

/**
 * TypeScript/JavaScript Pact Adapter
 */
export class TypeScriptPactAdapter implements PactAdapter {
  language = 'typescript';
  
  generatePactConfig(config: PactAdapterConfig): string {
    return `/**
 * Pact Configuration
 * Generated by mcp-Quality-CLI
 */

import { LogLevel } from '@pact-foundation/pact';
import path from 'path';

export const pactConfig = {
  consumer: '${config.consumerName}',
  provider: '${config.providerName}',
  
  // Pact file output
  dir: path.resolve(process.cwd(), '${config.outputDir}'),
  
  // Logging
  log: path.resolve(process.cwd(), '${config.outputDir}/logs/pact.log'),
  logLevel: 'info' as LogLevel,
  
  // Pact Broker (opcional)
  ${config.pactBrokerUrl ? `pactBrokerUrl: '${config.pactBrokerUrl}',` : '// pactBrokerUrl: undefined,'}
  ${config.pactBrokerToken ? `pactBrokerToken: '${config.pactBrokerToken}',` : '// pactBrokerToken: undefined,'}
  ${config.pactBrokerUrl ? `publishVerificationResult: true,` : '// publishVerificationResult: false,'}
  
  // Specification version
  spec: 2,
};

export default pactConfig;
`;
  }
  
  generateConsumerTest(params: {
    consumerName: string;
    providerName: string;
    interactions: PactInteraction[];
    outputDir: string;
  }): string {
    const { consumerName, providerName, interactions, outputDir } = params;
    
    const interactionTests = interactions.map((interaction, idx) => {
      const requestBody = interaction.request.body 
        ? `      body: ${JSON.stringify(interaction.request.body, null, 8)},`
        : '';
      
      const responseBody = interaction.response.body
        ? `      body: ${JSON.stringify(interaction.response.body, null, 8)},`
        : '';
      
      return `  it('${interaction.description}', async () => {
    // Arrange - Setup interaction expectation
    await provider.addInteraction({
      state: '${interaction.providerState || 'default state'}',
      uponReceiving: '${interaction.description}',
      withRequest: {
        method: '${interaction.request.method}',
        path: '${interaction.request.path}',
${interaction.request.headers ? `        headers: ${JSON.stringify(interaction.request.headers, null, 8)},` : ''}
${interaction.request.query ? `        query: ${JSON.stringify(interaction.request.query, null, 8)},` : ''}
${requestBody}
      },
      willRespondWith: {
        status: ${interaction.response.status},
${interaction.response.headers ? `        headers: ${JSON.stringify(interaction.response.headers, null, 8)},` : ''}
${responseBody}
      },
    });
    
    // Act - Make actual request
    const response = await fetch(\`\${provider.mockService.baseUrl}${interaction.request.path}\`, {
      method: '${interaction.request.method}',
${interaction.request.headers ? `      headers: ${JSON.stringify(interaction.request.headers, null, 6)},` : ''}
${interaction.request.body ? `      body: JSON.stringify(${JSON.stringify(interaction.request.body)}),` : ''}
    });
    
    // Assert
    expect(response.status).toBe(${interaction.response.status});
    ${interaction.response.body ? `
    const data = await response.json();
    expect(data).toMatchObject(${JSON.stringify(interaction.response.body, null, 4)});
    ` : ''}
  });
`;
    }).join('\n');
    
    return `/**
 * ${consumerName} Consumer Contract Tests
 * Tests expectations against ${providerName} provider
 * 
 * Generated by mcp-Quality-CLI
 */

import { Pact } from '@pact-foundation/pact';
import path from 'path';
import { pactConfig } from './pact.config';

describe('${consumerName} → ${providerName} Contract', () => {
  const provider = new Pact({
    consumer: pactConfig.consumer,
    provider: pactConfig.provider,
    port: 3456, // Mock server port
    log: pactConfig.log,
    dir: pactConfig.dir,
    logLevel: pactConfig.logLevel,
    spec: pactConfig.spec,
  });

  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());

${interactionTests}
});
`;
  }
  
  generateProviderTest(params: {
    providerName: string;
    consumerNames: string[];
    baseUrl: string;
    pactDir: string;
    stateHandlers?: Record<string, string>;
  }): string {
    const { providerName, consumerNames, baseUrl, pactDir, stateHandlers } = params;
    
    const stateHandlerCode = stateHandlers 
      ? `
  // State handlers
  const stateHandlers = {
${Object.entries(stateHandlers).map(([state, handler]) => 
  `    '${state}': async () => {
      // ${handler}
      // Implementar setup do estado aqui
      return Promise.resolve();
    },`
).join('\n')}
  };
`
      : `
  // State handlers (implementar conforme necessário)
  const stateHandlers = {};
`;
    
    return `/**
 * ${providerName} Provider Verification Tests
 * Verifies contracts from consumers: ${consumerNames.join(', ')}
 * 
 * Generated by mcp-Quality-CLI
 */

import { Verifier } from '@pact-foundation/pact';
import path from 'path';
import { pactConfig } from './pact.config';

describe('${providerName} Provider Verification', () => {
${stateHandlerCode}

  it('should verify contracts from all consumers', async () => {
    const verifier = new Verifier({
      provider: '${providerName}',
      
      // URL do provider em execução
      providerBaseUrl: '${baseUrl}',
      
      // Pact files gerados pelos consumers
      pactUrls: [
${consumerNames.map(consumer => 
  `        path.resolve(__dirname, '${pactDir}/${consumer}-${providerName}.json'),`
).join('\n')}
      ],
      
      // State handlers
      stateHandlers: stateHandlers,
      
      // Logging
      logLevel: 'info',
      
      // Pact Broker (se configurado)
      // pactBrokerUrl: pactConfig.pactBrokerUrl,
      // pactBrokerToken: pactConfig.pactBrokerToken,
      // publishVerificationResult: pactConfig.publishVerificationResult,
      // providerVersion: process.env.GIT_COMMIT || '1.0.0',
    });
    
    const output = await verifier.verifyProvider();
    console.log('Pact Verification Complete:', output);
  }, 30000); // 30s timeout
});
`;
  }
  
  getRequiredDependencies(): Record<string, string> {
    return {
      '@pact-foundation/pact': '^12.0.0',
    };
  }
  
  getTestCommands() {
    return {
      consumer: 'npm test -- --testPathPattern=consumer.pact.spec',
      provider: 'npm test -- --testPathPattern=provider.pact.spec',
      publish: 'pact-broker publish ./pacts --consumer-app-version=$GIT_COMMIT --broker-base-url=$PACT_BROKER_URL --broker-token=$PACT_BROKER_TOKEN',
    };
  }
}

/**
 * Python Pact Adapter
 */
export class PythonPactAdapter implements PactAdapter {
  language = 'python';
  
  generatePactConfig(config: PactAdapterConfig): string {
    return `"""
Pact Configuration
Generated by mcp-Quality-CLI
"""

import os

PACT_CONFIG = {
    'consumer': '${config.consumerName}',
    'provider': '${config.providerName}',
    
    # Pact file output
    'pact_dir': os.path.join(os.getcwd(), '${config.outputDir}'),
    'log_dir': os.path.join(os.getcwd(), '${config.outputDir}/logs'),
    
    # Logging
    'log_level': 'INFO',
    
    # Pact Broker (optional)
    ${config.pactBrokerUrl ? `'pact_broker_url': '${config.pactBrokerUrl}',` : "# 'pact_broker_url': None,"}
    ${config.pactBrokerToken ? `'pact_broker_token': '${config.pactBrokerToken}',` : "# 'pact_broker_token': None,"}
    
    # Specification version
    'pact_spec_version': '2.0.0',
}
`;
  }
  
  generateConsumerTest(params: {
    consumerName: string;
    providerName: string;
    interactions: PactInteraction[];
    outputDir: string;
  }): string {
    const { consumerName, providerName, interactions } = params;
    
    const interactionTests = interactions.map((interaction, idx) => {
      return `    def test_${interaction.description.toLowerCase().replace(/\s+/g, '_')}(self, pact):
        """${interaction.description}"""
        # Arrange
        expected = {
            'status': ${interaction.response.status},
            ${interaction.response.headers ? `'headers': ${JSON.stringify(interaction.response.headers)},` : ''}
            ${interaction.response.body ? `'body': ${JSON.stringify(interaction.response.body, null, 12)},` : ''}
        }
        
        (pact
         .given('${interaction.providerState || 'default state'}')
         .upon_receiving('${interaction.description}')
         .with_request('${interaction.request.method}', '${interaction.request.path}',
                       ${interaction.request.headers ? `headers=${JSON.stringify(interaction.request.headers)},` : ''}
                       ${interaction.request.body ? `body=${JSON.stringify(interaction.request.body)},` : ''})
         .will_respond_with(expected['status'],
                            ${interaction.response.headers ? `headers=expected['headers'],` : ''}
                            ${interaction.response.body ? `body=expected['body']` : ''}))
        
        # Act
        with pact:
            response = requests.${interaction.request.method.toLowerCase()}(
                f"{pact.uri}${interaction.request.path}",
                ${interaction.request.headers ? `headers=${JSON.stringify(interaction.request.headers)},` : ''}
                ${interaction.request.body ? `json=${JSON.stringify(interaction.request.body)},` : ''}
            )
            
            # Assert
            self.assertEqual(response.status_code, expected['status'])
            ${interaction.response.body ? `self.assertEqual(response.json(), expected['body'])` : ''}
`;
    }).join('\n\n');
    
    return `"""
${consumerName} Consumer Contract Tests
Tests expectations against ${providerName} provider

Generated by mcp-Quality-CLI
"""

import unittest
import requests
from pact import Consumer, Provider
from pact_config import PACT_CONFIG

pact = Consumer(PACT_CONFIG['consumer']).has_pact_with(
    Provider(PACT_CONFIG['provider']),
    pact_dir=PACT_CONFIG['pact_dir'],
    log_dir=PACT_CONFIG['log_dir']
)


class ${consumerName}ConsumerTest(unittest.TestCase):
    """Contract tests for ${consumerName} → ${providerName}"""

${interactionTests}


if __name__ == '__main__':
    unittest.main()
`;
  }
  
  generateProviderTest(params: {
    providerName: string;
    consumerNames: string[];
    baseUrl: string;
    pactDir: string;
    stateHandlers?: Record<string, string>;
  }): string {
    const { providerName, consumerNames, baseUrl, pactDir } = params;
    
    return `"""
${providerName} Provider Verification Tests
Verifies contracts from consumers: ${consumerNames.join(', ')}

Generated by mcp-Quality-CLI
"""

import os
from pact import Verifier
from pact_config import PACT_CONFIG


def test_provider_contract():
    """Verify all consumer contracts"""
    verifier = Verifier(
        provider='${providerName}',
        provider_base_url='${baseUrl}',
    )
    
    # Verify each consumer contract
    pact_files = [
${consumerNames.map(consumer => 
  `        os.path.join('${pactDir}', '${consumer}-${providerName}.json'),`
).join('\n')}
    ]
    
    for pact_file in pact_files:
        output, _ = verifier.verify_pacts(
            pact_file,
            enable_pending=False,
            publish_version=os.getenv('GIT_COMMIT', '1.0.0'),
            publish_verification_results=False,
        )
        
        print(f"Verified: {pact_file}")
        print(output)


if __name__ == '__main__':
    test_provider_contract()
`;
  }
  
  getRequiredDependencies(): Record<string, string> {
    return {
      'pact-python': '^2.0.0',
    };
  }
  
  getTestCommands() {
    return {
      consumer: 'pytest tests/contracts/*_consumer_test.py -v',
      provider: 'pytest tests/contracts/*_provider_test.py -v',
      publish: 'pact-broker publish ./pacts --consumer-app-version=$GIT_COMMIT --broker-base-url=$PACT_BROKER_URL --broker-token=$PACT_BROKER_TOKEN',
    };
  }
}

/**
 * Java Pact Adapter
 */
export class JavaPactAdapter implements PactAdapter {
  language = 'java';
  
  generatePactConfig(config: PactAdapterConfig): string {
    return `// Pact configuration is typically in pom.xml or build.gradle
// Generated by mcp-Quality-CLI

/*
 * Add to pom.xml:
 * 
 * <dependency>
 *   <groupId>au.com.dius.pact.consumer</groupId>
 *   <artifactId>junit5</artifactId>
 *   <version>4.6.0</version>
 *   <scope>test</scope>
 * </dependency>
 * 
 * <dependency>
 *   <groupId>au.com.dius.pact.provider</groupId>
 *   <artifactId>junit5</artifactId>
 *   <version>4.6.0</version>
 *   <scope>test</scope>
 * </dependency>
 */

package com.example.pact;

public class PactConfig {
    public static final String CONSUMER = "${config.consumerName}";
    public static final String PROVIDER = "${config.providerName}";
    public static final String PACT_DIR = "${config.outputDir}";
    ${config.pactBrokerUrl ? `public static final String PACT_BROKER_URL = "${config.pactBrokerUrl}";` : ''}
    ${config.pactBrokerToken ? `public static final String PACT_BROKER_TOKEN = "${config.pactBrokerToken}";` : ''}
}
`;
  }
  
  generateConsumerTest(params: {
    consumerName: string;
    providerName: string;
    interactions: PactInteraction[];
    outputDir: string;
  }): string {
    const { consumerName, providerName } = params;
    
    return `/**
 * ${consumerName} Consumer Contract Tests
 * Tests expectations against ${providerName} provider
 * 
 * Generated by mcp-Quality-CLI
 */

package com.example.pact.consumer;

import au.com.dius.pact.consumer.dsl.PactDslWithProvider;
import au.com.dius.pact.consumer.junit5.PactConsumerTestExt;
import au.com.dius.pact.consumer.junit5.PactTestFor;
import au.com.dius.pact.core.model.V4Pact;
import au.com.dius.pact.core.model.annotations.Pact;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import static org.junit.jupiter.api.Assertions.assertEquals;

@ExtendWith(PactConsumerTestExt.class)
@PactTestFor(providerName = "${providerName}")
public class ${consumerName}ConsumerTest {

    @Pact(consumer = "${consumerName}")
    public V4Pact createPact(PactDslWithProvider builder) {
        return builder
            .uponReceiving("a request for data")
                .path("/api/data")
                .method("GET")
            .willRespondWith()
                .status(200)
                .body("{\\"status\\": \\"success\\"}")
            .toPact(V4Pact.class);
    }

    @Test
    @PactTestFor(pactMethod = "createPact")
    void testContract(MockServer mockServer) {
        // Test implementation here
        // Use mockServer.getUrl() to make requests
    }
}
`;
  }
  
  generateProviderTest(params: {
    providerName: string;
    consumerNames: string[];
    baseUrl: string;
    pactDir: string;
  }): string {
    const { providerName, baseUrl } = params;
    
    return `/**
 * ${providerName} Provider Verification Tests
 * 
 * Generated by mcp-Quality-CLI
 */

package com.example.pact.provider;

import au.com.dius.pact.provider.junit5.HttpTestTarget;
import au.com.dius.pact.provider.junit5.PactVerificationContext;
import au.com.dius.pact.provider.junit5.PactVerificationInvocationContextProvider;
import au.com.dius.pact.provider.junitsupport.Provider;
import au.com.dius.pact.provider.junitsupport.loader.PactFolder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;

@Provider("${providerName}")
@PactFolder("pacts")
public class ${providerName}ProviderTest {

    @BeforeEach
    void setUp(PactVerificationContext context) {
        context.setTarget(new HttpTestTarget("${baseUrl.replace('http://', '').replace('https://', '')}", 80));
    }

    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(PactVerificationContext context) {
        context.verifyInteraction();
    }
}
`;
  }
  
  getRequiredDependencies(): Record<string, string> {
    return {
      'au.com.dius.pact.consumer:junit5': '4.6.0',
      'au.com.dius.pact.provider:junit5': '4.6.0',
    };
  }
  
  getTestCommands() {
    return {
      consumer: 'mvn test -Dtest=*ConsumerTest',
      provider: 'mvn test -Dtest=*ProviderTest',
      publish: 'mvn pact:publish',
    };
  }
}

/**
 * Factory: Retorna adapter correto baseado na linguagem
 */
export function getPactAdapter(language: string): PactAdapter {
  switch (language.toLowerCase()) {
    case 'typescript':
    case 'javascript':
      return new TypeScriptPactAdapter();
    case 'python':
      return new PythonPactAdapter();
    case 'java':
      return new JavaPactAdapter();
    default:
      console.warn(`⚠️  Pact adapter for ${language} not implemented yet, using TypeScript as fallback`);
      return new TypeScriptPactAdapter();
  }
}

/**
 * Extrai nome do serviço de um endpoint
 * Exemplo: "/api/users/123" → "users"
 */
export function extractServiceName(endpoint: string): string {
  const parts = endpoint.split('/').filter(Boolean);
  if (parts[0] === 'api' && parts.length > 1) {
    return parts[1];
  }
  return parts[0] || 'service';
}

/**
 * Detecta integrações HTTP no código (fetch, axios, requests, etc.)
 */
export async function detectHttpIntegrations(repoPath: string, language: string): Promise<ServiceIntegration[]> {
  // TODO: Implementar detecção de fetch(), axios.get(), requests.get(), etc.
  // Por enquanto retorna array vazio, será implementado no scaffold-contracts-pact.ts
  return [];
}
